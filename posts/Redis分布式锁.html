<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis分布式锁 | cloud_fly blog</title><meta name="author" content="cloud_fly"><meta name="copyright" content="cloud_fly"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是分布式锁分布式锁是实现分布式系统之间共享资源的一种方式  Redis实现分布式锁的要点加锁： 12345set lock_key owner nx px n     &#x2F;*        不能用setnx，因为setnx不能带过期参数        px n 表示设置过期时间是n秒    *&#x2F;   解锁： 先判断owner是否为加锁客户端，是的话才能将lock_key删除 采用lua脚本让两个">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis分布式锁">
<meta property="og:url" content="https://www.cdfy.top/posts/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html">
<meta property="og:site_name" content="cloud_fly blog">
<meta property="og:description" content="什么是分布式锁分布式锁是实现分布式系统之间共享资源的一种方式  Redis实现分布式锁的要点加锁： 12345set lock_key owner nx px n     &#x2F;*        不能用setnx，因为setnx不能带过期参数        px n 表示设置过期时间是n秒    *&#x2F;   解锁： 先判断owner是否为加锁客户端，是的话才能将lock_key删除 采用lua脚本让两个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.cdfy.top/img/website/avatar.jpg">
<meta property="article:published_time" content="2025-01-13T15:05:51.000Z">
<meta property="article:modified_time" content="2025-01-18T16:10:22.037Z">
<meta property="article:author" content="cloud_fly">
<meta property="article:tag" content="Redis - 数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.cdfy.top/img/website/avatar.jpg"><link rel="shortcut icon" href="/img/website/favicon.jpg"><link rel="canonical" href="https://www.cdfy.top/posts/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html"><link rel="preconnect" href="//cdnjs.cloudflare.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":3,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdnjs.cloudflare.com/ajax/libs/egjs-infinitegrid/4.12.0/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis分布式锁',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/modify.css"><link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/website/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/website/loading.gif" data-original="/img/website/avatar.jpg" onerror="onerror=null;src='/img/website/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">cloud_fly blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis分布式锁</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Redis分布式锁</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-13T15:05:51.000Z" title="发表于 2025-01-13 23:05:51">2025-01-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-18T16:10:22.037Z" title="更新于 2025-01-19 00:10:22">2025-01-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">2.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>9分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h1><p>分布式锁是实现分布式系统之间共享资源的一种方式</p>
<p><img src="/img/website/loading.gif" data-original="/img/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/img1.png" alt="alt text"></p>
<h1 id="Redis实现分布式锁的要点"><a href="#Redis实现分布式锁的要点" class="headerlink" title="Redis实现分布式锁的要点"></a>Redis实现分布式锁的要点</h1><p>加锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set lock_key owner nx px n </span><br><span class="line">    /*</span><br><span class="line">        不能用setnx，因为setnx不能带过期参数</span><br><span class="line">        px n 表示设置过期时间是n秒</span><br><span class="line">    */ </span><br></pre></td></tr></table></figure>

<p>解锁：</p>
<p>先判断owner是否为加锁客户端，是的话才能将lock_key删除</p>
<p>采用lua脚本让两个操作变成一个原子操作：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 先判断owner是否为加锁客户端</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, KEYS[<span class="number">1</span>]) // 将lock_key删除</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h1 id="为什么需要owner"><a href="#为什么需要owner" class="headerlink" title="为什么需要owner"></a>为什么需要owner</h1><p>存在服务A释放掉服务B的锁的可能：</p>
<p>比如服务A获取了锁，由于业务流程比较长，耗时久，导致锁过期。这时候服务B获取了锁，准备去执行，这个时候服务A恢复了过来并做完了业务，就会释放锁，但是业务B还在执行。</p>
<h1 id="lua一定能保证原子性？"><a href="#lua一定能保证原子性？" class="headerlink" title="lua一定能保证原子性？"></a>lua一定能保证原子性？</h1><p>lua本身不具有原子性，上面提到的用lua脚本保证原子性是因为Redis是单线程的，一个流程放进lua来执行，相当于是打包在一起，Redis执行他的流程不会被其他请求打断，所以保证了原子性</p>
<h1 id="Redis分布式锁优缺点"><a href="#Redis分布式锁优缺点" class="headerlink" title="Redis分布式锁优缺点"></a>Redis分布式锁优缺点</h1><p>优点：</p>
<ul>
<li>性能高效：选择缓存实现</li>
<li>实现方便：Redis提供了setnx方法</li>
<li>避免单点故障：Redis是跨集群部署</li>
</ul>
<p>缺点：</p>
<ul>
<li>超时时间不好设置</li>
<li>Redis主从复制的数据是异步复制的，这样导致分布式锁不可靠：Redis主节点获取到锁后，没有同步到其他节点，在主节点宕机后，此时新的节点依然可以获取到锁，所以多个应用服务获取到了锁</li>
</ul>
<h1 id="Redis分布式锁的超时时间怎么设置"><a href="#Redis分布式锁的超时时间怎么设置" class="headerlink" title="Redis分布式锁的超时时间怎么设置"></a>Redis分布式锁的超时时间怎么设置</h1><p>基于续约的方式设置超时时间。先给锁设置一个超时时间，然后启动一个守护线程，让守护线程在一段时间后，重新设置这个锁的超时时间， 比如Redisson的看门狗机制。<br>当然也会设置一个最大续约次数，避免因为服务异常导致无限续约，锁得不到释放</p>
<h1 id="Redisson的看门狗机制"><a href="#Redisson的看门狗机制" class="headerlink" title="Redisson的看门狗机制"></a>Redisson的看门狗机制</h1><p>看门狗机制是Redission提供的一种自动延期机制，这个机制使得Redission提供的分布式锁是可以自动续期的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">lockWatchdogTimeout</span> <span class="operator">=</span> <span class="number">30</span> * <span class="number">1000</span>; <span class="comment">//看门狗机制提供的默认超时时间是30*1000毫秒，也就是30秒</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> tryLock(waitTime, -<span class="number">1</span>, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在Redis中，锁的waiiTime表示等待获取锁的时间，而leaseTime表示锁的持有时间。 当一个线程或进程尝试获取锁时，如果锁已被其他线程或进程持有，则会等待一段时间（waitTime）后再次尝试获取锁。 </li>
<li>如果在这段时间内锁被释放，则当前线程或进程可以成功获取锁，否则需要等待下一次尝试。 一旦锁被某个线程或进程获取成功，该线程或进程拥有锁的持有权，持有时间为leaseTime</li>
</ul>
<p>看门狗流程：</p>
<ol>
<li>在获取锁的时候，不能指定leaseTime或者只能将leaseTime设置为-1，这样才能开启看门狗机制。</li>
<li>在tryLockInnerAsync方法里尝试获取锁，如果获取锁成功调用scheduleExpirationRenewal执行看门狗机制</li>
<li>在scheduleExpirationRenewal中比较重要的方法就是renewExpiration，当线程第一次获取到锁（也就是不是重入的情况），那么就会调用renewExpiration方法开启看门狗机制</li>
<li>在renewExpiration会为当前锁添加一个延迟任务task，这个延迟任务会在10s后执行，执行的任务就是将锁的有效期刷新为30s（这是看门狗机制的默认锁释放时间）</li>
<li>并且在任务最后还会继续递归调用renewExpiration</li>
</ol>
<p>看门狗的作用，考虑以下三种情况：</p>
<ul>
<li>如果没有设置锁的过期时间，单靠逻辑来释放锁，就会出现获取锁的节点宕机时，锁没有释放，造成死锁</li>
<li>如果设置了某个过期时间，在没有宕机的情况下，线程发生了阻塞，就会导致锁过期自动释放，带来一些其他的问题</li>
<li>如果设置了看门狗，在没有宕机时，如果发生了阻塞，那么看门狗就能一直给线程续时间；如果宕机了，看门狗不起作用，过了有效期之后就会自动释放掉锁，不会造成死锁</li>
</ul>
<p>底层源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Long <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(tryAcquireAsync(waitTime, leaseTime, unit, threadId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果获取锁失败，返回的结果是这个key的剩余有效期</span></span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture = <span class="built_in">this</span>.tryLockInnerAsync(waitTime, <span class="built_in">this</span>.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        <span class="comment">//上面获取锁回调成功之后，执行这代码块的内容</span></span><br><span class="line">        ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">            <span class="comment">//不存在异常</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//剩余有效期为null</span></span><br><span class="line">                <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//这个函数是解决最长等待有效期的问题</span></span><br><span class="line">                    <span class="built_in">this</span>.scheduleExpirationRenewal(threadId);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;T&gt; RFuture&lt;T&gt; <span class="title function_">tryLockInnerAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;</span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">                          <span class="comment">// 锁不存在，则往redis中设置锁信息</span></span><br><span class="line">                          <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                          <span class="comment">// 锁存在</span></span><br><span class="line">                          <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,</span><br><span class="line">                          Collections.singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ExpirationEntry&gt; EXPIRATION_RENEWAL_MAP = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleExpirationRenewal</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpirationEntry</span>();</span><br><span class="line">    <span class="comment">//这里EntryName是指锁的名称</span></span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">oldEntry</span> <span class="operator">=</span> (ExpirationEntry)EXPIRATION_RENEWAL_MAP.putIfAbsent(<span class="built_in">this</span>.getEntryName(), entry);</span><br><span class="line">    <span class="keyword">if</span> (oldEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//重入</span></span><br><span class="line">        <span class="comment">//将线程ID加入</span></span><br><span class="line">        oldEntry.addThreadId(threadId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将线程ID加入</span></span><br><span class="line">        entry.addThreadId(threadId);</span><br><span class="line">        <span class="comment">//续约</span></span><br><span class="line">        <span class="built_in">this</span>.renewExpiration();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//先从map里得到这个ExpirationEntry</span></span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> (ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(<span class="built_in">this</span>.getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//这个是一个延迟任务</span></span><br><span class="line">        <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> <span class="built_in">this</span>.commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="comment">//延迟任务内容</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">//拿出ExpirationEntry</span></span><br><span class="line">                <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> (ExpirationEntry)RedissonLock.EXPIRATION_RENEWAL_MAP.get(RedissonLock.<span class="built_in">this</span>.getEntryName());</span><br><span class="line">                <span class="keyword">if</span> (ent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//从ExpirationEntry拿出线程ID</span></span><br><span class="line">                    <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">                    <span class="keyword">if</span> (threadId != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//调用renewExpirationAsync方法刷新最长等待时间</span></span><br><span class="line">                        RFuture&lt;Boolean&gt; future = RedissonLock.<span class="built_in">this</span>.renewExpirationAsync(threadId);</span><br><span class="line">                        future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                                RedissonLock.log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + RedissonLock.<span class="built_in">this</span>.getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                                    <span class="comment">//renewExpirationAsync方法执行成功之后，进行递归调用，调用自己本身函数</span></span><br><span class="line">                                    <span class="comment">//那么就可以实现这样的效果</span></span><br><span class="line">                                    <span class="comment">//首先第一次进行这个函数，设置了一个延迟任务，在10s后执行</span></span><br><span class="line">                                    <span class="comment">//10s后，执行延迟任务的内容，刷新有效期成功，那么就会再新建一个延迟任务，刷新最长等待有效期</span></span><br><span class="line">                                    <span class="comment">//这样这个最长等待时间就会一直续费</span></span><br><span class="line">                                    RedissonLock.<span class="built_in">this</span>.renewExpiration();</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, </span><br><span class="line">        <span class="built_in">this</span>.internalLockLeaseTime / <span class="number">3L</span>, <span class="comment">//这是锁自动释放时间，因为没传，所以是看门狗时间=30*1000,也就是10s</span></span><br><span class="line">        TimeUnit.MILLISECONDS); <span class="comment">//时间单位</span></span><br><span class="line">        </span><br><span class="line">        ee.setTimeout(task); <span class="comment">//给当前ExpirationEntry设置延迟任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新等待时间</span></span><br><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">renewExpirationAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                          <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">                          Collections.singletonList(getName()),</span><br><span class="line">                          internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后，在释放锁的时候，就会关闭所有的延迟任务</span></span><br><span class="line"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title function_">unlockAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    RPromise&lt;Void&gt; result = <span class="keyword">new</span> <span class="title class_">RedissonPromise</span>();</span><br><span class="line">    RFuture&lt;Boolean&gt; future = <span class="built_in">this</span>.unlockInnerAsync(threadId);</span><br><span class="line">    future.onComplete((opStatus, e) -&gt; &#123;</span><br><span class="line">        <span class="comment">//取消锁更新任务</span></span><br><span class="line">        <span class="built_in">this</span>.cancelExpirationRenewal(threadId);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            result.tryFailure(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opStatus == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">IllegalMonitorStateException</span> <span class="variable">cause</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(<span class="string">&quot;attempt to unlock lock, not locked by current thread by node id: &quot;</span> + <span class="built_in">this</span>.id + <span class="string">&quot; thread-id: &quot;</span> + threadId);</span><br><span class="line">            result.tryFailure(cause);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.trySuccess((Object)<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">cancelExpirationRenewal</span><span class="params">(Long threadId)</span> &#123;</span><br><span class="line">    <span class="comment">//获得当前这把锁的任务</span></span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">task</span> <span class="operator">=</span> (ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(<span class="built_in">this</span>.getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//当前锁的延迟任务不为空，且线程id不为空</span></span><br><span class="line">        <span class="keyword">if</span> (threadId != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//先把线程ID去掉</span></span><br><span class="line">            task.removeThreadId(threadId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (threadId == <span class="literal">null</span> || task.hasNoThreads()) &#123;</span><br><span class="line">            <span class="comment">//然后取出延迟任务</span></span><br><span class="line">            <span class="type">Timeout</span> <span class="variable">timeout</span> <span class="operator">=</span> task.getTimeout();</span><br><span class="line">            <span class="keyword">if</span> (timeout != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//把延迟任务取消掉</span></span><br><span class="line">                timeout.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//再把ExpirationEntry移除出map</span></span><br><span class="line">            EXPIRATION_RENEWAL_MAP.remove(<span class="built_in">this</span>.getEntryName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Redis如何解决集群情况下分布式锁的可靠性"><a href="#Redis如何解决集群情况下分布式锁的可靠性" class="headerlink" title="Redis如何解决集群情况下分布式锁的可靠性"></a>Redis如何解决集群情况下分布式锁的可靠性</h1><p>采用Redlock（红锁）：让客户端和多个独立的Redis节点依次请求加锁，如果客户端能和半数以上的节点成功完成加锁操作，那么我们任务客户端成功获取到了分布式锁，否则获取失败</p>
<p>流程：</p>
<ol>
<li>客户端获取到当前时间T1</li>
<li>客户端依次向N个Redis节点执行加锁操作，加锁操作使用set命令，带上nx，px和客户端的唯一标识。如果某个节点发生了故障，为了保证Redlock能继续运行，需要给 加锁操作设置一个超时时间（远小于锁的过期时间）</li>
<li>一旦客户端从超过半数的Redis节点上获取到了锁，就再次获取当前时间T2</li>
<li>如果T2 - T1 &lt; 锁的过期时间，否则获取失败</li>
</ol>
<p>可以发现，需要满足两个条件：</p>
<ul>
<li>客户端从超过半数的Redis节点上获取到了锁</li>
<li>如果T2 - T1 &lt; 锁的过期时间</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.cdfy.top">cloud_fly</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.cdfy.top/posts/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html">https://www.cdfy.top/posts/Redis分布式锁.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.cdfy.top" target="_blank">cloud_fly blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis-%E6%95%B0%E6%8D%AE%E5%BA%93/">Redis - 数据库</a></div><div class="post-share"><div class="social-share" data-image="/img/website/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/Redis%E7%BC%93%E5%AD%98%E5%9C%BA%E6%99%AF.html" title="Redis缓存场景"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Redis缓存场景</div></div><div class="info-2"><div class="info-item-1">介绍旁路缓存和缓存异常的场景 旁路缓存(Cache-Aside)Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准  读策略： 从缓存中读取数据；如果缓存命中，则直接返回数据；如果缓存不命中，则从数据库中查询数据；查询到数据后，将数据写入到缓存中，并且返回给用户 写策略： 更新数据库Mysql中的记录,然后删除Redis中的缓存记录  场景： 举个例子，假设某个用户的年龄是 20，请求 A 要更新用户年龄为 21，所以它会删除缓存中的内容。这时，另一个请求 B 要读取这个用户的年龄，它查询缓存发现未命中后，会从数据库中读取到年龄为 20，并且写入到缓存中，然后请求 A 继续更改数据库，将用户的年龄更新为 21。最终，该用户年龄在缓存中是 20（旧值），在数据库中是 21（新值），缓存和数据库的数据不一致 为什么「先更新数据库再删除缓存」不会有数据不一致的问题？  假如某个用户数据在缓存中不存在，请求 A 读取数据时从数据库中查询到年龄为 20，在未写入缓存中时另一个请求 B 更新数据。它更新数据库中的年龄为...</div></div></div></a><a class="pagination-related" href="/posts/hello-world.html" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/website/loading.gif" data-original="/img/website/avatar.jpg" onerror="this.onerror=null;this.src='/img/website/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">cloud_fly</div><div class="author-info-description">Know the loom. Be the stone</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">70</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cloudfly03/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/cloudfly03/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/LFY20031120" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/q/LUQpYxEzGU" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:ie_feiyunluo@163.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎加入郑州大学ACM交流群 QQ群562888278，一起学习</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-text">什么是分布式锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E8%A6%81%E7%82%B9"><span class="toc-text">Redis实现分布式锁的要点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81owner"><span class="toc-text">为什么需要owner</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lua%E4%B8%80%E5%AE%9A%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="toc-text">lua一定能保证原子性？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">Redis分布式锁优缺点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE"><span class="toc-text">Redis分布式锁的超时时间怎么设置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redisson%E7%9A%84%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6"><span class="toc-text">Redisson的看门狗机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%9B%86%E7%BE%A4%E6%83%85%E5%86%B5%E4%B8%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-text">Redis如何解决集群情况下分布式锁的可靠性</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/Kafka%E6%9C%8D%E5%8A%A1%E7%AB%AF.html" title="Kafka服务端">Kafka服务端</a><time datetime="2025-01-31T09:48:05.000Z" title="发表于 2025-01-31 17:48:05">2025-01-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/Kafka%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.html" title="Kafka应用场景">Kafka应用场景</a><time datetime="2025-01-31T08:24:56.000Z" title="发表于 2025-01-31 16:24:56">2025-01-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5.html" title="限流策略">限流策略</a><time datetime="2025-01-25T06:47:33.000Z" title="发表于 2025-01-25 14:47:33">2025-01-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B9%82%E7%AD%89%E6%80%A7.html" title="幂等性">幂等性</a><time datetime="2025-01-25T05:20:36.000Z" title="发表于 2025-01-25 13:20:36">2025-01-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/Redis%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E5%93%88%E5%B8%8C%E6%A7%BD%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF16384%E4%B8%AA.html" title="Redis切片集群哈希槽为什么是16384个">Redis切片集群哈希槽为什么是16384个</a><time datetime="2025-01-25T04:25:42.000Z" title="发表于 2025-01-25 12:25:42">2025-01-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(img/website/footer.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By cloud_fly</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/canvas-nest.min.js"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>