<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>从Java线程池到阻塞队列 | cloud_fly blog</title><meta name="author" content="cloud_fly"><meta name="copyright" content="cloud_fly"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java语言虽然内置了多线程支持，启动一个新线程非常方便，但是，创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。 那么我们就可以把很多小任务让一组线程来执行，而不是一个任务对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池">
<meta property="og:type" content="article">
<meta property="og:title" content="从Java线程池到阻塞队列">
<meta property="og:url" content="https://www.cdfy.top/posts/%E4%BB%8EJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html">
<meta property="og:site_name" content="cloud_fly blog">
<meta property="og:description" content="Java语言虽然内置了多线程支持，启动一个新线程非常方便，但是，创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。 那么我们就可以把很多小任务让一组线程来执行，而不是一个任务对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.cdfy.top/img/website/avatar.jpg">
<meta property="article:published_time" content="2025-01-13T10:12:26.000Z">
<meta property="article:modified_time" content="2025-01-18T11:57:52.399Z">
<meta property="article:author" content="cloud_fly">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.cdfy.top/img/website/avatar.jpg"><link rel="shortcut icon" href="/img/website/favicon.jpg"><link rel="canonical" href="https://www.cdfy.top/posts/%E4%BB%8EJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html"><link rel="preconnect" href="//cdnjs.cloudflare.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":3,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdnjs.cloudflare.com/ajax/libs/egjs-infinitegrid/4.12.0/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '从Java线程池到阻塞队列',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/modify.css"><link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/website/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/website/loading.gif" data-original="/img/website/avatar.jpg" onerror="onerror=null;src='/img/website/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">cloud_fly blog</span></a><a class="nav-page-title" href="/"><span class="site-name">从Java线程池到阻塞队列</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">从Java线程池到阻塞队列</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-13T10:12:26.000Z" title="发表于 2025-01-13 18:12:26">2025-01-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-18T11:57:52.399Z" title="更新于 2025-01-18 19:57:52">2025-01-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>19分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="为什么要用线程池"><a class="markdownIt-Anchor" href="#为什么要用线程池"></a> 为什么要用线程池</h1>
<ul>
<li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
<li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行</li>
<li>方便管理线程：线程是稀缺资源，如果无条件地创建，不仅会消耗资源，还会降低线程的稳定性，使用线程池可以统一分配、调优和监考</li>
</ul>
<h1 id="线程池的核心参数"><a class="markdownIt-Anchor" href="#线程池的核心参数"></a> 线程池的核心参数</h1>
<p><img src="/img/website/loading.gif" data-original="/img/%E4%BB%8EJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/img1.png" alt="alt text" /></p>
<p>默认线程工厂（省略参数）创建线程池：</p>
<p>ThreadPoolExecutor继承自AbstractExecutorService，AbstractExecutorService实现了ExecutorService接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">Pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">8</span>, <span class="number">8</span>, <span class="number">2</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">4</span>),<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>corePoolSize：核心线程的数量</li>
<li>maximumPoolSize：线程池能创建的最大线程个数</li>
<li>keepAliveTime：空闲线程存活时间</li>
<li>unit：时间单位</li>
<li>workQueue：用于保存任务的阻塞队列</li>
<li>threadFactory：创建线程的工程类</li>
<li>hadler：饱和策略</li>
</ul>
<p>自定义线程工厂创建线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        pool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">5</span>),</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    ThreadFactory接口</span></span><br><span class="line"><span class="comment">                    ThreadFactory接口很简单，源码如下：</span></span><br><span class="line"><span class="comment">                    public interface ThreadFactory &#123;</span></span><br><span class="line"><span class="comment">                        Thread newThread(Runnable r);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">        </span><br><span class="line">                <span class="comment">//自定义线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程&quot;</span>+r.hashCode()+<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">                        <span class="comment">//线程命名</span></span><br><span class="line">                        <span class="type">Thread</span> <span class="variable">th</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;threadPool&quot;</span> + r.hashCode());</span><br><span class="line">                        <span class="keyword">return</span> th;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">ThreadTask</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//输出执行线程的名称</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ThreadName:&quot;</span> + hread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    线程118352462创建</span></span><br><span class="line"><span class="comment">    线程1550089733创建</span></span><br><span class="line"><span class="comment">    线程865113938创建</span></span><br><span class="line"><span class="comment">    ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">    ThreadName:threadPool118352462</span></span><br><span class="line"><span class="comment">    线程1442407170创建</span></span><br><span class="line"><span class="comment">    ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">    ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">    ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">    ThreadName:threadPool865113938</span></span><br><span class="line"><span class="comment">    ThreadName:threadPool865113938</span></span><br><span class="line"><span class="comment">    ThreadName:threadPool118352462</span></span><br><span class="line"><span class="comment">    ThreadName:threadPool1550089733</span></span><br><span class="line"><span class="comment">    ThreadName:threadPool1442407170</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>
<h1 id="常见线程池的区别以及特点"><a class="markdownIt-Anchor" href="#常见线程池的区别以及特点"></a> 常见线程池的区别以及特点</h1>
<p>创建方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tip: 到这里可以看到只有ThreadPoolExecutor类和ExecutorService类被使用，没有ThreadPool类</p>
<p>newCachedThreadPool：</p>
<ul>
<li>特点：newCachedThreadPool创建一个可缓存的线程池，如果当前线程池的长度超过了处理的需要，它可以灵活的回收空闲的线程，当需要添加的时候可以灵活的添加</li>
<li>缺点：<strong>maximumPoolSize被设置为Inter.MAX_VALUE</strong>，可能会造成OOM</li>
</ul>
<p>newFixedThreadPool：</p>
<ul>
<li>特点：创建一个定长的线程池，可控制线程最大并发数，超出的任务会在线程中等待</li>
<li>缺点：线程数量是固定的，但是<strong>阻塞队列是LinkedBlockingQueue</strong>，是无界队列，也可能会造成OOM</li>
</ul>
<p>newScheduledThreadPool：</p>
<ul>
<li>特点：创建一个固定长度的线程，而且支持定时的以及周期性的任务执行，类似Timer</li>
<li>缺点：底层封装了<strong>PriorityQueue，同样是无界队列</strong>，可能会造成OOM</li>
</ul>
<p>newSingleThreadExecutor：</p>
<ul>
<li>特点：单线程化的线程池，它会用唯一的工作线程来执行任务。如果这个线程因为异常结束，那么会有一个新的线程来替代它。它必须保证前一项任务完成才能执行后一项。<strong>阻塞队列是LinkedBlockingQueue</strong>，因此是无界队列，会有OOM的风险</li>
<li>缺点：因为是单线程，高并发下有压力</li>
</ul>
<h1 id="为什么我们不用executors默认创建线程池的方法而直接自己手动去调用threadpoolexecutor去创建线程池"><a class="markdownIt-Anchor" href="#为什么我们不用executors默认创建线程池的方法而直接自己手动去调用threadpoolexecutor去创建线程池"></a> 为什么我们不用Executors默认创建线程池的方法，而直接自己手动去调用ThreadPoolExecutor去创建线程池</h1>
<p>Executors 返回的线程池对象的弊端如下：</p>
<ul>
<li>newFixedThreadPool 和 newSingleThreadPool: LinkedBlockingQueue无界队列，允许的请求队列长度为 Integer.MAX_VALUE(无界队列)，可能会堆积大量的请求，从而导致 OOM</li>
<li>newCachedThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM</li>
<li>newScheduledThreadPool：同样使用无界队列（底层是PriorityQueue），也会堆积大量请求导致OOM</li>
</ul>
<h1 id="线程池的饱和策略有哪些"><a class="markdownIt-Anchor" href="#线程池的饱和策略有哪些"></a> 线程池的饱和策略有哪些</h1>
<ul>
<li>ThreadPoolExecutor.AbortPolicy：抛出RejectedExecutionException来拒绝任务的处理</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：调用提交任务的线程运行任务（比如A提交线程，A运行任务）。但是会降低新任务提交速度，影响程序的整体性能</li>
<li>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉</li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃掉最早的未处理的任务</li>
</ul>
<h1 id="线程池原理"><a class="markdownIt-Anchor" href="#线程池原理"></a> 线程池原理</h1>
<ol>
<li>判断线程池的核心线程数是不是已满，如果不是则创建一个新的工作线程来执行任务。</li>
<li>如果核心线程数已满，则将提交的任务放在保存任务的阻塞队列中。</li>
<li>如果工作任务队列满了，则创建一个新的线程来执行任务，直到数量到达maximumPoolSize</li>
<li>最后如果达到线程池最大线程数，则采取对应的饱和策略</li>
</ol>
<h1 id="线程池中execute和submit方法有什么区别"><a class="markdownIt-Anchor" href="#线程池中execute和submit方法有什么区别"></a> 线程池中execute()和submit()方法有什么区别</h1>
<p>相同点：</p>
<ul>
<li>都可以提交任务到线程池中</li>
</ul>
<p>不同点：</p>
<ul>
<li>接受参数：execute只能执行Runnable类型的任务，submit可以执行Runnable和Callable类型的任务</li>
<li>返回值：submit方法可以返回持有计算结果的Future对象，而execute没有</li>
<li>异常处理：submit可以方便处理异常</li>
</ul>
<h1 id="java中executor-executors和executeservice的区别"><a class="markdownIt-Anchor" href="#java中executor-executors和executeservice的区别"></a> Java中Executor、Executors和ExecuteService的区别</h1>
<p>Executor:</p>
<p>是一个<strong>接口</strong>，定义了execute方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ExecuteService：</p>
<p>是一个<strong>接口</strong>，继承了Executor。相比Executor，定义了更多的方法，以及可以作为创建的线程池的返回类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>Executors:</p>
<p>是一个工具类，继承了Executor，而且集成了很多创建线程池相关的方法，比如可以调用newFixedThreadPool(10)（返回类型是ExecuteService）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Executors.newFixedThreadPool(<span class="number">10</span>).submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Executor是最基本的接口，只定义了一个execute方法</li>
<li>ExecuteService是一个高级的接口，实现了Executor并进行了扩展,比如实现了submit方法，以及可以创建固定类型的线程池。这个接口的目的是方便我们使用底层不同的线程池，类似List接口，屏蔽底层差异</li>
<li>Executors是一个工具类，使用这个工具类可以方便的创建线程。让我们可以不用手动地指定线程池的各个参数，比如Executors.newFixedThreadPool(10)</li>
</ul>
<h1 id="线程池有哪些状态"><a class="markdownIt-Anchor" href="#线程池有哪些状态"></a> 线程池有哪些状态</h1>
<p><img src="/img/website/loading.gif" data-original="/img/%E4%BB%8EJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/img2.png" alt="alt text" /></p>
<ul>
<li>Running:正常状态，可以接受其他线程</li>
<li>Shutdown：不接受新的任务提交，但是会继续处理等待队列中的任务</li>
<li>Stop：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li>
<li>Tidying：所有的任务都销毁，workerCount（线程数量）为0，线程池在向Tidying状态转换时，会执行钩子方法terminated()</li>
<li>Terminated：terminated()方法介绍后，就会变成这个</li>
</ul>
<h1 id="如何合理分配线程池大小线程池应对io密集型和cpu密集型的策略"><a class="markdownIt-Anchor" href="#如何合理分配线程池大小线程池应对io密集型和cpu密集型的策略"></a> 如何合理分配线程池大小——线程池应对IO密集型和CPU密集型的策略</h1>
<ul>
<li>CPU密集型：也叫计算密集型，其处理器占用率高，也许在某段时间内保持100%占用率。线程配置数大概和CPU核数相当，这样可以使得每个线程在执行任务</li>
<li>IO密集型：大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，但CPU的使用率不高。大部分线程在阻塞，故需要多配置线程数，2 * cpu核数</li>
</ul>
<h1 id="线程池如何实现动态修改"><a class="markdownIt-Anchor" href="#线程池如何实现动态修改"></a> 线程池如何实现动态修改</h1>
<p>线程池提供了部分setter方法可以设置线程池的参数：</p>
<ul>
<li>修改线程数，最大线程数，空闲线程停留时间，拒绝策略等</li>
<li>可以将线程池的配置参数放入配置中心，然后直接在配置中心修改</li>
</ul>
<p>什么时候需要修改？</p>
<ol>
<li>需要监考报警策略，获取线程池状态指标，当指标判定为异常后再报警</li>
<li>分析指标原因，评估策略，然后通过上述线程池提供的接口进行修改</li>
</ol>
<h1 id="既然线程池中使用了阻塞队列那么什么是阻塞队列阻塞队列有哪些"><a class="markdownIt-Anchor" href="#既然线程池中使用了阻塞队列那么什么是阻塞队列阻塞队列有哪些"></a> 既然线程池中使用了阻塞队列，那么什么是阻塞队列，阻塞队列有哪些</h1>
<p>阻塞队列支持两个阻塞的插入和删除操作</p>
<ul>
<li>支持阻塞的插入put方法：当队列满的时候，队列会阻塞插入元素的线程，直到队列不满</li>
<li>支持阻塞的移除take方法：当队列为空的时候，队列会阻塞移除元素的线程，直到队列不为空</li>
</ul>
<p>阻塞队列：</p>
<ul>
<li>ArrayBlockingQueue：底层使用数组结构，创建时必须指定大小，是有界的</li>
<li>LinkedBlockingQueue：底层使用链表结构，创建时默认大小是Inter.MAX_VALUE，因此是无界的。也可以指定大小成为有界</li>
<li>PriorityBlockingQueue：一个支持优先级排列的队列，可重写自定义类的compareTo方法来指定排序规则</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列，使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，表示指定多久才能从队列中获得元素</li>
<li>SynchronousQueue：一个不存储元素的队列，每一次put必须等待一个take操作，否则不能添加元素。适用于传递性场景</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界队列，设计了一种生产者和消费者之间传递的机制，称为”transfer“。当生产者调用transfer（e）方法时，它会阻塞直到一个消费者接收该元素</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双端队列</li>
</ul>
<h1 id="arrayblockingqueue和linkedblockingqueue的区别"><a class="markdownIt-Anchor" href="#arrayblockingqueue和linkedblockingqueue的区别"></a> ArrayBlockingQueue和LinkedBlockingQueue的区别</h1>
<ul>
<li>底层实现：ArrayBlockingQueue基于数组，LinkedBlockingQueue基于链表</li>
<li>是否有界：ArrayBlockingQueue有界，LinkedBlockingQueue创建时可以指定大小，默认是Integer.MAX_VALUE，无界</li>
<li>锁是否分离：ArrayBlockingQueue中的锁不分离，生产者和消费者使用同一把锁。LinkedBlockingQueue的锁分离，生产者使用的是putLock，消费者使用的是takeLock，这样可以防止生产者和消费者之间竞争锁</li>
<li>内存占用：ArrayBlockingQueue需要提前分配内存，LinkedBlockingQueue是动态分配内存，会不断占用空间</li>
</ul>
<h1 id="arrayblockingqueue底层源码"><a class="markdownIt-Anchor" href="#arrayblockingqueue底层源码"></a> ArrayBlockingQueue底层源码</h1>
<h2 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] items;  <span class="comment">//队列的底层为数组，是个循环数组</span></span><br><span class="line"><span class="type">int</span> takeIndex;  <span class="comment">//从队列中取元素的索引，用于take、poll、remove</span></span><br><span class="line"><span class="type">int</span> putIndex;  <span class="comment">//向队列中存放元素的索引，用于put、offer、add</span></span><br><span class="line"><span class="type">int</span> count;  <span class="comment">//队列中的元素数</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock; <span class="comment">//队列中的锁机制，可重入锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;   <span class="comment">//notEmpty条件对象，由lock创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;  <span class="comment">//notFull条件对象，由lock创建</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">Itrs</span> <span class="variable">itrs</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">//迭代器对象</span></span><br></pre></td></tr></table></figure>
<h2 id="添加方法"><a class="markdownIt-Anchor" href="#添加方法"></a> 添加方法</h2>
<h3 id="adde-e非阻塞方法"><a class="markdownIt-Anchor" href="#adde-e非阻塞方法"></a> add(E e)（非阻塞方法）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*调用了offer(e)方法，成功，返回true，失败，抛出IllegalStateException异常*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (offer(e)) </span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在当前put位置插入元素、前进和信号</span></span><br><span class="line"><span class="comment">   * Call only when holding lock. 只有在持有锁资源时才调用该方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">      <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">      <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">      <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items; <span class="comment">//将队列数组初始化</span></span><br><span class="line">      items[putIndex] = x;  <span class="comment">//将元素添加到数组里</span></span><br><span class="line">      <span class="keyword">if</span> (++putIndex == items.length)  <span class="comment">//如果将要插入的元素索引等于数组的长度，将存放元素的索引重新置为0</span></span><br><span class="line">          putIndex = <span class="number">0</span>;</span><br><span class="line">      count++;</span><br><span class="line">      notEmpty.signal();   <span class="comment">//使用条件对象notEmpty通知，唤醒当前等待的线程</span></span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Throws NullPointerException if argument is null.</span></span><br><span class="line"><span class="comment">    *如果参数为null，则抛出NullPointerException的异常</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> v the element</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkNotNull</span><span class="params">(Object v)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (v == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="pute-e阻塞方法"><a class="markdownIt-Anchor" href="#pute-e阻塞方法"></a> put(E e)（阻塞方法）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将指定的元素插入到此队列的末尾，然后等待</span></span><br><span class="line"><span class="comment">    * for space to become available if the queue is full.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       checkNotNull(e); <span class="comment">//判断元素是否为null</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;  <span class="comment">//初始化重入锁</span></span><br><span class="line">       lock.lockInterruptibly(); <span class="comment">//加锁，以保证在调用put方法时只有一个线程</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (count == items.length) <span class="comment">//当队列满了，阻塞当前线程，并加入到条件对象notFull的等待队列里面</span></span><br><span class="line">               notFull.await(); <span class="comment">//线程阻塞并被挂起，同时释放锁资源</span></span><br><span class="line">           enqueue(e); <span class="comment">//调用enqueue方法</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();  <span class="comment">//释放锁，让其他线程可以调用put方法</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="offere-e添加方法的具体实现"><a class="markdownIt-Anchor" href="#offere-e添加方法的具体实现"></a> offer(E e)（添加方法的具体实现）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       checkNotNull(e); <span class="comment">//检查队列中的元素是否为空。在这里不允许为空</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock; <span class="comment">//引入重入锁</span></span><br><span class="line">       lock.lock(); <span class="comment">//加锁，保证调用offer时只有一个线程</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (count == items.length)  <span class="comment">//如果当前元素的个数等于队列数组的长度，说明队列是满的，添加失败</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">else</span> &#123;<span class="comment">//否则队列不满，调用enqueue(e)方法添加元素，返回true</span></span><br><span class="line">               enqueue(e);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;<span class="comment">//最后，释放锁，让其他线程可以调用offer方法</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除方法"><a class="markdownIt-Anchor" href="#删除方法"></a> 删除方法</h2>
<h3 id="poll非阻塞方法"><a class="markdownIt-Anchor" href="#poll非阻塞方法"></a> poll()（非阻塞方法）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock; <span class="comment">//引入重用锁</span></span><br><span class="line">       lock.lock();  <span class="comment">//加锁，以保证当前只有一个线程</span></span><br><span class="line">       <span class="keyword">try</span> &#123;<span class="comment">//如果队列为空，则返回null；否则，调用dequeue方法</span></span><br><span class="line">           <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="literal">null</span> : dequeue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock(); <span class="comment">//释放锁资源，让其他线程可以调用poll方法</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="take阻塞方法"><a class="markdownIt-Anchor" href="#take阻塞方法"></a> take()（阻塞方法）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();<span class="comment">//加锁，以保证在调用take()方法时只有一个线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">//当队列中元素个数为1，即队列为空时 </span></span><br><span class="line">            notEmpty.await(); <span class="comment">//阻塞当前线程，并加入到条件对象notEmpty的等待队列里</span></span><br><span class="line">        <span class="keyword">return</span> dequeue(); <span class="comment">//调用dequeue()方法</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">//释放锁，让其他线程可以调用take()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="removeobject-obj删除指定元素"><a class="markdownIt-Anchor" href="#removeobject-obj删除指定元素"></a> remove(Object obj)（删除指定元素）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从队列中删除指定的元素。如果该元素存在，则将该元素从队列中删除，返回true；如果不存在，则返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果指定删除的元素为null，则返回false</span></span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items; <span class="comment">//阻塞队列数组</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock; <span class="comment">//重入锁</span></span><br><span class="line">        lock.lock(); <span class="comment">//加锁，以此保证在调用该remove方法时只有一个线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;<span class="comment">//如果队列不为空</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">putIndex</span> <span class="operator">=</span> <span class="built_in">this</span>.putIndex; <span class="comment">//往队列中即将要存储的元素的下标</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> takeIndex; <span class="comment">//从队列即将要取出元素的下标</span></span><br><span class="line"><span class="comment">//循环遍历阻塞队列中的元素，如果在队列中找到了要删除的元素，则将该元素删除，返回true;否则，返回false。</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (o.equals(items[i])) &#123; <span class="comment">//</span></span><br><span class="line">                        removeAt(i);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                        i = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (i != putIndex);<span class="comment">//结束条件为当前元素索引==最后将要存入队列中的元素的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();<span class="comment">//释放锁资源，让其他线程可以调用remove(e)方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="dequepoll-take的具体实现"><a class="markdownIt-Anchor" href="#dequepoll-take的具体实现"></a> deque()（poll、take的具体实现）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Extracts element at current take position, advances, and signals.提取元素当前的位置、进展和信号</span></span><br><span class="line"><span class="comment">   * Call only when holding lock.在持有锁时才调用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">      <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">      <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;<span class="comment">//阻塞队列数组</span></span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex];<span class="comment">//用变量x记录当前要取出的元素</span></span><br><span class="line">      items[takeIndex] = <span class="literal">null</span>;<span class="comment">//将该元素置为null</span></span><br><span class="line">      <span class="keyword">if</span> (++takeIndex == items.length)<span class="comment">//判断是否是最后一个元素</span></span><br><span class="line">          takeIndex = <span class="number">0</span>; <span class="comment">//如果是，将取元素索引置为0，从头开始取</span></span><br><span class="line">      count--;<span class="comment">//元素个数-1</span></span><br><span class="line">      <span class="keyword">if</span> (itrs != <span class="literal">null</span>) <span class="comment">//迭代遍历队列，</span></span><br><span class="line">          itrs.elementDequeued();</span><br><span class="line">      notFull.signal();<span class="comment">// 使用条件对象notFull通知，比如使用put方法放数据的时候队列已满，被阻塞。这个时候消费了一条数据，队列没满了，就需要调用signal进行通知  </span></span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h1 id="linkedblockingqueue底层源码"><a class="markdownIt-Anchor" href="#linkedblockingqueue底层源码"></a> LinkedBlockingQueue底层源码</h1>
<h2 id="属性-2"><a class="markdownIt-Anchor" href="#属性-2"></a> 属性</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;  <span class="comment">//元素</span></span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//next指针</span></span><br><span class="line">        </span><br><span class="line">        Node(E x) &#123;  <span class="comment">//有参构造函数</span></span><br><span class="line">          item = x;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;  <span class="comment">//容量，默认为 Integer.MAX_VALUE</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();  <span class="comment">//队列中元素的数量</span></span><br><span class="line">        <span class="keyword">transient</span> Node&lt;E&gt; head;  <span class="comment">//头节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;  <span class="comment">//尾节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">//拿锁</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();  <span class="comment">//拿锁的条件，队列不为空</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();  <span class="comment">//放锁</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();  <span class="comment">//放锁的条件</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加方法-2"><a class="markdownIt-Anchor" href="#添加方法-2"></a> 添加方法</h2>
<h3 id="adde-e非阻塞方法-2"><a class="markdownIt-Anchor" href="#adde-e非阻塞方法-2"></a> add(E e)（非阻塞方法）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pute-e阻塞方法-2"><a class="markdownIt-Anchor" href="#pute-e阻塞方法-2"></a> put(E e)（阻塞方法）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();<span class="comment">//判断添加的元素是否为null，如果为Null，抛出NullPointerException异常</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>; </span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e); <span class="comment">//构造新的结点</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock; <span class="comment">//放锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count; <span class="comment">//元素的个数</span></span><br><span class="line">        putLock.lockInterruptibly(); <span class="comment">//放锁加锁，保证在调用put方法的时候只有1个线程 </span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123;<span class="comment">//如果队列为满</span></span><br><span class="line">                notFull.await();<span class="comment">//阻塞并挂起当前线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            enqueue(node);<span class="comment">//将元素添加到链表的尾部</span></span><br><span class="line">            c = count.getAndIncrement(); <span class="comment">//元素个数+1</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity) <span class="comment">//如果队列的容量还没有满</span></span><br><span class="line">                notFull.signal(); <span class="comment">//在notFull对象上唤醒正在等待的1个线程，表示队列中还有元素可以消费</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock(); <span class="comment">//释放放锁，让其他线程可以调用该put方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)<span class="comment">//由于存在放锁和拿锁，这里可能拿锁一直在消费数据，count会变化。这里的if条件表示如果队列中还有1条数据 </span></span><br><span class="line">            signalNotEmpty();<span class="comment">//在拿锁的条件对象notEmpty上唤醒正在等待的1个线程，表示队列里还有1条数据，可以进行消费 </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//enqueue(Node&lt;E&gt; node)（上面方法用到）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> &#123;</span><br><span class="line">        <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">        <span class="comment">// assert last.next == null;</span></span><br><span class="line">        last = last.next = node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="offere-e添加方法的具体实现分为offerfirst和offerlast"><a class="markdownIt-Anchor" href="#offere-e添加方法的具体实现分为offerfirst和offerlast"></a> offer(E e)（添加方法的具体实现，分为offerFirst和OfferLast）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> linkFirst(node);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> linkLast(node);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除方法-2"><a class="markdownIt-Anchor" href="#删除方法-2"></a> 删除方法</h2>
<h3 id="poll非阻塞方法-2"><a class="markdownIt-Anchor" href="#poll非阻塞方法-2"></a> poll()（非阻塞方法）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count; <span class="comment">//队列中元素的个数</span></span><br><span class="line">      <span class="keyword">if</span> (count.get() == <span class="number">0</span>) <span class="comment">//判断该队列是否为空</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//如果为空，返回null</span></span><br><span class="line">      <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//定义要返回的元素的变量名，初始化为Null</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;<span class="comment">//拿锁</span></span><br><span class="line">      takeLock.lock();<span class="comment">//拿锁加锁，以保证在调用poll()线程的时候只有1个线程</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;<span class="comment">//判断队列是否为空。如果不为空</span></span><br><span class="line">              x = dequeue();<span class="comment">//删除头节点</span></span><br><span class="line">              c = count.getAndDecrement();<span class="comment">//元素个数-1</span></span><br><span class="line">              <span class="keyword">if</span> (c &gt; <span class="number">1</span>)<span class="comment">//如果队列中还有元素</span></span><br><span class="line">                  notEmpty.signal();<span class="comment">//在拿锁的条件对象notEmpty上唤醒正在等待的线程，表示队列里还有数据，可以再次消费 </span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          takeLock.unlock();<span class="comment">//释放拿锁资源，让其他线程可以调用该poll()方法</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (c == capacity)<span class="comment">//由于存在放锁和拿锁，这里可能放锁一直在添加数据，count会变化。这里的if条件表示如果队列中还可以再插入数据 </span></span><br><span class="line">          signalNotFull();<span class="comment">//在放锁的条件对象notFull上唤醒正在等待的1个线程，表示队列里还能再次添加数据 </span></span><br><span class="line">      <span class="keyword">return</span> x;<span class="comment">//返回删除的元素</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="take阻塞方法-2"><a class="markdownIt-Anchor" href="#take阻塞方法-2"></a> take()（阻塞方法）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count; <span class="comment">//队列中元素的个数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;  <span class="comment">//拿锁</span></span><br><span class="line">    takeLock.lockInterruptibly();  <span class="comment">//拿锁加锁，以保证在调用take()方法的时候只有一个线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123; <span class="comment">//如果队列为空</span></span><br><span class="line">            notEmpty.await(); <span class="comment">//则将当前线程阻塞并挂起</span></span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue(); <span class="comment">//否则，删除头节点</span></span><br><span class="line">        c = count.getAndDecrement();  <span class="comment">//元素个数-1</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)  <span class="comment">//判断队列中是否还有元素</span></span><br><span class="line">            notEmpty.signal(); <span class="comment">//如果有，在拿锁的条件对象notEmpty上唤醒正在等待的线程，表示队列里还有数据，可以再次消费 </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock(); <span class="comment">//释放拿锁，以保证其他线程可以调用take()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity) <span class="comment">//表示如果队列中还可以再插入数据 </span></span><br><span class="line">        signalNotFull(); <span class="comment">//在放锁的条件对象notFull上唤醒正在等待的1个线程，表示队列里还能再次添加数据 </span></span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">//返回删除的那个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="removeobject-o删除指定元素"><a class="markdownIt-Anchor" href="#removeobject-o删除指定元素"></a> remove(Object o)（删除指定元素）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果要删除的元素为null，返回false</span></span><br><span class="line">    fullyLock(); <span class="comment">//remove操作要移动的位置不固定，2个锁都需要加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;</span><br><span class="line">             p != <span class="literal">null</span>;</span><br><span class="line">             trail = p, p = p.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123;<span class="comment">//判断在队列中是否能找到要删除的对象</span></span><br><span class="line">                unlink(p, trail);<span class="comment">//修改节点的链接信息，同时调用notFull的signal方法 ，唤醒等待的线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果没有找到，返回false</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fullyUnlock();<span class="comment">//2个锁解锁 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove()方法中的加锁方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fullyLock</span><span class="params">()</span> &#123;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    takeLock.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove()方法中的解锁方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fullyUnlock</span><span class="params">()</span> &#123;</span><br><span class="line">    takeLock.unlock();</span><br><span class="line">    putLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dequepoll-take的具体实现-2"><a class="markdownIt-Anchor" href="#dequepoll-take的具体实现-2"></a> deque()（poll、take的具体实现）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert head.item == null;</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    head = first;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;</span><br><span class="line">    first.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.cdfy.top">cloud_fly</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.cdfy.top/posts/%E4%BB%8EJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html">https://www.cdfy.top/posts/从Java线程池到阻塞队列.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.cdfy.top" target="_blank">cloud_fly blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post-share"><div class="social-share" data-image="/img/website/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.html" title="Redis线程模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Redis线程模型</div></div><div class="info-2"><div class="info-item-1"> Redis线程是单线程还是多线程 Redis核心处理一直都是单线程，但是其他处理模块也会有一些多线程、多进程的功能  网络I/O解包从6.0开始是多线程 某些异步流程从4.0开始用的是多进程，比如UNLIKE、FLUSHALL ASYNC等非阻塞的删除操作   Redis为什么用单线程做核心处理  首先如果引用多线程，主要是希望利用多核的性能，但是Redis是内存k-v存储，一般不会很慢。真正影响Redis性能的是网络I/O 其次多线程的上下文切换、同步机制开销等成本，会影响Redis的性能   Redis单线程性能如何 性能很好，普通机器1s10多万的读性能，几万的写性能 redis-benchmark测试命令： 1redis-benchmark -h 127.0.0.1 -p 6379 -t set,get -n 10000 -q ...</div></div></div></a><a class="pagination-related" href="/posts/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html" title="Redis数据结构和数据类型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Redis数据结构和数据类型</div></div><div class="info-2"><div class="info-item-1"> 基本结构 在Redis中有一个核心的对象叫做redisObject ，是用来表示所有的key和value的，用redisObject结构体来表示String、Hash、List、Set、ZSet五种数据类型  key和value指向的是redisObject对象   type：标识该对象用的是什么类型（String、List) encoding：编码方式   Redis数据结构 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/HashMap%E7%9A%84%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98.html" title="HashMap的环形链表问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-24</div><div class="info-item-2">HashMap的环形链表问题</div></div><div class="info-2"><div class="info-item-1"> 在JDK1.7的时候，插入链表采用的是头插法，会先将一个需要迁移节点的next指向新位置，然后再将新位置设置成迁移节点。因此在多线程扩容的情况下，一个线程完成了两个节点的迁移，但是被调度到另一个还未完成的线程，就会出现循环链表的情况 在JDK1.8，采用了尾插法，只需要遍历一个个节点，挂在tail节点的后面即可，即使迁移过程有并发情况，指针也最多被复制两次  </div></div></div></a><a class="pagination-related" href="/posts/HashTable%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB.html" title="HashTable和HashMap的区别"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-11</div><div class="info-item-2">HashTable和HashMap的区别</div></div><div class="info-2"><div class="info-item-1"> 区别 1、HashMap是线程不安全的，HashTable是线程安全的   HashMap：Fail-fast 机制。表示快速失败，在集合遍历过程中，一旦发现容器中的数据被修改了，会立刻抛出ConcurrentModificationException异常，从而导致遍历失败，像这种情况：定义一个Map集合，使用Iterator迭代器进行数据遍历，在遍历过程中，对集合数据做变更时，就会发生Fail-fast。java.util包下的集合类都是快速失败机制的,...</div></div></div></a><a class="pagination-related" href="/posts/CopyOnWriteArrayList.html" title="CopyOnWriteArrayList"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-24</div><div class="info-item-2">CopyOnWriteArrayList</div></div><div class="info-2"><div class="info-item-1">CopyOnWriteArrayList是Java并发包中提供的一个并发容器，它是个线程安全且读操作无锁的ArrayList，写操作则通过创建底层数组的新副本来实现，是一种读写分离的并发策略，我们也可以称这种容器为&quot;写时复制器&quot;，Java并发包中类似的容器还有CopyOnWriteSet  原理  初始化时候，CopyOnWriteArrayList内部维护了一个可变数组，用于存储元素 修改的时候，首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器 读操作直接在原数组上进行，因为读操作不会改变数据，所以读操作不会加锁    优点  我们可以对CopyOnWriteArrayList并发的读，而不需要加锁，采用了读写分离的思想，读和写不同的容器   缺点  内存占用问题：因为CopyOnWriteArrayList的写时复制机制，在写的时候，内存中会出现两个对象的内存，旧的对象和新写入的对象，可能会造成频繁的young gc和full...</div></div></div></a><a class="pagination-related" href="/posts/JUC%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html" title="JUC同步工具CountDownLatch源码解析，与CyclicBarrier的对比"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-20</div><div class="info-item-2">JUC同步工具CountDownLatch源码解析，与CyclicBarrier的对比</div></div><div class="info-2"><div class="info-item-1"> 基本使用 CountDownLatch典型用法: 某一线程在开始运行前等待n个任务线程数执行完毕。将CountDownLatch的计数器初始化为new CountDownLatch(n)，每当一个任务线程数执行完毕，就将计数器减1 countdownLatch.countDown()，当计数器的值变为0时，在CountDownLatch上await()的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行   自定义任务类  1234567891011121314151617181920212223242526package org.example; import java.util.Random;import java.util.concurrent.CountDownLatch; public class Task implements Runnable&#123;    private final static Random random = new Random();    private Integer id;   ...</div></div></div></a><a class="pagination-related" href="/posts/Java%E4%BF%A1%E5%8F%B7%E9%87%8F%E2%80%94%E2%80%94Semaphore.html" title="Java信号量——Semaphore"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-20</div><div class="info-item-2">Java信号量——Semaphore</div></div><div class="info-2"><div class="info-item-1"> 基本概念 Semaphore是一个计数信号量，它可以用来控制对某一资源的访问数量。在Java中，Semaphore位于java.util.concurrent包中  Semaphore的用途 流量控制：Semaphore可以用来控制同时访问特定资源的线程数量，例如数据库连接、文件句柄等 分配资源：Semaphore可以用来分配有限数量的资源，例如线程池、线程队列等  Semaphore的使用技巧  创建Semaphore  1Semaphore semaphore = new Semaphore(5);    获取信号量  1semaphore.acquire();   请求一个信号量，这时候的信号量个数-1（是尝试获取，如果是&gt;0就减去, 否则阻塞等待信号量&gt;0）  释放信号量  1semaphore.release();   信号量+1  使用tryAcquire方法  1boolean acquired = semaphore.tryAcquire(); ...</div></div></div></a><a class="pagination-related" href="/posts/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.html" title="Java线程安全问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-18</div><div class="info-item-2">Java线程安全问题</div></div><div class="info-2"><div class="info-item-1"> Java线程安全性问题  原子性：一个或多个线程操作 CPU 执行的过程中被中断，互斥性称为操作的原子性 可见性：一个线程对共享变量的修改，其他线程不能立刻看到。要保证一个线程对主内存的修改可以及时的被其他线程观察到 有序性：程序执行的顺序没有按照代码的先后顺序执行   原子性安全 JDK 里面提供了很多 atomic 类，比如 AtomicInteger、AtomicLong、AtomicBoolean 等等，这些类本身可以通过 CAS 来保证操作的原子性。另外 Java 也提供了各种锁机制，来保证锁内的代码块在同一时刻只能有一个线程执行，比如使用 synchronized 加锁，保证一个线程在对资源进行读、写时，其他线程不可对此资源进行操作，从而保证了线程的安全性  可见性安全 同样可以通过 synchronized 关键字加锁来解决，与此同时，java 还提供了 volatile 关键字，要优于 synchronized 的性能，同样可以保证修改对其他线程的可见性。volatile 一般用于对变量的写操作不依赖于当前值的场景中，比如状态标记量等 ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/website/loading.gif" data-original="/img/website/avatar.jpg" onerror="this.onerror=null;this.src='/img/website/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">cloud_fly</div><div class="author-info-description">Know the loom. Be the stone</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/cloudfly03/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/cloudfly03/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/LFY20031120" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://qm.qq.com/q/LUQpYxEzGU" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:ie_feiyunluo@163.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎加入郑州大学ACM交流群 QQ群562888278，一起学习</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text"> 为什么要用线程池</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-text"> 线程池的核心参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="toc-text"> 常见线程池的区别以及特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E7%94%A8executors%E9%BB%98%E8%AE%A4%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%96%B9%E6%B3%95%E8%80%8C%E7%9B%B4%E6%8E%A5%E8%87%AA%E5%B7%B1%E6%89%8B%E5%8A%A8%E5%8E%BB%E8%B0%83%E7%94%A8threadpoolexecutor%E5%8E%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text"> 为什么我们不用Executors默认创建线程池的方法，而直接自己手动去调用ThreadPoolExecutor去创建线程池</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text"> 线程池的饱和策略有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86"><span class="toc-text"> 线程池原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%ADexecute%E5%92%8Csubmit%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text"> 线程池中execute()和submit()方法有什么区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E4%B8%ADexecutor-executors%E5%92%8Cexecuteservice%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text"> Java中Executor、Executors和ExecuteService的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81"><span class="toc-text"> 线程池有哪些状态</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E5%88%86%E9%85%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%94%E5%AF%B9io%E5%AF%86%E9%9B%86%E5%9E%8B%E5%92%8Ccpu%E5%AF%86%E9%9B%86%E5%9E%8B%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-text"> 如何合理分配线程池大小——线程池应对IO密集型和CPU密集型的策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9"><span class="toc-text"> 线程池如何实现动态修改</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A2%E7%84%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E9%82%A3%E4%B9%88%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-text"> 既然线程池中使用了阻塞队列，那么什么是阻塞队列，阻塞队列有哪些</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arrayblockingqueue%E5%92%8Clinkedblockingqueue%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text"> ArrayBlockingQueue和LinkedBlockingQueue的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#arrayblockingqueue%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81"><span class="toc-text"> ArrayBlockingQueue底层源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-text"> 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="toc-text"> 添加方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#adde-e%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%96%B9%E6%B3%95"><span class="toc-text"> add(E e)（非阻塞方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pute-e%E9%98%BB%E5%A1%9E%E6%96%B9%E6%B3%95"><span class="toc-text"> put(E e)（阻塞方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#offere-e%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text"> offer(E e)（添加方法的具体实现）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-text"> 删除方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#poll%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%96%B9%E6%B3%95"><span class="toc-text"> poll()（非阻塞方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#take%E9%98%BB%E5%A1%9E%E6%96%B9%E6%B3%95"><span class="toc-text"> take()（阻塞方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#removeobject-obj%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0"><span class="toc-text"> remove(Object obj)（删除指定元素）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dequepoll-take%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text"> deque()（poll、take的具体实现）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linkedblockingqueue%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81"><span class="toc-text"> LinkedBlockingQueue底层源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-2"><span class="toc-text"> 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95-2"><span class="toc-text"> 添加方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#adde-e%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%96%B9%E6%B3%95-2"><span class="toc-text"> add(E e)（非阻塞方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pute-e%E9%98%BB%E5%A1%9E%E6%96%B9%E6%B3%95-2"><span class="toc-text"> put(E e)（阻塞方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#offere-e%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%88%86%E4%B8%BAofferfirst%E5%92%8Cofferlast"><span class="toc-text"> offer(E e)（添加方法的具体实现，分为offerFirst和OfferLast）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%B9%E6%B3%95-2"><span class="toc-text"> 删除方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#poll%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%96%B9%E6%B3%95-2"><span class="toc-text"> poll()（非阻塞方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#take%E9%98%BB%E5%A1%9E%E6%96%B9%E6%B3%95-2"><span class="toc-text"> take()（阻塞方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#removeobject-o%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0"><span class="toc-text"> remove(Object o)（删除指定元素）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dequepoll-take%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-2"><span class="toc-text"> deque()（poll、take的具体实现）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/Kafka%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.html" title="Kafka应用场景">Kafka应用场景</a><time datetime="2025-01-31T08:24:56.000Z" title="发表于 2025-01-31 16:24:56">2025-01-31</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5.html" title="限流策略">限流策略</a><time datetime="2025-01-25T06:47:33.000Z" title="发表于 2025-01-25 14:47:33">2025-01-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/%E5%B9%82%E7%AD%89%E6%80%A7.html" title="幂等性">幂等性</a><time datetime="2025-01-25T05:20:36.000Z" title="发表于 2025-01-25 13:20:36">2025-01-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/Redis%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%E5%93%88%E5%B8%8C%E6%A7%BD%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF16384%E4%B8%AA.html" title="Redis切片集群哈希槽为什么是16384个">Redis切片集群哈希槽为什么是16384个</a><time datetime="2025-01-25T04:25:42.000Z" title="发表于 2025-01-25 12:25:42">2025-01-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/HashMap%E7%9A%84%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98.html" title="HashMap的环形链表问题">HashMap的环形链表问题</a><time datetime="2025-01-24T10:23:35.000Z" title="发表于 2025-01-24 18:23:35">2025-01-24</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(img/website/footer.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By cloud_fly</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/canvas-nest.min.js"></script><script id="click-heart" src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.4/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>