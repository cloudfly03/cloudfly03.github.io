<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis过期删除策略和内存淘汰策略</title>
      <link href="/posts/Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html"/>
      <url>/posts/Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html</url>
      
        <content type="html"><![CDATA[<h1 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h1><h2 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h2><ol><li>只对key设置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expire key n // key在n秒后过期</span><br><span class="line">pexpire key n // key在n毫秒后过期</span><br><span class="line">expireat key n // key在时间戳n秒的时刻过期</span><br><span class="line">pexpireat key n // key在时间戳n毫秒的时刻过期</span><br></pre></td></tr></table></figure><ol start="2"><li>创建key的时候设置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set key value ex n // 创建key，并且key在n秒后过期</span><br><span class="line">set key value px n // 创建key，并且key在n毫秒后过期</span><br><span class="line">set key n value // 创建key，并且key在时间戳n秒的时刻过期</span><br></pre></td></tr></table></figure><ol start="3"><li>查看某个key的存活时间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br></pre></td></tr></table></figure><h2 id="判定key是否过期"><a href="#判定key是否过期" class="headerlink" title="判定key是否过期"></a>判定key是否过期</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span> </span><br><span class="line">    dict *dict; <span class="comment">/* 数据库键空间，存放着所有的键值对 */</span> </span><br><span class="line">    dict *expires; <span class="comment">/* 键的过期时间 */</span> .... </span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>过期字典数据结构：</p><ul><li>key 是一个指针，指向某个键对象</li><li>value 是一个 long long 类型的整数，这个整数保存了 key 的过期时间</li></ul><p><img src="/img/Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/img1.png" alt="alt text"></p><p>判断策略：</p><ul><li>字典实际上是哈希表，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找</li><li>当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：<ol><li>如果不在，则正常读取键值；</li><li>如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li></ol></li></ul><h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><ul><li>定时删除：给key创建过期时间的同时创建一个定时器，在过期时间来临的时候进行主动删除。好处是删除及时使得内存空间释放，坏处是定时器占用CPU时间</li><li>惰性删除：不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该key。好处是占用CPU时间少，坏处是容易造成内存泄漏</li><li>定期删除：每隔一段时间随机从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。平衡了CPU和内存占用</li><li>Redis采用的是最后两种，惰性删除和定期删除组合使用</li></ul><h2 id="Redis定期删除的流程"><a href="#Redis定期删除的流程" class="headerlink" title="Redis定期删除的流程"></a>Redis定期删除的流程</h2><ol><li>从过期字典中随机抽取 20 个 key</li><li>检查这 20 个 key 是否过期，并删除已过期的 key</li><li>如果本轮检查的已过期 key 的数量，超过 5 个（20&#x2F;4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查</li></ol><h1 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h1><h2 id="有哪些内存淘汰策略"><a href="#有哪些内存淘汰策略" class="headerlink" title="有哪些内存淘汰策略"></a>有哪些内存淘汰策略</h2><p><img src="/img/Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/img2.png" alt="alt text"></p><ul><li>noevction：不淘汰任何数据，如果运行内存超过了最大设置内存，会不允许写入</li><li>volatile：针对过期键<ul><li>lru：淘汰最久未访问到的数据</li><li>lfu：淘汰使用频率最少的数据</li><li>random：随机淘汰</li><li>ttl：淘汰最久的过期键</li></ul></li><li>allkeys：针对所有键 <ul><li>lru：淘汰最久未访问到的数据</li><li>lfu：淘汰使用频率最少的数据</li><li>random：随机淘汰</li></ul></li></ul><h2 id="Redis的LRU算法"><a href="#Redis的LRU算法" class="headerlink" title="Redis的LRU算法"></a>Redis的LRU算法</h2><p>LRU，最近最久未使用算法：记录了每个key的最近访问时间，每次淘汰最久这个时间的key，但是redis的lru不是标准的，做了优化</p><p>优化：</p><ul><li>标准lru需要维护双链表，开销很大，所以redis采用的是近似LRU算法</li><li>具体的是每次随机采样n个key，默认值是5，然后按照时间戳淘汰最久的那个。如果淘汰后内存还是不足继续随机采样淘汰。在3.0之后，redis LRU还维护了淘汰池，池中的数据按照访问时间进行排序。第一次随机选取的key都会放入池中，每次淘汰池中最久访问的key。</li><li>随后每次选取的key只有空闲时间（指的是没有访问到的时候）大于池中空间时间最小的key，才能放入其中。当池子装满了，需要新的key放入的时候，就将池子中最大的key淘汰</li></ul><h2 id="Redis的LFU算法"><a href="#Redis的LFU算法" class="headerlink" title="Redis的LFU算法"></a>Redis的LFU算法</h2><p>LRU 算法有一个问题，无法解决缓存污染问题，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染</p><p>所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些</p><p>LFU 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息。Redis 对象的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span> </span><br><span class="line">    ... <span class="comment">// 24 bits，</span></span><br><span class="line">    用于记录对象的访问信息 <span class="type">unsigned</span> lru:<span class="number">24</span>; </span><br><span class="line">    ... </span><br><span class="line">&#125; </span><br><span class="line">robj;</span><br></pre></td></tr></table></figure><p>Redis对象头中的lru字段，在LRU算法下和LFU算法下使用方式并不相同:</p><ul><li>在 LRU 算法中，Redis对象头的24bits的lru字段是用来记录key的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的lru字段记录的值，来比较最后一次key的访问时间长，从而淘汰最久未被使用的key</li><li>在 LFU 算法中，Redis对象头的24bits的lru字段被分成两段来存储，高16bit存储ldt(Last Decrement Time)，低8bit存储logc(Logistic Counter)</li></ul><p><img src="/img/Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/img3.png" alt="alt text"></p><p>lfu字段：</p><ul><li>ldt:用来记录key的访问时间戳；</li><li>logc:用来记录key的访问频次，它的值越小表示使用频率越低，越容易淘汰，每个新加入的key的logc初始值为5</li><li>logc 并不是单纯的访问次数，而是访问频次（访问频率），因为 logc 会随时间推移而衰减的。<br>在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大 <strong>（ldt的作用）</strong>，那么衰减的值就越大，这样实现的 LFU 算法是根据访问频率来淘汰数据的，而不只是访问次数。访问频率需要考虑 key 的访问是多长时间段内发生的。key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大。<br>对 logc 做完衰减操作后，就开始对 logc 进行增加操作，增加操作并不是单纯的 + 1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化</title>
      <link href="/posts/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html"/>
      <url>/posts/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis的持久化方式有哪些"><a href="#Redis的持久化方式有哪些" class="headerlink" title="Redis的持久化方式有哪些"></a>Redis的持久化方式有哪些</h1><p>Redis持久化有两种方式：RDB（Redis DataBase）和AOF（Append Only File）</p><p><img src="/img/Redis%E6%8C%81%E4%B9%85%E5%8C%96/img1.png" alt="alt text"></p><ul><li>RDB：RDB文件是一个经过压缩的二进制文件</li><li>AOF：AOF则是以追加的方式记录Redis执行的每一条写命令</li></ul><h1 id="Redis重启时加载持久化文件"><a href="#Redis重启时加载持久化文件" class="headerlink" title="Redis重启时加载持久化文件"></a>Redis重启时加载持久化文件</h1><p><img src="/img/Redis%E6%8C%81%E4%B9%85%E5%8C%96/img2.png" alt="alt text"></p><h1 id="RDB和AOF的区别"><a href="#RDB和AOF的区别" class="headerlink" title="RDB和AOF的区别"></a>RDB和AOF的区别</h1><ul><li>文件类型：RDB生成的是二进制文件（快照），AOF生成的是文本文件（追加日志）</li><li>安全性：缓存宕机时，RDB容易丢失较多的数据，AOF根据策略决定（默认的everysec可以保证最多有一秒的损失）</li><li>文件恢复速度：由于RDB是二进制文件，恢复比AOF快</li><li>操作的开销：每一次RDB保存都是一次全量保存，操作比较重，通常至少5分钟保存一次。而AOF的刷盘是追加操作，操作比较轻，通常设置为每一秒进行一次刷盘</li></ul><h1 id="RDB和AOF选哪种比较好"><a href="#RDB和AOF选哪种比较好" class="headerlink" title="RDB和AOF选哪种比较好"></a>RDB和AOF选哪种比较好</h1><ul><li>从业务需要来看，如果我们可以接受分钟级别的丢失，可以选择RDB。如果我们尽量让数据安全，可以考虑AOF混合持久化，</li><li>从持久化理论来看，始终开启快照是一个推荐，这也是官方默认开启RDB而不开启AOF</li></ul><h1 id="什么是AOF混合持久化"><a href="#什么是AOF混合持久化" class="headerlink" title="什么是AOF混合持久化"></a>什么是AOF混合持久化</h1><ul><li>使用RDB持久化函数，将内存数据写入到新的AOF文件中（数据格式也是RDB）</li><li>而重写期间新的命令追加到新的AOF中（数据格式是AOF）</li><li>新的AOF文件包含RDB格式和AOF格式的数据</li></ul><h1 id="RDB的触发时机"><a href="#RDB的触发时机" class="headerlink" title="RDB的触发时机"></a>RDB的触发时机</h1><ul><li>调用save和bgsave命令</li><li>根据我们的配置周期决定</li><li>redis关闭前</li><li>主从复制第二阶段：主服务器全量复制RDB文件发送给从服务器</li><li>客户点执行清空命令FLUSHALL</li></ul><h1 id="save和bgsave的区别"><a href="#save和bgsave的区别" class="headerlink" title="save和bgsave的区别"></a>save和bgsave的区别</h1><ul><li>save：会阻塞主进程，客户端无法连接redis，等SAVE完成后，主进程才开始工作，客户端可以连接</li><li>bgsave：是fork一个save的子进程，在执行save过程中，不影响主进程，客户端可以正常链接redis，等子进程fork执行save完成后，通知主进程，子进程关闭。bgsave采取的是<strong>写时复制</strong>。<br>子进程写数据到临时的RDB文件，写完之后替换旧的RDB文件</li></ul><h1 id="AOF的触发时机"><a href="#AOF的触发时机" class="headerlink" title="AOF的触发时机"></a>AOF的触发时机</h1><ul><li>Redis关闭的时候</li><li>每一次事件循环的时候</li><li>通过配置指令关闭AOF的时候</li></ul><h1 id="AOF重写流程"><a href="#AOF重写流程" class="headerlink" title="AOF重写流程"></a>AOF重写流程</h1><ol><li>子进程读取Redis DB中的数据以字符串命令的格式（也可以看作AOF格式）写入到新AOF中</li><li>如果有新数据，由主进程将数据写入到AOF重写缓冲区（aof_rewrite_buf）</li><li>当子进程完成重写操作后，主进程通过管道将AOF重写缓冲区数据传输给子进程，子进程追加到AOF文件中</li></ol><h1 id="AOF的不足"><a href="#AOF的不足" class="headerlink" title="AOF的不足"></a>AOF的不足</h1><ol><li>额外CPU的开销：<ul><li>如果有新数据，由主进程将数据写入到AOF重写缓冲区</li><li>进程通过管道将AOF重写缓冲区数据传输给子进程</li><li>子进程追加到AOF文件中</li></ul></li><li>额外内存的开销：<br>在重写的时候，Redis不仅将新的操作记录在原有的AOF缓冲区，还记录在AOF重写缓冲区</li><li>额外的磁盘开销：<br>在重写的时候，AOF缓冲需要刷入旧的AOF日志，AOF重写缓冲也需要刷入新的AOF日志，导致在重写的时候多了一份数据</li></ol><p>但是Redis在7.0做了优化？下一个问答</p><h1 id="Redis7-0对AOF做了哪些优化"><a href="#Redis7-0对AOF做了哪些优化" class="headerlink" title="Redis7.0对AOF做了哪些优化"></a>Redis7.0对AOF做了哪些优化</h1><p><img src="/img/Redis%E6%8C%81%E4%B9%85%E5%8C%96/img3.png" alt="alt text"></p><p>原来的AOF重写缓存被移除，采用<br>MP-AOF（Multi Part AOF），即多部件AOF。将原来的一个AOF变成了多个AOF，由manifest（追踪管理AOF文件）来管理。重写的时候还是fork一个子进程来对Base AOF重写</p><ul><li>Base AOF：重写之前的命令</li><li>Incr AOF：追加新的命令</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis线程模型</title>
      <link href="/posts/Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.html"/>
      <url>/posts/Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis线程是单线程还是多线程"><a href="#Redis线程是单线程还是多线程" class="headerlink" title="Redis线程是单线程还是多线程"></a>Redis线程是单线程还是多线程</h1><p>Redis核心处理一直都是单线程，但是其他处理模块也会有一些多线程、多进程的功能</p><ul><li>网络I&#x2F;O解包从6.0开始是多线程</li><li>某些异步流程从4.0开始用的是多进程，比如UNLIKE、FLUSHALL ASYNC等非阻塞的删除操作</li></ul><h1 id="Redis为什么用单线程做核心处理"><a href="#Redis为什么用单线程做核心处理" class="headerlink" title="Redis为什么用单线程做核心处理"></a>Redis为什么用单线程做核心处理</h1><ol><li>首先如果引用多线程，主要是希望利用多核的性能，但是Redis是内存k-v存储，一般不会很慢。真正影响Redis性能的是网络I&#x2F;O</li><li>其次多线程的上下文切换、同步机制开销等成本，会影响Redis的性能</li></ol><h1 id="Redis单线程性能如何"><a href="#Redis单线程性能如何" class="headerlink" title="Redis单线程性能如何"></a>Redis单线程性能如何</h1><p>性能很好，普通机器1s10多万的读性能，几万的写性能</p><p>redis-benchmark测试命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -h 127.0.0.1 -p 6379 -t set,get -n 10000 -q</span><br></pre></td></tr></table></figure><h1 id="为什么Redis单线程性能还这么快"><a href="#为什么Redis单线程性能还这么快" class="headerlink" title="为什么Redis单线程性能还这么快"></a>为什么Redis单线程性能还这么快</h1><ul><li>基于内存操作：Redis是内存k-v存储</li><li>高效的数据结构：依赖String、List、Hash等高效的数据结构</li><li>采用单线程：没有多线程上下文切换、锁竞争等问题</li><li>I&#x2F;O多路复用：Redis的瓶颈在I&#x2F;O而不是CPU，多路复用同时监听多个socket，根据socket上的事件来选择对应的处理器进行处理</li></ul><h1 id="Redis6-0引入多线程是什么"><a href="#Redis6-0引入多线程是什么" class="headerlink" title="Redis6.0引入多线程是什么"></a>Redis6.0引入多线程是什么</h1><ul><li>Redis的瓶颈在I&#x2F;O而不是CPU，但随着互联网的发展，请求量巨大的时候单线程在同步读写I&#x2F;O的时间（读写客户端socket的I&#x2F;O），单核CPU也可能处理不过来。 因此针对核心处理流程中的解包、发包这两个CPU耗时操作，进行了多线程优化</li><li>Redis6.0多线程是默认关闭的，如果需要开启可以在redis.conf中修改。这么做的目的是首先为了兼容以前的，因为很多人认为Redis是单线程。其次是多线程不是必要的，大部分情况下够用</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Java线程池到阻塞队列</title>
      <link href="/posts/%E4%BB%8EJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html"/>
      <url>/posts/%E4%BB%8EJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h1><ul><li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li><li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行</li><li>方便管理线程：线程是稀缺资源，如果无条件地创建，不仅会消耗资源，还会降低线程的稳定性，使用线程池可以统一分配、调优和监考</li></ul><h1 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h1><p><img src="/img/%E4%BB%8EJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/img1.png" alt="alt text"></p><ul><li>corePoolSize：核心线程的数量</li><li>maximumPoolSize：线程池能创建的最大线程个数</li><li>keepAliveTime：空闲线程存活时间</li><li>unit：时间单位</li><li>workQueue：用于保存任务的阻塞队列</li><li>threadFactory：创建线程的工程类</li><li>hadler：饱和策略</li></ul><h1 id="常见线程池的区别以及特点"><a href="#常见线程池的区别以及特点" class="headerlink" title="常见线程池的区别以及特点"></a>常见线程池的区别以及特点</h1><p>newCachedThreadPool：</p><ul><li>特点：newCachedThreadPool创建一个可缓存的线程池，如果当前线程池的长度超过了处理的需要，它可以灵活的回收空闲的线程，当需要添加的时候可以灵活的添加</li><li>缺点：<strong>maximumPoolSize被设置为Inter.MAX_VALUE</strong>，可能会造成OOM</li></ul><p>newFixedThreadPool：</p><ul><li>特点：创建一个定长的线程池，可控制线程最大并发数，超出的任务会在线程中等待</li><li>缺点：线程数量是固定的，但是<strong>阻塞队列是LinkedBlockingQueue</strong>，是无界队列，也可能会造成OOM</li></ul><p>newScheduledThreadPool：</p><ul><li>特点：创建一个固定长度的线程，而且支持定时的以及周期性的任务执行，类似Timer</li><li>缺点：底层封装了<strong>PriorityQueue，同样是无界队列</strong>，可能会造成OOM</li></ul><p>newSingleThreadExecutor：</p><ul><li>特点：单线程化的线程池，它会用唯一的工作线程来执行任务。如果这个线程因为异常结束，那么会有一个新的线程来替代它。它必须保证前一项任务完成才能执行后一项。<strong>阻塞队列是LinkedBlockingQueue</strong>，因此是无界队列，会有OOM的风险</li><li>缺点：因为是单线程，高并发下有压力</li></ul><h1 id="为什么我们不用Executors默认创建线程池的方法，而直接自己手动去调用ThreadPoolExecutor去创建线程池"><a href="#为什么我们不用Executors默认创建线程池的方法，而直接自己手动去调用ThreadPoolExecutor去创建线程池" class="headerlink" title="为什么我们不用Executors默认创建线程池的方法，而直接自己手动去调用ThreadPoolExecutor去创建线程池"></a>为什么我们不用Executors默认创建线程池的方法，而直接自己手动去调用ThreadPoolExecutor去创建线程池</h1><p>Executors 返回的线程池对象的弊端如下：</p><ul><li>newFixedThreadPool 和 newSingleThreadPool: LinkedBlockingQueue无界队列，允许的请求队列长度为 Integer.MAX_VALUE(无界队列)，可能会堆积大量的请求，从而导致 OOM</li><li>newCachedThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM</li><li>newScheduledThreadPool：同样使用无界队列（底层是PriorityQueue），也会堆积大量请求导致OOM</li></ul><h1 id="线程池的饱和策略有哪些"><a href="#线程池的饱和策略有哪些" class="headerlink" title="线程池的饱和策略有哪些"></a>线程池的饱和策略有哪些</h1><ul><li>ThreadPoolExecutor.AbortPolicy：抛出RejectedExecutionException来拒绝任务的处理</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用提交任务的线程运行任务（比如A提交线程，A运行任务）。但是会降低新任务提交速度，影响程序的整体性能</li><li>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃掉最早的未处理的任务</li></ul><h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><ol><li>判断线程池的核心线程数是不是已满，如果不是则创建一个新的工作线程来执行任务。</li><li>如果核心线程数已满，则将提交的任务放在保存任务的阻塞队列中。</li><li>如果工作任务队列满了，则创建一个新的线程来执行任务，直到数量到达maximumPoolSize</li><li>最后如果达到线程池最大线程数，则采取对应的饱和策略</li></ol><h1 id="线程池中execute-和submit-方法有什么区别"><a href="#线程池中execute-和submit-方法有什么区别" class="headerlink" title="线程池中execute()和submit()方法有什么区别"></a>线程池中execute()和submit()方法有什么区别</h1><p>相同点：</p><ul><li>都可以提交任务到线程池中</li></ul><p>不同点：</p><ul><li>接受参数：execute只能执行Runnable类型的任务，submit可以执行Runnable和Callable类型的任务</li><li>返回值：submit方法可以返回持有计算结果的Future对象，而execute没有</li><li>异常处理：submit可以方便处理异常</li></ul><h1 id="Java中Executor、Executors和ExecuteService的区别"><a href="#Java中Executor、Executors和ExecuteService的区别" class="headerlink" title="Java中Executor、Executors和ExecuteService的区别"></a>Java中Executor、Executors和ExecuteService的区别</h1><ul><li>Executor是最基本的接口，只定义了一个execute方法</li><li>ExecuteService是一个高级的接口，实现了Executor并进行了扩展,比如实现了submit方法。这个接口的目的是方便我们使用底层不同的线程池，类似List接口，屏蔽底层差异</li><li>Executors是一个工具类，使用这个工具类可以方便的创建线程。让我们可以不用手动地指定线程池的各个参数，比如Executors.newFixedThreadPool(10)</li></ul><h1 id="线程池有哪些状态"><a href="#线程池有哪些状态" class="headerlink" title="线程池有哪些状态"></a>线程池有哪些状态</h1><p><img src="/img/%E4%BB%8EJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/img2.png" alt="alt text"></p><ul><li>Running:正常状态，可以接受其他线程</li><li>Shutdown：不接受新的任务提交，但是会继续处理等待队列中的任务</li><li>Stop：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li><li>Tidying：所有的任务都销毁，workerCount（线程数量）为0，线程池在向Tidying状态转换时，会执行钩子方法terminated()</li><li>Terminated：terminated()方法介绍后，就会变成这个</li></ul><h1 id="如何合理分配线程池大小——线程池应对IO密集型和CPU密集型的策略"><a href="#如何合理分配线程池大小——线程池应对IO密集型和CPU密集型的策略" class="headerlink" title="如何合理分配线程池大小——线程池应对IO密集型和CPU密集型的策略"></a>如何合理分配线程池大小——线程池应对IO密集型和CPU密集型的策略</h1><ul><li>CPU密集型：也叫计算密集型，其处理器占用率高，也许在某段时间内保持100%占用率。线程配置数大概和CPU核数相当，这样可以使得每个线程在执行任务</li><li>IO密集型：大部分的状况是CPU在等I&#x2F;O (硬盘&#x2F;内存) 的读&#x2F;写操作，但CPU的使用率不高。大部分线程在阻塞，故需要多配置线程数，2 * cpu核数</li></ul><h1 id="线程池如何实现动态修改"><a href="#线程池如何实现动态修改" class="headerlink" title="线程池如何实现动态修改"></a>线程池如何实现动态修改</h1><p>线程池提供了部分setter方法可以设置线程池的参数：</p><ul><li>修改线程数，最大线程数，空闲线程停留时间，拒绝策略等</li><li>可以将线程池的配置参数放入配置中心，然后直接在配置中心修改</li></ul><p>什么时候需要修改？</p><ol><li>需要监考报警策略，获取线程池状态指标，当指标判定为异常后再报警</li><li>分析指标原因，评估策略，然后通过上述线程池提供的接口进行修改</li></ol><h1 id="既然线程池中使用了阻塞队列，那么什么是阻塞队列，阻塞队列有哪些"><a href="#既然线程池中使用了阻塞队列，那么什么是阻塞队列，阻塞队列有哪些" class="headerlink" title="既然线程池中使用了阻塞队列，那么什么是阻塞队列，阻塞队列有哪些"></a>既然线程池中使用了阻塞队列，那么什么是阻塞队列，阻塞队列有哪些</h1><p>阻塞队列支持两个阻塞的插入和删除操作</p><ul><li>支持阻塞的插入put方法：当队列满的时候，队列会阻塞插入元素的线程，直到队列不满</li><li>支持阻塞的移除take方法：当队列为空的时候，队列会阻塞移除元素的线程，直到队列不为空</li></ul><p>阻塞队列：</p><ul><li>ArrayBlockingQueue：底层使用数组结构，创建时必须指定大小，是有界的</li><li>LinkedBlockingQueue：底层使用链表结构，创建时默认大小是Inter.MAX_VALUE，因此是无界的。也可以指定大小成为有界</li><li>PriorityBlockingQueue：一个支持优先级排列的队列，可重写自定义类的compareTo方法来指定排序规则</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列，使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，表示指定多久才能从队列中获得元素</li><li>SynchronousQueue：一个不存储元素的队列，每一次put必须等待一个take操作，否则不能添加元素。适用于传递性场景</li><li>LinkedTransferQueue：一个由链表结构组成的无界队列，设计了一种生产者和消费者之间传递的机制，称为”transfer“。当生产者调用transfer（e）方法时，它会阻塞直到一个消费者接收该元素</li><li>LinkedBlockingDeque：一个由链表结构组成的双端队列</li></ul><h1 id="ArrayBlockingQueue和LinkedBlockingQueue的区别"><a href="#ArrayBlockingQueue和LinkedBlockingQueue的区别" class="headerlink" title="ArrayBlockingQueue和LinkedBlockingQueue的区别"></a>ArrayBlockingQueue和LinkedBlockingQueue的区别</h1><ul><li>底层实现：ArrayBlockingQueue基于数组，LinkedBlockingQueue基于链表</li><li>是否有界：ArrayBlockingQueue有界，LinkedBlockingQueue创建时可以指定大小，默认是Integer.MAX_VALUE，无界</li><li>锁是否分离：ArrayBlockingQueue中的锁不分离，生产者和消费者使用同一把锁。LinkedBlockingQueue的锁分离，生产者使用的是putLock，消费者使用的是takeLock，这样可以防止生产者和消费者之间竞争锁</li><li>内存占用：ArrayBlockingQueue需要提前分配内存，LinkedBlockingQueue是动态分配内存，会不断占用空间</li></ul><h1 id="ArrayBlockingQueue底层源码"><a href="#ArrayBlockingQueue底层源码" class="headerlink" title="ArrayBlockingQueue底层源码"></a>ArrayBlockingQueue底层源码</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] items;  <span class="comment">//队列的底层为数组，是个循环数组</span></span><br><span class="line"><span class="type">int</span> takeIndex;  <span class="comment">//从队列中取元素的索引，用于take、poll、remove</span></span><br><span class="line"><span class="type">int</span> putIndex;  <span class="comment">//向队列中存放元素的索引，用于put、offer、add</span></span><br><span class="line"><span class="type">int</span> count;  <span class="comment">//队列中的元素数</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock; <span class="comment">//队列中的锁机制，可重入锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;   <span class="comment">//notEmpty条件对象，由lock创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;  <span class="comment">//notFull条件对象，由lock创建</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">Itrs</span> <span class="variable">itrs</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">//迭代器对象</span></span><br></pre></td></tr></table></figure><h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><h3 id="add-E-e-（非阻塞方法）"><a href="#add-E-e-（非阻塞方法）" class="headerlink" title="add(E e)（非阻塞方法）"></a>add(E e)（非阻塞方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*调用了offer(e)方法，成功，返回true，失败，抛出IllegalStateException异常*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (offer(e)) </span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在当前put位置插入元素、前进和信号</span></span><br><span class="line"><span class="comment">   * Call only when holding lock. 只有在持有锁资源时才调用该方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">      <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">      <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">      <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items; <span class="comment">//将队列数组初始化</span></span><br><span class="line">      items[putIndex] = x;  <span class="comment">//将元素添加到数组里</span></span><br><span class="line">      <span class="keyword">if</span> (++putIndex == items.length)  <span class="comment">//如果将要插入的元素索引等于数组的长度，将存放元素的索引重新置为0</span></span><br><span class="line">          putIndex = <span class="number">0</span>;</span><br><span class="line">      count++;</span><br><span class="line">      notEmpty.signal();   <span class="comment">//使用条件对象notEmpty通知，唤醒当前等待的线程</span></span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Throws NullPointerException if argument is null.</span></span><br><span class="line"><span class="comment">    *如果参数为null，则抛出NullPointerException的异常</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> v the element</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkNotNull</span><span class="params">(Object v)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (v == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="put-E-e-（阻塞方法）"><a href="#put-E-e-（阻塞方法）" class="headerlink" title="put(E e)（阻塞方法）"></a>put(E e)（阻塞方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将指定的元素插入到此队列的末尾，然后等待</span></span><br><span class="line"><span class="comment">    * for space to become available if the queue is full.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       checkNotNull(e); <span class="comment">//判断元素是否为null</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;  <span class="comment">//初始化重入锁</span></span><br><span class="line">       lock.lockInterruptibly(); <span class="comment">//加锁，以保证在调用put方法时只有一个线程</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (count == items.length) <span class="comment">//当队列满了，阻塞当前线程，并加入到条件对象notFull的等待队列里面</span></span><br><span class="line">               notFull.await(); <span class="comment">//线程阻塞并被挂起，同时释放锁资源</span></span><br><span class="line">           enqueue(e); <span class="comment">//调用enqueue方法</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();  <span class="comment">//释放锁，让其他线程可以调用put方法</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="offer-E-e-（添加方法的具体实现）"><a href="#offer-E-e-（添加方法的具体实现）" class="headerlink" title="offer(E e)（添加方法的具体实现）"></a>offer(E e)（添加方法的具体实现）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       checkNotNull(e); <span class="comment">//检查队列中的元素是否为空。在这里不允许为空</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock; <span class="comment">//引入重入锁</span></span><br><span class="line">       lock.lock(); <span class="comment">//加锁，保证调用offer时只有一个线程</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (count == items.length)  <span class="comment">//如果当前元素的个数等于队列数组的长度，说明队列是满的，添加失败</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">else</span> &#123;<span class="comment">//否则队列不满，调用enqueue(e)方法添加元素，返回true</span></span><br><span class="line">               enqueue(e);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;<span class="comment">//最后，释放锁，让其他线程可以调用offer方法</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h2><h3 id="poll-（非阻塞方法）"><a href="#poll-（非阻塞方法）" class="headerlink" title="poll()（非阻塞方法）"></a>poll()（非阻塞方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock; <span class="comment">//引入重用锁</span></span><br><span class="line">       lock.lock();  <span class="comment">//加锁，以保证当前只有一个线程</span></span><br><span class="line">       <span class="keyword">try</span> &#123;<span class="comment">//如果队列为空，则返回null；否则，调用dequeue方法</span></span><br><span class="line">           <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="literal">null</span> : dequeue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock(); <span class="comment">//释放锁资源，让其他线程可以调用poll方法</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="take-（阻塞方法）"><a href="#take-（阻塞方法）" class="headerlink" title="take()（阻塞方法）"></a>take()（阻塞方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();<span class="comment">//加锁，以保证在调用take()方法时只有一个线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">//当队列中元素个数为1，即队列为空时 </span></span><br><span class="line">            notEmpty.await(); <span class="comment">//阻塞当前线程，并加入到条件对象notEmpty的等待队列里</span></span><br><span class="line">        <span class="keyword">return</span> dequeue(); <span class="comment">//调用dequeue()方法</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">//释放锁，让其他线程可以调用take()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-Object-obj-（删除指定元素）"><a href="#remove-Object-obj-（删除指定元素）" class="headerlink" title="remove(Object obj)（删除指定元素）"></a>remove(Object obj)（删除指定元素）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从队列中删除指定的元素。如果该元素存在，则将该元素从队列中删除，返回true；如果不存在，则返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果指定删除的元素为null，则返回false</span></span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items; <span class="comment">//阻塞队列数组</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock; <span class="comment">//重入锁</span></span><br><span class="line">        lock.lock(); <span class="comment">//加锁，以此保证在调用该remove方法时只有一个线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;<span class="comment">//如果队列不为空</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">putIndex</span> <span class="operator">=</span> <span class="built_in">this</span>.putIndex; <span class="comment">//往队列中即将要存储的元素的下标</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> takeIndex; <span class="comment">//从队列即将要取出元素的下标</span></span><br><span class="line"><span class="comment">//循环遍历阻塞队列中的元素，如果在队列中找到了要删除的元素，则将该元素删除，返回true;否则，返回false。</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (o.equals(items[i])) &#123; <span class="comment">//</span></span><br><span class="line">                        removeAt(i);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                        i = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (i != putIndex);<span class="comment">//结束条件为当前元素索引==最后将要存入队列中的元素的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();<span class="comment">//释放锁资源，让其他线程可以调用remove(e)方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="deque-（poll、take的具体实现）"><a href="#deque-（poll、take的具体实现）" class="headerlink" title="deque()（poll、take的具体实现）"></a>deque()（poll、take的具体实现）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Extracts element at current take position, advances, and signals.提取元素当前的位置、进展和信号</span></span><br><span class="line"><span class="comment">   * Call only when holding lock.在持有锁时才调用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">      <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">      <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;<span class="comment">//阻塞队列数组</span></span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex];<span class="comment">//用变量x记录当前要取出的元素</span></span><br><span class="line">      items[takeIndex] = <span class="literal">null</span>;<span class="comment">//将该元素置为null</span></span><br><span class="line">      <span class="keyword">if</span> (++takeIndex == items.length)<span class="comment">//判断是否是最后一个元素</span></span><br><span class="line">          takeIndex = <span class="number">0</span>; <span class="comment">//如果是，将取元素索引置为0，从头开始取</span></span><br><span class="line">      count--;<span class="comment">//元素个数-1</span></span><br><span class="line">      <span class="keyword">if</span> (itrs != <span class="literal">null</span>) <span class="comment">//迭代遍历队列，</span></span><br><span class="line">          itrs.elementDequeued();</span><br><span class="line">      notFull.signal();<span class="comment">// 使用条件对象notFull通知，比如使用put方法放数据的时候队列已满，被阻塞。这个时候消费了一条数据，队列没满了，就需要调用signal进行通知  </span></span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="LinkedBlockingQueue底层源码"><a href="#LinkedBlockingQueue底层源码" class="headerlink" title="LinkedBlockingQueue底层源码"></a>LinkedBlockingQueue底层源码</h1><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;  <span class="comment">//元素</span></span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//next指针</span></span><br><span class="line">        </span><br><span class="line">        Node(E x) &#123;  <span class="comment">//有参构造函数</span></span><br><span class="line">          item = x;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;  <span class="comment">//容量，默认为 Integer.MAX_VALUE</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();  <span class="comment">//队列中元素的数量</span></span><br><span class="line">        <span class="keyword">transient</span> Node&lt;E&gt; head;  <span class="comment">//头节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;  <span class="comment">//尾节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">//拿锁</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();  <span class="comment">//拿锁的条件，队列不为空</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();  <span class="comment">//放锁</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();  <span class="comment">//放锁的条件</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="添加方法-1"><a href="#添加方法-1" class="headerlink" title="添加方法"></a>添加方法</h2><h3 id="add-E-e-（非阻塞方法）-1"><a href="#add-E-e-（非阻塞方法）-1" class="headerlink" title="add(E e)（非阻塞方法）"></a>add(E e)（非阻塞方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put-E-e-（阻塞方法）-1"><a href="#put-E-e-（阻塞方法）-1" class="headerlink" title="put(E e)（阻塞方法）"></a>put(E e)（阻塞方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();<span class="comment">//判断添加的元素是否为null，如果为Null，抛出NullPointerException异常</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>; </span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e); <span class="comment">//构造新的结点</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock; <span class="comment">//放锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count; <span class="comment">//元素的个数</span></span><br><span class="line">        putLock.lockInterruptibly(); <span class="comment">//放锁加锁，保证在调用put方法的时候只有1个线程 </span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123;<span class="comment">//如果队列为满</span></span><br><span class="line">                notFull.await();<span class="comment">//阻塞并挂起当前线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            enqueue(node);<span class="comment">//将元素添加到链表的尾部</span></span><br><span class="line">            c = count.getAndIncrement(); <span class="comment">//元素个数+1</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity) <span class="comment">//如果队列的容量还没有满</span></span><br><span class="line">                notFull.signal(); <span class="comment">//在notFull对象上唤醒正在等待的1个线程，表示队列中还有元素可以消费</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock(); <span class="comment">//释放放锁，让其他线程可以调用该put方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)<span class="comment">//由于存在放锁和拿锁，这里可能拿锁一直在消费数据，count会变化。这里的if条件表示如果队列中还有1条数据 </span></span><br><span class="line">            signalNotEmpty();<span class="comment">//在拿锁的条件对象notEmpty上唤醒正在等待的1个线程，表示队列里还有1条数据，可以进行消费 </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//enqueue(Node&lt;E&gt; node)（上面方法用到）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> &#123;</span><br><span class="line">        <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">        <span class="comment">// assert last.next == null;</span></span><br><span class="line">        last = last.next = node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="offer-E-e-（添加方法的具体实现，分为offerFirst和OfferLast）"><a href="#offer-E-e-（添加方法的具体实现，分为offerFirst和OfferLast）" class="headerlink" title="offer(E e)（添加方法的具体实现，分为offerFirst和OfferLast）"></a>offer(E e)（添加方法的具体实现，分为offerFirst和OfferLast）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> linkFirst(node);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> linkLast(node);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除方法-1"><a href="#删除方法-1" class="headerlink" title="删除方法"></a>删除方法</h2><h3 id="poll-（非阻塞方法）-1"><a href="#poll-（非阻塞方法）-1" class="headerlink" title="poll()（非阻塞方法）"></a>poll()（非阻塞方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count; <span class="comment">//队列中元素的个数</span></span><br><span class="line">      <span class="keyword">if</span> (count.get() == <span class="number">0</span>) <span class="comment">//判断该队列是否为空</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//如果为空，返回null</span></span><br><span class="line">      <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//定义要返回的元素的变量名，初始化为Null</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;<span class="comment">//拿锁</span></span><br><span class="line">      takeLock.lock();<span class="comment">//拿锁加锁，以保证在调用poll()线程的时候只有1个线程</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;<span class="comment">//判断队列是否为空。如果不为空</span></span><br><span class="line">              x = dequeue();<span class="comment">//删除头节点</span></span><br><span class="line">              c = count.getAndDecrement();<span class="comment">//元素个数-1</span></span><br><span class="line">              <span class="keyword">if</span> (c &gt; <span class="number">1</span>)<span class="comment">//如果队列中还有元素</span></span><br><span class="line">                  notEmpty.signal();<span class="comment">//在拿锁的条件对象notEmpty上唤醒正在等待的线程，表示队列里还有数据，可以再次消费 </span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          takeLock.unlock();<span class="comment">//释放拿锁资源，让其他线程可以调用该poll()方法</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (c == capacity)<span class="comment">//由于存在放锁和拿锁，这里可能放锁一直在添加数据，count会变化。这里的if条件表示如果队列中还可以再插入数据 </span></span><br><span class="line">          signalNotFull();<span class="comment">//在放锁的条件对象notFull上唤醒正在等待的1个线程，表示队列里还能再次添加数据 </span></span><br><span class="line">      <span class="keyword">return</span> x;<span class="comment">//返回删除的元素</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="take-（阻塞方法）-1"><a href="#take-（阻塞方法）-1" class="headerlink" title="take()（阻塞方法）"></a>take()（阻塞方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count; <span class="comment">//队列中元素的个数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;  <span class="comment">//拿锁</span></span><br><span class="line">    takeLock.lockInterruptibly();  <span class="comment">//拿锁加锁，以保证在调用take()方法的时候只有一个线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123; <span class="comment">//如果队列为空</span></span><br><span class="line">            notEmpty.await(); <span class="comment">//则将当前线程阻塞并挂起</span></span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue(); <span class="comment">//否则，删除头节点</span></span><br><span class="line">        c = count.getAndDecrement();  <span class="comment">//元素个数-1</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)  <span class="comment">//判断队列中是否还有元素</span></span><br><span class="line">            notEmpty.signal(); <span class="comment">//如果有，在拿锁的条件对象notEmpty上唤醒正在等待的线程，表示队列里还有数据，可以再次消费 </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock(); <span class="comment">//释放拿锁，以保证其他线程可以调用take()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity) <span class="comment">//表示如果队列中还可以再插入数据 </span></span><br><span class="line">        signalNotFull(); <span class="comment">//在放锁的条件对象notFull上唤醒正在等待的1个线程，表示队列里还能再次添加数据 </span></span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">//返回删除的那个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-Object-o-（删除指定元素）"><a href="#remove-Object-o-（删除指定元素）" class="headerlink" title="remove(Object o)（删除指定元素）"></a>remove(Object o)（删除指定元素）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果要删除的元素为null，返回false</span></span><br><span class="line">    fullyLock(); <span class="comment">//remove操作要移动的位置不固定，2个锁都需要加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;</span><br><span class="line">             p != <span class="literal">null</span>;</span><br><span class="line">             trail = p, p = p.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123;<span class="comment">//判断在队列中是否能找到要删除的对象</span></span><br><span class="line">                unlink(p, trail);<span class="comment">//修改节点的链接信息，同时调用notFull的signal方法 ，唤醒等待的线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果没有找到，返回false</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fullyUnlock();<span class="comment">//2个锁解锁 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove()方法中的加锁方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fullyLock</span><span class="params">()</span> &#123;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    takeLock.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove()方法中的解锁方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fullyUnlock</span><span class="params">()</span> &#123;</span><br><span class="line">    takeLock.unlock();</span><br><span class="line">    putLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deque-（poll、take的具体实现）-1"><a href="#deque-（poll、take的具体实现）-1" class="headerlink" title="deque()（poll、take的具体实现）"></a>deque()（poll、take的具体实现）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert head.item == null;</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    head = first;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;</span><br><span class="line">    first.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构和数据类型</title>
      <link href="/posts/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"/>
      <url>/posts/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>在Redis中有一个核心的对象叫做redisObject ，是用来表示所有的key和value的，用redisObject结构体来表示String、Hash、List、Set、ZSet五种数据类型</p><p><img src="/img/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/img1.png" alt="alt text"></p><p>key和value指向的是<strong>redisObject</strong>对象</p><p><img src="/img/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/img2.png" alt="alt text"></p><ul><li>type：标识该对象用的是什么类型（String、List)</li><li>encoding：编码方式</li></ul><h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><p><img src="/img/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/img3.png" alt="alt text"></p><p>属性：</p><ul><li>len：记录了字符串长度，因此获取字符串长度的时候时间复杂度O(1)</li><li>alloc：分配给字符数组的空间长度。这样在修改字符串的时候，只需要alloc-len来判断剩余空间大小，可以用来判断空间是否满足修改条件，如果不满足就会将SDS扩容。因此不会出现C语言的缓冲区溢出问题</li><li>flags：用来表示不同类型的SDS，表示len和alloc的类型不同，进而保存的SDS分配给字节数组的大小不同</li><li>buf[]：字节数组，用来保存实际数据。不仅可以保存文本数据，还可以保存二进制数据</li></ul><p>Redis底层由C语言实现，那么SDS与C语言字符串对比：</p><ul><li>O(1)获得字符串长度：因为SDS有len属性</li><li>二进制安全：SDS不仅可以保存文本数据，还能保存二进制数据。SDS的使用len属性来判断是否遍历完成，不会管’\0’的字符</li><li>不会发生缓冲区溢出：通过alloc-len来判断剩余空间大小，可以用来判断空间是否满足修改条件，如果不满足就会将SDS扩容。因此不会出现C语言的缓冲区溢出问题</li></ul><p>扩容机制：</p><ul><li>如果所需的SDS长度小于1MB,则翻倍 + 1</li><li>如果所需的SDS长度超过1MB,最后的扩容大小应该是newlen + 1MB + 1</li></ul><h2 id="Ziplist（压缩列表）"><a href="#Ziplist（压缩列表）" class="headerlink" title="Ziplist（压缩列表）"></a>Ziplist（压缩列表）</h2><p><img src="/img/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/img4.png" alt="alt text"></p><p>ziplist构成：</p><ul><li>zlbytes：整个压缩列表占用内存字节数</li><li>zltail：压缩表尾部节点距离起始地址多少个字节，也就是列表尾的偏移量</li><li>zllen：entry节点的个数</li><li>entry：存储数据的部分</li><li>zlend：压缩列表的结束点，固定在0xFF</li></ul><p>entry构成：</p><ul><li>prevlen：前一个节点的长度，目的是实现从后往前遍历</li><li>encoding：记录当前节点实际的类型和长度，类型主要是字符串和整数   </li><li>data：记录当前节点的实际存储数据，类型和长度由encoding决定</li></ul><p>encdoing构成：</p><ul><li>如果当前数据是整数，需要1字节</li><li>如果当前的数据是字符串，会根据需要使用1、2、5字节的空间</li></ul><p>连续更新问题：<br>压缩列表新增某一个元素或者修改某一个元素，如果空间不够，压缩列表占用的内存空间需要重新分配。当更新的元素较大，会导致后续的prevlen也都要重新分配，从而引起连锁更新的问题</p><h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><p>在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现</p><p><img src="/img/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/img5.png" alt="alt text"></p><p>quicklist就是<strong>双向链表+ziplist</strong>的组合，quicklist链表中的每一个节点是一个压缩列表</p><p>解决连锁更新：通过控制链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越小，连锁更新带来的影响就越小，从而性能提升</p><h2 id="dictht（哈希表）"><a href="#dictht（哈希表）" class="headerlink" title="dictht（哈希表）"></a>dictht（哈希表）</h2><p>属性：</p><ul><li>dictEntry **table：数组的每一个元素是指向哈希表节点的指针</li><li>size：哈希表大小</li><li>sizemask：掩码，用于计算索引值</li><li>used：哈希表已有的entry个数</li></ul><p>哈希冲突：</p><ul><li>当两个key不同，但是索引值相同，就会发生冲突</li></ul><p>哈希冲突解决（拉链法）：</p><ul><li>被分配到同一个哈希桶上的多个节点用一个单项链表连接起来</li><li>但是也有缺点，当链表长度过长的时候，查询效率很低</li></ul><p>rehash解决链表长度过长：</p><ol><li>给哈希表2分配空间，一般比哈希表1大一倍</li><li>将哈希表1数据迁移到哈希表2</li><li>迁移完成后，哈希表1的空间释放，并把哈希表2设置为哈希表1，然后在新哈希表2创建出一个空白的哈希表，为下次rehash做准备</li></ol><p>渐进式rehash解决rehash迁徙过程耗时久：</p><ol><li>给哈希表2分配空间，一般比哈希表1大一倍</li><li>在rehash期间，每次哈希表元素新增、删除、查找的时候，Redis会执行对应的操作外，还会将哈希表1中索引位置上的所有dictEntry迁移到哈希表2。查找，更新操作会在两个哈希表上进行。redis会先尝试在 ht[0] 中寻找目标键值对，如果没有找到则会在 ht[1] 再次寻找。但是新增操作就不一样了，新增key只会在新的哈希表 ht[1] 上进行，为的是确保 ht[0] 中的已经被清空的单向链表不会新增元素。在 rehash 被触发后，即使没有收到新请求，Redis 也会定时执行一次 rehash 操作，而且，每次执行时长不会超过 1ms，以免对其他任务造成影响</li><li>迁移完成后，哈希表1的空间释放，并把哈希表2设置为哈希表1，然后在新哈希表2创建出一个空白的哈希表，为下次rehash做准备</li></ol><p>rehash触发条件：</p><ul><li>负载因子 &#x3D; 哈希表已保存的节点数量 &#x2F; 哈希表大小</li><li>当负载因子大于等于1，并且redis没有进行RDB快照和AOF重写的时候，进行rehash</li><li>当负载因子大于等于5，说明哈希冲突非常严重，不管也没用RDB快照和AOF重写，都会强制执行rehash</li></ul><h2 id="intset（整数集合）"><a href="#intset（整数集合）" class="headerlink" title="intset（整数集合）"></a>intset（整数集合）</h2><p>属性：</p><ul><li>encoding：编码方式，比如 INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组</li><li>length：集合包含的元素数量</li><li>contents：虽然被声明为 int8_t 类型，但是实际上是由保存的数据大小由encoding决定</li></ul><p>整数集合升级规则：</p><ul><li>当我们将一个新元素加入集合中，如果新元素的类型(int32_t)比现有元素的类型(int16_t)都要长，需要扩宽contents数组的大小。比如现在有3个类型为int16_t的元素，每个都是16位长度，然后往整数集合里面加入一个新元素65535，这个新元素类型用int32_t保存，然后对contents扩容，会在原本的空间的大小之上多出80位（4 * 32 - 3 * 16 &#x3D; 80），这样就能保证可以存下4个int32_t的元素</li><li>扩容完 contents 数组空间大小后，需要将之前的三个元素转换为 int32_t 类型，并将转换后的元素放置到正确的位上面，并且需要维持底层数组的有序性不变：从后往前依次填充，最后再把65535这个元素放到数组末尾</li></ul><p>整数集合升级优点：</p><ul><li>如果让一个数组保存int16_t、int32_t、int64_t的元素，最好的方式就是用int64_t类型，但是会造成空间的浪费。</li><li>整数升级保证了我们只需要int64_t类型的元素再进行扩容，因此可以节约资源内存</li></ul><p>最后，整数集合不支持降级 </p><h2 id="zkplist（跳表）"><a href="#zkplist（跳表）" class="headerlink" title="zkplist（跳表）"></a>zkplist（跳表）</h2><p><img src="/img/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/img6.png" alt="alt text"></p><p>ziplist属性：</p><ul><li>跳表的头尾节点head，tail（指向ziplistNode）</li><li>跳表的长度length</li><li>跳表的最大层数level</li></ul><p>ziplistNode属性：</p><ul><li>ele：SDS结构存储数据</li><li>score：节点的分数，浮点型</li><li>backward：指向上一个节点的回退指针，支持从表尾向表头遍历，也就是ZREVRANGE命令</li><li>level：是个zskiplistLevel数组，zskiplistLevel包含了两个字段，一个是forward，指向下一层能调到哪个节点，span记录了距离下个节点的步数。数据结构就表示每个节点是个多层结构</li></ul><p>跳表节点层数设置：</p><ul><li>跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)</li><li>Redis在创建节点的时候，会生成范围为[0, 1]的随机数，如果这个随机数小于0.25（相当于概率25%），那么层数就增加一层。然后继续生成下一个随机数，直到随机数的结构大于0.25就结束</li><li>这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64</li></ul><p>为什么用跳表而不用平衡树？</p><ul><li>从内存占用上，跳表比平衡树更灵活：平衡树每个节点包含2个指针，跳表每个节点包含的指针数目为1&#x2F;（1-p），在redis中p&#x3D;0.25，平均每个节点包含1.33个指针，内存占用更少</li><li>在做范围查询的时候，跳表比平衡树操作更简单：在平衡树中我们找到特定范围的最小值后，还需要以中序遍历的顺序寻找其他不超过大值的节点，所以中序遍历不容易实现。而跳表就很简单，只需要找到最小值后，对第一层的节点进行若干步的遍历即可</li><li>在算法实现难度上，跳表更简单。平衡树的插入和删除操作可能引发子树的调整，子树逻辑复杂。而跳表的插入和删除只需要修改相邻的节点，操作简单又迅速</li></ul><h2 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h2><p><img src="/img/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/img7.png" alt="alt text"></p><p>listpack entry构成：</p><ul><li>encoding：定于元素的编码类型，会对不同长度的整数和字符串进行编码</li><li>data：实际存放的数据</li><li>len：encdong+data的总长度</li></ul><p>将prevlen改成len之后能不能从后往前遍历？</p><ul><li>答案是可以。lpDecodeBacklen函数已经实现了</li></ul><h1 id="Redis数据对象"><a href="#Redis数据对象" class="headerlink" title="Redis数据对象"></a>Redis数据对象</h1><p><img src="/img/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/img8.png" alt="alt text"></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>字符串对象的内部编码（encoding）有 3 种 ：int、raw和embstr：</p><ul><li>int：如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型表示，那么这个字符串对象会被保存在redisObject对象的<strong>prt</strong>中，同时将encoding设置成int</li><li>embstr(Embedded string 嵌入式字符串)：如果一个字符串对象保存的是字符串，并且这个字符串对象小于等于32字节。那么字符串对象将用<strong>SDS</strong>表示，同时encoding设置成embstr</li><li>raw：如果一个字符串对象保存的是字符串，并且这个字符串对象大于32字节。那么字符串对象将用<strong>SDS</strong>表示，同时encoding设置成raw</li></ul><p>embstr和raw的区别：</p><ul><li>embstr和raw都会用SDS来保存值。</li><li>embstr会通过一次内存分配函数来分配一块连续的内存空间来保存redisObject和SDS</li><li>而raw编码会调用两次内存分配函数分别分配redisObject和SDS</li></ul><p>embstr相比raw好处：</p><ul><li>embstr编码创建字符串对象只用调用一次内存分配函数，而raw编码需要两次</li><li>释放embstr编码的字符串对象同样也只需要调用一次内存释放函数</li><li>因为embstr编码的字符串对象的所有数据都保存在一块连续的内存空间，可以更好的利用cpu缓存提升性能</li></ul><p>embstr的缺点：</p><ul><li>如果字符串的长度需要重新分配空间时，整个redisObject和sds都需要重新分配空间，所以embstr编码的字符串对象实际上是只读的。redis没有为embstr编码的字符串对象编写任何修改的程序。当我们对embstr编码的字符串对象执行修改的命令，实际上是先将编码从embstr转换成raw，再做修改</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>3.2版本之前是双向链表和压缩列表：</p><ul><li>如果列表中的元素小于512个，列表每个元素的值都小于64字节，redis会用ziplist存储</li><li>否则用双向链表</li></ul><p>3.2版本之后： 统一用quicklist</p><p>7.0版本之后，统一用listpack</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><ul><li>如果哈希类型元素个数小于512个，并且所有值小于64字节，Redis会用ziplist（7.0版本开始采用listpack）底层数据结构</li><li>否则用哈希表</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li>如果集合中的元素都是整数且元素个数小于512使用整数集合</li><li>否则用哈希表</li></ul><h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><ul><li>如果有序集合元素小于128个，并且每个元素大小小于64字节，使用ziplist（7.0版本开始采用listpack）</li><li>否则用skiplist</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/posts/JVM.html"/>
      <url>/posts/JVM.html</url>
      
        <content type="html"><![CDATA[<p>The Java Virtual Machine (JVM) is a crucial component of the Java programming language. It is an abstract computing machine that enables a computer to run Java programs. The JVM is platform-independent, meaning it can run on any device or operating system that has a compatible JVM implementation</p><p>总的来说，分为五部分：程序计数器，虚拟机栈，本地方法栈，方法区，堆<br><img src="/img/JVM/img1.png" alt="alt text"></p><h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><h2 id="什么是程序计数器"><a href="#什么是程序计数器" class="headerlink" title="什么是程序计数器"></a>什么是程序计数器</h2><p>程序计数器：是线程私有的，记录当前虚拟机正在执行的线程指令地址。首先实现了代码的基本控制流程，比如顺序、选择、循环等，其次是因为记录了当前线程指令地址，在当前线程下次被切换回来时，可以知道它上次执行到的位置</p><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="虚拟机栈是什么"><a href="#虚拟机栈是什么" class="headerlink" title="虚拟机栈是什么"></a>虚拟机栈是什么</h2><ul><li>虚拟机栈：由很多栈帧组成（一个方法有一个栈帧），每个栈帧包含：局部变量表、操作数栈、动态链接、返回地址等信息</li><li>局部变量表：存储当前方法参数和当前方法内部 的局部变量。局部变量表的最小容量用变量槽来表示，其中64位长度的long和double会占用两个变量槽。如果执行的是实例方法，那么当前第0个变量槽存放的是用于传递方法所属对象实例的引用，在方法中可以用“this”来访问。此外，还通过变量槽复用达到减少内存空间的使用，比如当前PC计数器超出的这个变量的作用域，那么这个变量的变量槽就可以被复用</li><li>操作数栈：为当前方法运行提供了一个临时计算过程结果的存储</li><li>动态链接：在运行期间部分符号引用转变为直接引用，为了支持java多态</li><li>返回地址：<ol><li>遇到方法返回的字节码指令</li><li>出现了异常，有异常处理则交给异常处理器，否则抛异常</li></ol></li></ul><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><h2 id="本地方法栈是什么"><a href="#本地方法栈是什么" class="headerlink" title="本地方法栈是什么"></a>本地方法栈是什么</h2><p>先介绍虚拟机栈，然后：类似虚拟机栈，本地方法栈为java虚拟机提供native方法的服务。native方法一般是由C&#x2F;C++编写</p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>方法区： 首先它是虚拟机规范的抽象概念。 他是所有线程共享的内存区域，在hotspot jkd1.8之前，方法区的实现是永久代。而在jdk 1.8，采用的是元空间</p><h2 id="对于永久代和元空间主要有以下两个区别："><a href="#对于永久代和元空间主要有以下两个区别：" class="headerlink" title="对于永久代和元空间主要有以下两个区别："></a>对于永久代和元空间主要有以下两个区别：</h2><ol><li><p>永久代位于java虚拟机内，元空间位于本地内存。因此永久代受限于JVM可用内存，但是元空间使用的是直接内存，受本地内存的限制，因此内存溢出的可能性更小。</p></li><li><p>永久代本身是面向堆来设计的，所以存储在永久代的对象不是内存连续的，所以需要额外的存储信息和额外的对象查找机制来定位对象，所以比较麻烦。（最开始使用永久代是为了进行一定程度的代码复用）</p></li></ol><h2 id="那么方法区到底存储了什么东西？"><a href="#那么方法区到底存储了什么东西？" class="headerlink" title="那么方法区到底存储了什么东西？"></a>那么方法区到底存储了什么东西？</h2><ol><li><p>在类加载的第一个阶段，会将类的类型信息加载进入方法区（包括类签名、属性、方法）</p></li><li><p>运行时常量池：常量池，存储了符号引用和部分直接引用，字面量等信息，运行时常量池主要负责动态解析符号引用，将符号引用转换为直接引用，以及字节码生成的字面量。以及还有一些字符串常量池，在jdk1.8之前字符串常量池在永久代中，1.8时在堆中。因此对于某些方法，比如intern方法，如果目标字符串在字符串常量池中存在，就返回其引用，否则创建并返回其在字符串常量池中的引用，那么在1.8时，由于字符串常量池在堆中，即使字符串常量池中没有对应的字符串对象，也只会创建一个指向堆中的该字符串对象的引用</p></li></ol><h2 id="既然提到了类加载机制，不妨谈谈类加载机制？"><a href="#既然提到了类加载机制，不妨谈谈类加载机制？" class="headerlink" title="既然提到了类加载机制，不妨谈谈类加载机制？"></a>既然提到了类加载机制，不妨谈谈类加载机制？</h2><p>类加载机制是将javac编译产生的.class对象中的二进制数据读入到方法区中的常量池，然后在堆区创建一个此类的class对象，通过这个class对象可以访问到方法区中的类信息</p><p>分为加载、链接（验证、准备、解析）、初始化这几个步骤</p><ul><li><p>加载：</p><ol><li>通过类的全限定名（ 包名 + 类型名）获取此类的二进制流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个该类的class对象，作为方法区类信息的访问入口</li></ol></li><li><p>验证：<br>确保class文件的字节流所包含的class类信息符合虚拟机规范</p></li><li><p>文件格式验证：字节流是否符合标准</p><ol><li>元数据验证：验证数据是否合理，比如所有类应该有父类</li><li>字节码验证：验证字节码是否会危害虚拟机，因此java具有安全性</li><li>符号引用验证（发生在解析阶段，因此链接不仅仅是准备阶段前）：检查常量池中引用的外部类是否存在，可以正常访问</li></ol></li><li><p>准备：为类变量分配内存并设置类变量初始值的阶段（局部变量不存在准备阶段，不能被赋值就不能被使用）。如果是final修饰，意味者在Class文件中，该字段的属性表中存在Constantvalue属性，此时初值设置为代码里写的。如果不是，就设置成零值，等到初始化阶段再赋值</p></li><li><p>解析：虚拟机将常量池的符号引用转化为直接引用</p></li><li><p>初始化：开始执行类中的java代码，调用类构造器</p></li></ul><h2 id="类加载器有哪些？"><a href="#类加载器有哪些？" class="headerlink" title="类加载器有哪些？"></a>类加载器有哪些？</h2><p>首先类加载器是属于JVM规范，是抽象概念</p><p>在规范中类加载器分为Bootstrap ClassLoader和Other，也就是启动类加载器和非启动类加载器</p><p>在hotspot实现中，bootstrap classloader是C&#x2F;C++实现（加载<java_home>&#x2F;lib），无法作为对象被程序引用。other类包括：extension classloader（加载<java_home>&#x2F;lib&#x2F;ext），applicaition classloader（加载<java_home>&#x2F;java.class.path）, user classloader（任意来源）。非bootstrap classloader（other类）都采用java来实现，都继承自java.lang.classloader，都可以作为对象被引用。除了user classloader，其他都只能从本地文件中获取字节码来加载，而user classloader可以获取任意来源的字节码。除了bootstrap classloader，其余类加载器后续加载流程都一样，因为都继承了java.lang.classloader, 在底层源码中逻辑都一样并且defineClass方法存在final修饰符，表示无法被重写。</p><h2 id="类加载模型主要是什么？"><a href="#类加载模型主要是什么？" class="headerlink" title="类加载模型主要是什么？"></a>类加载模型主要是什么？</h2><p>在默认情况下，一个限定名的类只会被一个类加载器加载，这样的话在程序中它就是唯一的，因此需要双亲委派模型</p><p>一个类加载器收到一个类的加载请求时，会先给他的父亲类去请求，这样最终一直请求到bootstrap classloader，然后再从上到下，如果父亲类加载器不能被加载，则委派给儿子类，如果没有可以被加载的，则会报ClassNotFoundException错误。越核心的类库会越被上层的类加载器加载，而某限定名的类一旦被加载过了，此后就不会被加载，这样就能有效避免类加载混乱</p><p>但是双亲委派模型由于存在设计缺陷，因此也有可能被打破：</p><p>因为java类加载器在加载第一个类的时候，这个类所引用的其他类也是由于这个类加载器去加载。这样的话，比如jdbc是没办法实现的，因此需要打破双亲委派模型</p><ul><li>打破的情况：</li></ul><ol><li>自定义类重写java.lang.loadClass方法，以实现自己的类加载逻辑</li><li>OSGi</li><li>SPI</li></ol><ul><li>哪些框架破坏了双亲委派模型？</li></ul><ol><li>Tomcat</li><li>Springboot</li><li>OSGi</li></ol><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的基本结构"><a href="#堆的基本结构" class="headerlink" title="堆的基本结构"></a>堆的基本结构</h2><p>堆存放对象实例，可以分为新生代和老年代。新生代又分为伊甸园、from区、to区</p><p>也是虚拟机中管理内存的最大一块，被线程共享，物理上不连续（因此速度相比慢，由于cache命中率低），逻辑上连续</p><p>堆也可以通过参数-Xms -Xmx设置堆的最小容量和最大容量</p><p>同时也是GC的主要地方</p><h2 id="详细解释一下GC"><a href="#详细解释一下GC" class="headerlink" title="详细解释一下GC"></a>详细解释一下GC</h2><h3 id="为什么要GC"><a href="#为什么要GC" class="headerlink" title="为什么要GC?"></a>为什么要GC?</h3><p>GC就是垃圾回收，java提供的GC可以自动监测对象是否超过作用域从而达到自动回收内存的目的，防止内存占用过多导致内存溢出</p><h3 id="可以作为GC-roots的对象有哪些？"><a href="#可以作为GC-roots的对象有哪些？" class="headerlink" title="可以作为GC roots的对象有哪些？"></a>可以作为GC roots的对象有哪些？</h3><ul><li>虚拟机栈中引用的对象，例如方法堆栈中的参数，局部变量，临时变量等</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中Native方法引用的对象</li><li>Java虚拟机内部的引用对象，比如基本数据类型对应的Class对象、线程等</li></ul><h3 id="什么情况下会被回收？"><a href="#什么情况下会被回收？" class="headerlink" title="什么情况下会被回收？"></a>什么情况下会被回收？</h3><p>当对象不存活的时候会被回收，判断对象存活与否有两种：</p><ul><li>第一点是引用计数法，给对象添加一个引用计数器。当一个对象被引用，计数器就加1，当一个对象被取消引用，就-1。计数器为0的对象是会被回收的。但是有弊端：循环引用造成对象不可能会被回收</li><li>第二点是可达性分析，以GC roots为起点，从这些节点向下搜索，通过引用链看能不能找到</li></ul><h3 id="如何可达性分析？"><a href="#如何可达性分析？" class="headerlink" title="如何可达性分析？"></a>如何可达性分析？</h3><p>不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响</p><p>分为强引用、软引用、弱引用、虚引用</p><ul><li>强引用：只要还有强引用指向该对象，就说明还存活</li><li>软引用：只有当JVM内存不足时，才会回收软引用的对象</li><li>弱引用：不管内存够不够，都会回收只有弱引用的对象</li><li>虚引用：等于没有被引用，在任何时候都可能被回收，目的是为了在对象被垃圾回收时起到一个通知作用</li></ul><h3 id="GC根据作用域划分："><a href="#GC根据作用域划分：" class="headerlink" title="GC根据作用域划分："></a>GC根据作用域划分：</h3><ul><li>Minor GC：只是回收新生代</li><li>Major GC: 只是回收老年代</li><li>Full GC: 整堆回收</li><li>Mixed GC: 收集整个新生代和部分老年代的垃圾（目前只有G1 GC会有这种行为）</li></ul><h3 id="堆分配策略："><a href="#堆分配策略：" class="headerlink" title="堆分配策略："></a>堆分配策略：</h3><p>首先大部分情况分配在伊甸园区，如果伊甸园内存不足，触发Minor GC，当然大对象直接进入老年代。接着长期存活的对象进入老年代（在新生代存活时间超过一定阈值的对象，每经过一次Minor GC 都会增长一次年龄）</p><p>此外，还有一些机制保证GC:</p><p>动态年龄判定以及空间分配担保</p><ul><li>动态年龄判定：当Survivor区中相同年龄对象的总和大于Survivor空间的一半时，则年龄大于或等于该年龄的对象可以直接进入老年区，不用直接达到阈值</li><li>空间分配担保：在发生Minor GC之前，虚拟机要看老年代最大可用的连续空间是否大于新生代所有的对象空间，如果是，则Minor GC是安全的，否则虚拟机会看老年代最大的连续空间是否大于历次晋升到老年代的平均大小，如果大则担保成功，触发Minor GC。否则，触发Full GC</li></ul><h3 id="四大回收算法"><a href="#四大回收算法" class="headerlink" title="四大回收算法"></a>四大回收算法</h3><ul><li>标记清除算法：将需要回收的对象标记，然后清除。缺点是会产生内存碎片</li><li>复制算法：为了解决内存碎片问题。将内存分为相同大小的两块，每次只使用其中的一块，当其中一块用完了则复制到另一块，并且这一块全部回收。缺点是内存占用大</li><li>标记整理算法：和标记清除算法一样，但是不同的是后续不是直接清理，而是让所以存活的对象移动到同一端</li><li>分代收集算法：严格来说不是一套理论，而是综合以上三种算法根据不同情况选择不同的回收算法。一般来说，新生代使用复制算法，老年代使用标记清除算法或者标记整理算法</li></ul><h3 id="为什么需要Survivor-区？"><a href="#为什么需要Survivor-区？" class="headerlink" title="为什么需要Survivor 区？"></a>为什么需要Survivor 区？</h3><p>如何没有Survivor区，那么会直接进入Old区，这样会导致Old区很快被填满，但是由于虽然一次Minor GC没有回收，但也不会存活几次。因此放在Survivor区可以减少Major GC的发生。当存活年龄达到16次时再进入Old区</p><h3 id="Survivor-区为什么需要两个？"><a href="#Survivor-区为什么需要两个？" class="headerlink" title="Survivor 区为什么需要两个？"></a>Survivor 区为什么需要两个？</h3><p>因为一个的话由于标记清除会导致内存碎片问题，但是两个区域的话，将Eden区和From区复制到To区，第二次GC时再交换From和To的职责，将Edge和To区复制到From区。这样永远有一个Survivor区是空的，另一个非空的是无碎片的。为什么不继续分多一点？因为再细分下去，每一块的Survivor的空间会更小，两块综合考虑更好</p><h3 id="那么有哪些垃圾回收器？"><a href="#那么有哪些垃圾回收器？" class="headerlink" title="那么有哪些垃圾回收器？"></a>那么有哪些垃圾回收器？</h3><p>主要可以分为四类垃圾收集器：</p><ol><li><p>串行垃圾收集器：</p><ul><li>serial gc:单线程垃圾收集器，使用时必须先stop the world（进入一个安全点，其他用户线程均阻塞），然后直到他收集结束。采取标记复制算法。通常在单核cpu或较小的应用中去使用</li><li>serial old gc:serial gc的老年代版本，单线程垃圾回收，采取标记整理算法</li></ul></li><li><p>吞吐量优先的垃圾回收器：</p><ul><li>Parallel gc：并行垃圾回收器.工作在新生代，采用标记复制算法，多线程垃圾回收算法，线程数量与CPU核数相关。以吞吐量优先意味着总的时间花费少</li><li>Parallel old gc：并行垃圾回收器.区别在于工作在老年代</li></ul></li><li><p>响应时间优先</p></li></ol><p>CMS GC：并发垃圾收集器，工作在老年代，如果并发失败，会退化成serial old。采用的是并发标记清除算法</p><p>当触发垃圾回收机制时，有以下4个阶段：</p><pre><code>1. 初始标记：短暂地stop the world，标记直接与gc roots能直接关联的对象2. 并发标记：从gc roots开始进行可达性分析，标记存活对象，用户线程不需要暂停，不需要stop the world。由三色标记算法保证3. 重新标记：由于并发标记阶段可能引用发生了变化，发生错标、漏标，因此需要stop the world来重新标记4. 并发清理：清理未标记对象，用户线程不需要暂停</code></pre><p>整个过程消耗时间最长的是并发标记和并发清除阶段，这两个阶段垃圾收集线程可以和用户线程一起工作。</p><p>优点是并发收集，停顿时间短</p><p>缺点是标记清除算法，会导致大量内存碎片以及会产生浮动垃圾，因为并发清理阶段还有用户线程在运行，就会产生新的垃圾</p><p>ParNew GC:与之配合，工作在新生代，基于复制算法的垃圾回收器</p><ol start="4"><li>同时注重吞吐量和低延迟的G1垃圾收集器，JDK9默认</li></ol><p>G1将堆分为相同大小的分区，每个分区大小是2的幂次方。有4种不同类型的分区，eden，survivor，old，humongous</p><p>整体上是标记整理算法，两个区域之间采取的是标记复制算法</p><p>整体分为以下几个步骤：</p><pre><code>1. 初始标记。暂停其他线程，记录直接与gc roots相连的对象2. 并发标记。从gc roots开始进行可达性分析，找出要回收的对象，耗时较长，不过可以与用户程序同时执行。3. 最终标记。需要对其他线程做短暂的暂停，用于处理并发标记阶段对象出现引用变化的区域4. 筛选回收。对整个分区的回收价值和成本进行排序，然后根据用户所期望的停顿时间来制作回收计划。把回收的分区的存活对象复制到空的分区中，再清理掉整个旧的分区的全部空间。因此也需要stop the world</code></pre><h3 id="三色标记算法？"><a href="#三色标记算法？" class="headerlink" title="三色标记算法？"></a>三色标记算法？</h3><p>整个标记过程：</p><ol><li><p>将标记对象分为三种颜色：</p><ul><li>白色——该对象没有被标记过（垃圾）</li><li>灰色——对象已经被标记过，但他的属性没有被标记完</li><li>黑色——对象已经被标记过，他的属性也标记完了</li></ul></li></ol><p>初始时，所有对象都在白色集合里面，然后从gc roots开始进行可达性分析，将gc roots直接引用的对象移动到灰色集合，然后再从灰色集合中根据属性不断再取出新的标记对象，放到灰色集合里面，然后将本对象放到黑色集合里面。如此反复直到没有灰色对象</p><ol start="2"><li><p>优点：用于垃圾回收，将stw升级为并发标记。然后避免重复标记，提高了效率</p></li><li><p>存在的问题：</p></li></ol><p>由于并发标记阶段对象引用发生变化，所以会出现错标和漏标的情况</p><p>浮动垃圾：在并发标记阶段，已经被标记成黑色或灰色的对象，突然变成了垃圾，由于不会再对黑色的对象重新扫描，那么这个对象不是白色的但是会被清除。于是只能留到下一次gc去回收，所以一般情况下老年代占到百分之80到90就回收</p><p>对象漏标问题：<br>在并发标记对象，一个对象是黑色，但是这个对象引用发生了变化，引用到了需要被回收的对象</p><p>因此漏标问题一定要解决，对于不同的垃圾回收器处理策略也不一样</p><ul><li><p>cms：写屏障+增量更新</p></li><li><p>g1：写屏障+原始快照 stab</p></li><li><p>zgc：读屏障</p></li><li><p>增量更新：如果白色对象被重新指定引用，那么被指定的对象是黑色，那么就将这个引用记录下来，之后等并发标记结束后，再重新扫描一遍，以黑色对象为根，相当于黑色对象变成了灰色</p></li><li><p>原始快照 stab：当灰色对象要删除指向白色对象的引用时，将这个要删除的引用记录下来，并发标记结束后再重新扫描一遍</p></li></ul><h3 id="什么是跨代引用？"><a href="#什么是跨代引用？" class="headerlink" title="什么是跨代引用？"></a>什么是跨代引用？</h3><p>java中不同代存在引用，比如新生代引用老年代</p><p>问题：比如在minor gc时，存在老年代指向新生代的引用，但是由于是minor gc，将会产生漏标问题</p><p>解决：minor gc时，将整个老年代的对象也加入扫描范围，但是这样做效率太低，因此引入记忆集的数据结构<br>记忆集是在新生代开辟一个空间来存储一个集合，用来存放老年代对新生代的引用，因此在minor gc时不需要扫描整个老年代，只需要扫描新生代+记忆集。在hotspot中采用一种卡表的方式实现。卡表是使用一个字节数组实现，每个元素对应着其标识的卡页</p><h3 id="full-gc触发条件？"><a href="#full-gc触发条件？" class="headerlink" title="full gc触发条件？"></a>full gc触发条件？</h3><ul><li>System.gc() 主动</li><li>老年代空间不足</li><li>空间分配担保失败</li><li>jdk1.7及之前的永久代空间不足</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用设计模式</title>
      <link href="/posts/undefined.html"/>
      <url>/posts/undefined.html</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式就是: 在程序运行期间, 某些类有且最多只有一个实例对象</p><h2 id="饿汉模式-静态常量"><a href="#饿汉模式-静态常量" class="headerlink" title="饿汉模式(静态常量)"></a>饿汉模式(静态常量)</h2><p>饥饿模式又称为饿汉模式, 指的是JVM在加载类的时候就完成类对象的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式(静态常量)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line">    <span class="comment">//构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//本类创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton1</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line">    <span class="comment">//提供一个公有的静态方法，返回对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>优点：JVM层面的线程安全。JVM在加载这个类的时候就会对它进行初始化, 因此JVM层面包证了线程安全</li><li>缺点：造成空间的浪费</li></ul><h2 id="饿汉模式（静态代码块）"><a href="#饿汉模式（静态代码块）" class="headerlink" title="饿汉模式（静态代码块）"></a>饿汉模式（静态代码块）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式(静态代码块)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="comment">//构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//本类创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供一个公有的静态方法，返回对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</p><h2 id="饿汉模式（枚举）"><a href="#饿汉模式（枚举）" class="headerlink" title="饿汉模式（枚举）"></a>饿汉模式（枚举）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton8</span> &#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的(枚举类也是在JVM层面保证的线程安全)，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p><h2 id="懒汉模式（线程不安全，不可用）"><a href="#懒汉模式（线程不安全，不可用）" class="headerlink" title="懒汉模式（线程不安全，不可用）"></a>懒汉模式（线程不安全，不可用）</h2><p>真正需要的时候再完成类对象的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式(线程不安全)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建instance 即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：节省空间</li><li>缺点：线程不安全</li></ul><h2 id="懒汉模式（线程安全，同步方法，不推荐用）"><a href="#懒汉模式（线程安全，同步方法，不推荐用）" class="headerlink" title="懒汉模式（线程安全，同步方法，不推荐用）"></a>懒汉模式（线程安全，同步方法，不推荐用）</h2><p>通过<code>synchronized</code>关键字对获取实例的方法进行同步限制, 实现了线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式(线程安全)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton4</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton4</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建instance 即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>优点：线程安全</li><li>缺点：对所有线程的访问都会进行同步操作, 有很严重的性能问题</li></ul><h2 id="懒汉模式（线程不安全，同步代码块，不可用）"><a href="#懒汉模式（线程不安全，同步代码块，不可用）" class="headerlink" title="懒汉模式（线程不安全，同步代码块，不可用）"></a>懒汉模式（线程不安全，同步代码块，不可用）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式(线程安全, 同步代码块)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton5 instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton5</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建instance 即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton5.class)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton5</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (instance &#x3D;&#x3D; null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例</p><h2 id="懒汉模式（线程安全，双重检查-推荐用）"><a href="#懒汉模式（线程安全，双重检查-推荐用）" class="headerlink" title="懒汉模式（线程安全，双重检查, 推荐用）"></a>懒汉模式（线程安全，双重检查, 推荐用）</h2><p>双重检查锁(Double Checked Locking, 简称DCL)模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双重检查</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton6</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton6</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton6 instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton5.class)&#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton6</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多处理器的共享内存、或者编译器的优化下, DCL模式并不一定线程 —— 可能 (注意: 只是可能出现) 会发生指令的重排序, 出现半个对象的问题</p><p>Java中创建一个对象的过程并不是原子性操作，可能会发生指令的重排序（先把这个实例的引用指向地址，再对成员初始化）, 出现半个对象的问题</p><p>因此要用<code>volatile</code>关键字修饰<code>instance</code>变量</p><p>半对象问题：当一个线程进来的时候，判断对象是否为空？肯定为空，因为还没创建呢，往下执行，拿到锁，继续往下执行，再次判断是否为空？为空，往下执行，在new对象的时候，对象有个半初始化的一个状态，在执行完new的时候，分配了一块空间，成员变量是引用类型那么它的值为null，就在此时，<code>invokespecial</code>和<code>astore 1</code>发生了指令重排序，直接将<code>instance</code>指向了初始化一半还没有调用构造方法的内存空间，这时候第二个线程进来了，判断对象为空吗？不为空，为啥？因为它指向了一个半初始化的一个对象嘛！既然不为空，我就直接返回了这个初始化一半的对象</p><h2 id="懒汉式（线程安全，静态内部类，推荐用）"><a href="#懒汉式（线程安全，静态内部类，推荐用）" class="headerlink" title="懒汉式（线程安全，静态内部类，推荐用）"></a>懒汉式（线程安全，静态内部类，推荐用）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton7</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton7</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建instance 即懒汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton7</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton7</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton7 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>JVM在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类(SingletonHolder)的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性(instance)</li><li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li></ul><h2 id="破坏单例模式"><a href="#破坏单例模式" class="headerlink" title="破坏单例模式"></a>破坏单例模式</h2><p>除枚举方式外, 其他方法都会通过反射的方式破坏单例</p><ol><li><p>反射是通过调用构造方法生成新的对象, 可以在构造方法中进行判断 —— 若已有实例, 则阻止生成新的实例,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Singleton already initialized, 此类是单例类, 不允许生成新对象, 请通过getInstance()获取本类对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果单例类实现了序列化接口Serializable, 就可以通过反序列化破坏单例。可以不实现序列化接口, 或者重写反序列化方法readResolve(), 反序列化时直接返回相关单例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化时直接返回当前实例</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Object#clone()方法也会破坏单例, 即使你没有实现Cloneable接口 —— 因为clone()方法是Object类中的。可以重写clone()方法, 并在其中抛出异常信息“Can not create clone of Singleton class”</p></li></ol><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p><img src="/img/Java%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-5.png" alt="alt text"></p><ul><li><p>Factory: 工厂角色 负责根据不同的参数创建不同的实例。</p></li><li><p>IProduct: 抽象产品角色 所有产品实例的接口，负责描述所有产品实例的行为。</p></li><li><p>Product(A B ..): 具象产品角色，所有产品的实例，实现了抽象产品定义的代码</p></li></ul><p>示例:</p><p>平台做一个机票代购业务，对接了两个供应商A、B，用户选择完机票后，平台拿着机票去供应商下单。下单时根据机票由那个供应商提供去相应的供应商去下单。</p><ol><li><p>定义一个下单接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IVender</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供应商下单方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">order</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分别实现A、B供应商的下单方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VendorA</span> <span class="keyword">implements</span> <span class="title class_">IVender</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">order</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A供应商下单成功,下单时间&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VendorB</span> <span class="keyword">implements</span> <span class="title class_">IVender</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">order</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B供应商下单成功，下单时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接着定义一个工厂类，根据传入的不同参数请求，分别创建不同的供应商实例并返回，若碰到无效的参数，则抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VendorFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IVender <span class="title function_">createVendor</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VendorA</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VendorB</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;供应商不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后，由我们客户端进行调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">        <span class="type">IVender</span> <span class="variable">iVender</span> <span class="operator">=</span> VendorFactory.createVendor(type);</span><br><span class="line">        iVender.order();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>缺点：缺点在于不符合<code>开闭原则</code>，每次添加新产品就需要修改工厂类。在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展维护，并且工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><ul><li>工厂方法模式将工厂抽象化，并定义一个创建对象的接口。每增加新产品，只需增加该产品以及对应的具体实现工厂类，由具体工厂类决定要实例化的产品是哪个，将对象的创建与实例化延迟到子类，这样工厂的设计就符合“开闭原则”了，扩展时不必去修改原来的代码。</li><li>缺点：但缺点在于，每增加一个产品都需要增加一个具体产品类和实现工厂类，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</li></ul><ol><li><p>抽象产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂方法的抽象产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interviewer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">askQuestion</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Developer</span> <span class="keyword">implements</span> <span class="title class_">Interviewer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">askQuestion</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;询问设计模式相关的问题&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommunityExecutive</span> <span class="keyword">implements</span> <span class="title class_">Interviewer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">askQuestion</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;询问社区建设相关的问题&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HiringManager</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象工厂方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Interviewer <span class="title function_">makeInterviewer</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeInterviewer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Interviewer</span> <span class="variable">interviewer</span> <span class="operator">=</span> makeInterviewer(); <span class="comment">//创建具体的</span></span><br><span class="line">        interviewer.askQuestion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体工厂（决定要实例化的产品是哪个）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DevelopmentManager</span> <span class="keyword">extends</span> <span class="title class_">HiringManager</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Interviewer <span class="title function_">makeInterviewer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Developer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarketingManager</span> <span class="keyword">extends</span> <span class="title class_">HiringManager</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Interviewer <span class="title function_">makeInterviewer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommunityExecutive</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式定义了一系列的算法，并将每一个算法封装起来，使每个算法可以相互替代，使算法本身和使用算法的客户端分割开来，相互独立</p><ol><li><p>策略接口角色IStrategy：用来约束一系列具体的策略算法，策略上下文角色ConcreteStrategy使用此策略接口来调用具体的策略所实现的算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//策略接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStrategy</span> &#123;</span><br><span class="line">    <span class="comment">//定义的抽象算法方法 来约束具体的算法实现方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithmMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体策略实现角色ConcreteStrategy：具体的策略实现，即具体的算法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 具体的策略实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategy</span> <span class="keyword">implements</span> <span class="title class_">IStrategy</span> &#123;</span><br><span class="line">     <span class="comment">//具体的算法实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithmMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is ConcreteStrategy method...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>策略上下文角色StrategyContext：策略上下文，负责具体的策略实现交互，通常策略上下文对象会持有一个真正的策略实现对象，策略上下文还可以让具体的策略实现从其中获取相关数据，回调策略上下文对象的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyContext</span> &#123;</span><br><span class="line">    <span class="comment">//持有一个策略实现的引用</span></span><br><span class="line">    <span class="keyword">private</span> IStrategy strategy;</span><br><span class="line">    <span class="comment">//使用构造器注入具体的策略类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StrategyContext</span><span class="params">(IStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//调用策略实现的方法</span></span><br><span class="line">        strategy.algorithmMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>外部客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建具体测策略实现</span></span><br><span class="line">        <span class="type">IStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategy</span>();</span><br><span class="line">        <span class="comment">//2.在创建策略上下文的同时，将具体的策略实现对象注入到策略上下文当中</span></span><br><span class="line">        <span class="type">StrategyContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyContext</span>(strategy);</span><br><span class="line">        <span class="comment">//3.调用上下文对象的方法来完成对具体策略实现的回调</span></span><br><span class="line">        ctx.contextMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>缺点：</li></ul><ol><li>客户端必须了解所有的策略，清楚它们的不同：<br>如果由客户端来决定使用何种算法，那客户端必须知道所有的策略，清楚各个策略的功能和不同，这样才能做出正确的选择，但是这暴露了策略的具体实现</li><li>增加了对象的数量：<br>由于策略模式将每个具体的算法都单独封装为一个策略类，如果可选的策略有很多的话，那对象的数量也会很多</li><li>只适合偏平的算法结构：<br>由于策略模式的各个策略实现是平等的关系（可相互替换），实际上就构成了一个扁平的算法结构。即一个策略接口下面有多个平等的策略实现（多个策略实现是兄弟关系），并且运行时只能有一个算法被使用。这就限制了算法的使用层级，且不能被嵌套</li></ol><ul><li>本质：<br>分离算法，选择实现。如果没有上下文，策略模式就回到了最基本的接口和实现了，只要是面向接口编程，就能够享受到面向接口编程带来的好处，通过一个统一的策略接口来封装和分离各个具体的策略实现，无需关系具体的策略实现。貌似没有上下文什么事，但是如果没有上下文的话，客户端就必须直接和具体的策略实现进行交互了，尤其是需要提供一些公共功能或者是存储一些状态的时候，会大大增加客户端使用的难度；引入上下文之后，这部分工作可以由上下文来完成，客户端只需要和上下文进行交互就可以了。这样可以让策略模式更具有整体性，客户端也更加的简单</li></ul><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><ul><li>前言：代理(Proxy)模式是一种结构型设计模式，提供了对目标对象另外的访问方式；即通过代理对象访问目标对象。<br><img src="/img/Java%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image.png" alt="alt text"></li></ul><p>代理模式大致有三种角色：</p><ul><li>Real Subject：真实类，也就是被代理类、委托类。用来真正完成业务服务功能；</li><li>Proxy：代理类，将自身的请求用 Real Subject 对应的功能来实现，代理类对象并不真正的去实现其业务功能；</li><li>Subject：定义 RealSubject 和 Proxy 角色都应该实现的接口。</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理需要先定义接口，被代理对象与代理对象一起实现相同的接口，然后通过调用相同的方法来调用目标对象的方法。<br><img src="/img/Java%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-1.png" alt="alt text"></p><ul><li>优点：静态代理模式在不改变目标对象的前提下，实现了对目标对象的功能扩展。</li><li>缺点：静态代理实现了目标对象的所有方法，一旦目标接口增加方法，代理对象和目标对象都要进行相应的修改，增加维护成本。</li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="JDK代理"><a href="#JDK代理" class="headerlink" title="JDK代理"></a>JDK代理</h3><p><img src="/img/Java%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-2.png" alt="alt text"></p><ul><li><p>原理：JDK动态代理对象不需要实现接口，但是目标对象必须实现接口。代理对象会实现与目标类一样的方法，并将方法调用转发给目标对象</p></li><li><p>样例：有一天公司增加了业务，出售的商品越来越多，售后也需要更上。但是公司发现原来的代理商，还要再培训才能完成全部的业务，于是就找了另外的动态代理商B 。 代理商B 承诺无缝对接公司所有的业务，不管新增什么业务，均不需要额外的培训即可完成</p></li></ul><ol><li><p>公司增加了维修业务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口添加方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TVCompany</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产电视机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 电视机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">produceTV</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 维修电视机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tv 电视机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 电视机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">repair</span><span class="params">(TV tv)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>工厂也得把维修业务搞起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TVFactory</span> <span class="keyword">implements</span> <span class="title class_">TVCompany</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">produceTV</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TV factory produce TV...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TV</span>(<span class="string">&quot;小米电视机&quot;</span>,<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">repair</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tv is repair finished...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TV</span>(<span class="string">&quot;小米电视机&quot;</span>,<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>B代理商 全面代理公司所有的业务。使用Proxy.newProxyInstance方法生成代理对象，实现InvocationHandler中的 invoke方法，在invoke方法中通过反射调用代理类的方法，并提供增强方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TVProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TVProxyFactory</span><span class="params">(Object o)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target = o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        ClassLoader loader：指定当前目标对象使用类加载器，获取加载器的方法是固定的。</span></span><br><span class="line"><span class="comment">        Class&lt;?&gt;[] interfaces：目标对象实现的接口的类型，使用泛型方式确认类型。</span></span><br><span class="line"><span class="comment">        InvocationHandler h：事件处理，执行目标对象的方法时，会触发事件处理器的方法，会把当前执行目标对象的方法作为参数传入。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(), target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;TV proxy find factory for tv.... &quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                <span class="keyword">return</span> invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TVConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TVCompany</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TVFactory</span>();</span><br><span class="line">        <span class="type">TVCompany</span> <span class="variable">tvCompany</span> <span class="operator">=</span> (TVCompany) <span class="keyword">new</span> <span class="title class_">TVProxyFactory</span>(target).getProxy();</span><br><span class="line">        <span class="type">TV</span> <span class="variable">tv</span> <span class="operator">=</span> tvCompany.produceTV();</span><br><span class="line">        tvCompany.repair(tv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>缺点：JDK 动态代理有一个最致命的问题是它只能代理实现了某个接口的实现类（因为java是单继承，生成的新的代理类继承Proxy），并且代理类也只能代理接口中实现的方法，要是实现类中有自己私有的方法，而接口中没有的话，该方法不能进行代理调用</p><p>事务失效场景：内部调用，当类内部的方法调用另一个带有 @Transactional 注解的方法时，这个调用不会通过 Spring 的代理对象进行，而是直接通过 this 引用，因此 Spring 无法拦截并应用事务。Spring AOP 代理机制只能拦截通过代理对象进行的方法调用，而不能拦截类内部的直接方法调用</p><p>解决：</p><p>其中一种解决方法是在类内部通过 Spring 容器获取当前对象的代理实例，然后通过代理对象调用目标方法，从而让事务生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 从 Spring 容器中获取代理对象</span></span><br><span class="line">        <span class="type">TransactionService</span> <span class="variable">proxy</span> <span class="operator">=</span> context.getBean(TransactionService.class);</span><br><span class="line">        proxy.internalMethod(); <span class="comment">// 通过代理对象调用方法，事务生效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">internalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 事务在这里生效</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>Cglib代理可以称为子类代理，是在内存中构建一个子类对象，从而实现对目标对象功能的扩展。它不要求目标类实现接口中的方法，而是基于字节码生成技术，生成目标类的子类作为代理类，并重写父类的方法和增强逻辑</p><p><img src="/img/Java%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-3.png" alt="alt text"></p><p>Cglib通过Enhancer 来生成代理类，通过实现MethodInterceptor接口，并实现其中的intercept方法，在此方法中可以添加增强方法，并可以利用反射Method或者MethodProxy继承类 来调用原方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TVProxyCglib</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给目标对象创建一个代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Class c)</span>&#123;</span><br><span class="line">        <span class="comment">//1.工具类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//2.设置父类</span></span><br><span class="line">        enhancer.setSuperclass(c);</span><br><span class="line">        <span class="comment">//3.设置回调函数，调用方法的时候先调用intercept（拦截器）方法，执行我们定义的方法的增强链（也就是设置）</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//4.创建子类（代理对象）</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TVProxyFactory enhancement.....&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新代理的B工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TVFactoryB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">produceTVB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tv factory B producing tv.... &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TV</span>(<span class="string">&quot;华为电视机&quot;</span>, <span class="string">&quot;南京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">repairB</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tv B is repair finished.... &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C代理可以直接和公司合作，也可以和工厂打交道。并且可以代理任何工厂的产品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TVConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TVCompany</span> <span class="variable">tvCompany</span> <span class="operator">=</span> (TVCompany) <span class="keyword">new</span> <span class="title class_">TVProxyCglib</span>().getProxyInstance(TVFactory.class);</span><br><span class="line">        <span class="type">TV</span> <span class="variable">tv</span> <span class="operator">=</span> tvCompany.produceTV();</span><br><span class="line">        tvCompany.repair(tv);</span><br><span class="line">        System.out.println(<span class="string">&quot;==============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">TVFactoryB</span> <span class="variable">tvFactoryB</span> <span class="operator">=</span> (TVFactoryB) <span class="keyword">new</span> <span class="title class_">TVProxyCglib</span>().getProxyInstance(TVFactoryB.class);</span><br><span class="line">        <span class="type">TV</span> <span class="variable">tv</span> <span class="operator">=</span> tvFactoryB.produceTVB();</span><br><span class="line">        tvFactoryB.repairB(tv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TVProxyFactory enhancement.....</span><br><span class="line">TV factory produce TV...</span><br><span class="line">TVProxyFactory enhancement.....</span><br><span class="line">tv is repair finished...</span><br><span class="line">==============================</span><br><span class="line">TVProxyFactory enhancement.....</span><br><span class="line">tv factory B producing tv.... </span><br><span class="line">TVProxyFactory enhancement.....</span><br><span class="line">tv B is repair finished.... </span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="Spring-AOP使用代理"><a href="#Spring-AOP使用代理" class="headerlink" title="Spring AOP使用代理"></a>Spring AOP使用代理</h2><p>Spring中AOP的实现有JDK和Cglib两种，如下图：</p><p><img src="/img/Java%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-4.png" alt="alt text"></p><ul><li>如果目标对象需要实现接口，则使用JDK代理</li><li>如果目标对象不需要实现接口，则使用Cglib代理</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>静态代理：需要代理类和目标类都实现接口的方法，从而达到代理增强其功能</li><li>JDK动态代理：需要代理类实现某个接口，使用Proxy.newProxyInstance方法生成代理类，并实现InvocationHandler中的invoke方法，实现增强功能</li><li>Cglib动态代理：无需代理类实现接口，使用Cblib中的Enhancer来生成代理对象子类，并实现MethodInterceptor中的intercept方法，在此方法中可以实现增强功能</li></ul><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p>核心思想是：父类定义骨架，子类实现某些细节</p><p>为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用final。对于需要子类实现的抽象方法，一般声明为protected，使得这些方法对外部客户端不可见</p><ol><li><p>父类定义骨架</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSetting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getSetting</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">//从缓存读取</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> lookupCache(key);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在缓存中未找到,从数据库读取</span></span><br><span class="line">            value = readFromDatabase(key);</span><br><span class="line">            <span class="comment">// 放入缓存</span></span><br><span class="line">            putIntoCache(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title function_">lookupCache</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">putIntoCache</span><span class="params">(String key, String value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>子类实现某些细节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisSetting</span> <span class="keyword">extends</span> <span class="title class_">AbstractSetting</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RedisClient</span> <span class="variable">client</span> <span class="operator">=</span> RedisClient.create(<span class="string">&quot;redis://localhost:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">lookupCache</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;</span><br><span class="line">            RedisCommands&lt;String, String&gt; commands = connection.sync();</span><br><span class="line">            <span class="keyword">return</span> commands.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">putIntoCache</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;</span><br><span class="line">            RedisCommands&lt;String, String&gt; commands = connection.sync();</span><br><span class="line">            commands.set(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AbstractSetting</span> <span class="variable">setting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisSetting</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;autosave = &quot;</span> + setting.getSetting(<span class="string">&quot;autosave&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;autosave = &quot;</span> + setting.getSetting(<span class="string">&quot;autosave&quot;</span>));</span><br></pre></td></tr></table></figure></li></ol><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h2><p>观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式</p><ul><li>优点：</li></ul><ol><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则</li><li>目标与观察者之间建立了一套触发机制</li></ol><ul><li>缺点：</li></ul><ol><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用</li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率</li></ol><ul><li>观察者模式的结构：</li></ul><ol><li>抽象主题（subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的方法</li><li>具体主题（Concrete subject）角色：也叫具体目标类，实现了抽象目标类的方法，当具体主题的内部状态发生变化的时候，通知所有注册过的观察者对象</li><li>抽象观察者（Observer）角色：它是一个抽象类或者接口，它包含了一个更新自己的抽象方法，当接受到具体主题的更改通知时被调用</li><li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态</li></ol><p>示例：</p><p>Observer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">//更新的方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String messages)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WexinUser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体观察者类 实现更新的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WexinUser</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WexinUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WexinUser</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String messages)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;--&gt;&quot;</span> + messages);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Subject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象主题类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//增加订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知订阅者更新消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String messages)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SubscriptionSubject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体主题(具体被观察者)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//存储订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; weixinUserList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserList.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserList.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SubscriptionSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubscriptionSubject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建微信用户</span></span><br><span class="line">        <span class="type">WexinUser</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WexinUser</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">WexinUser</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WexinUser</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="type">WexinUser</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WexinUser</span>(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//订阅公众号</span></span><br><span class="line">        subject.attach(user1);</span><br><span class="line">        subject.attach(user2);</span><br><span class="line">        subject.attach(user3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过订阅用户</span></span><br><span class="line">        subject.notify(<span class="string">&quot;您关注的公众号更新啦~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK源码解析"><a href="#JDK源码解析" class="headerlink" title="JDK源码解析"></a>JDK源码解析</h2><p>在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例</p><ol><li>Observable类（抽象被观察者）<br>Observable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的3个方法</li></ol><ul><li>void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中</li><li>void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知</li><li>void setChange() 方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者</li></ul><ol start="2"><li>Observer 接口（抽象观察者）<br>Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作</li></ol><p>示例：</p><p>警擦（观察者）抓小偷（被观察者），当小偷偷东西的时警擦会被通知</p><p>Thief(被观察者)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小偷类 继承Observable接口</span></span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thief</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thief</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thief</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">steal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;emmm我正在悄悄偷东西&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.setChanged();<span class="comment">//默认为true</span></span><br><span class="line">        <span class="built_in">super</span>.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Policemen(观察者)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Policeman</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Policeman</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Policeman</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;警察：&quot;</span> + ((Thief) o).getName() + <span class="string">&quot;我抓住你了！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//小偷（被观察者）</span></span><br><span class="line">        <span class="type">Thief</span> <span class="variable">thief</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thief</span>(<span class="string">&quot;法外狂徒格雷福斯&quot;</span>);</span><br><span class="line">        <span class="comment">//警察（观察者）</span></span><br><span class="line">        <span class="type">Policeman</span> <span class="variable">policeman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Policeman</span>(<span class="string">&quot;凯瑟琳女警&quot;</span>);</span><br><span class="line">        <span class="comment">//警察观察小偷</span></span><br><span class="line">        thief.addObserver(policeman);</span><br><span class="line">        <span class="comment">//小偷行窃</span></span><br><span class="line">        thief.steal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  打印结果：</span></span><br><span class="line"><span class="comment">    emmm我正在悄悄偷东西</span></span><br><span class="line"><span class="comment">    警察：法外狂徒格雷福斯我抓住你了！！！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashTable和HashMap的区别</title>
      <link href="/posts/HashTable%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
      <url>/posts/HashTable%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      
        <content type="html"><![CDATA[<p>1、HashMap是线程不安全的，HashTable是线程安全的</p><ul><li><p>HashMap：Fail-fast 机制。表示快速失败，在集合遍历过程中，一旦发现容器中的数据被修改了，会立刻抛出ConcurrentModificationException异常，从而导致遍历失败，像这种情况：定义一个Map集合，使用Iterator迭代器进行数据遍历，在遍历过程中，对集合数据做变更时，就会发生Fail-fast。java.util包下的集合类都是快速失败机制的, 常见的的使用Fail-fast方式遍历的容器有HashMap和ArrayList等。</p></li><li><p>HashTable：公开的方法比如get都使用了synchronized描述符。而遍历视图比如keySet都使用了Collections.synchronizedXXX进行了同步包装。并且是锁住全局的</p></li><li><p>Fail-fast底层实现：迭代器在遍历集合的过程，会维护一个modCount变量。如果在遍历过程modCount发生变化，在迭代器使用hasNext&#x2F;next遍历下一个元素的时候，都会检测modCount是否为expectedModCount的值，如果不是抛出异常。</p></li></ul><p>2、 由于线程安全，HashTable效率比不上HashMap</p><p>3、HashMap允许键为NULL，值为NULL。HashTable都不允许</p><ul><li>HashMap是支持null键和null值的，而HashTable在遇到null时，会抛出NullPointerException异常。这并不是因为HashTable有什么特殊的实现层面的原因导致不能支持null键和null值，这仅仅是因为HashMap在实现时对null做了特殊处理，将null的hashCode值定为了0，从而将其存放在哈希表的第0个bucket中。</li></ul><p>4、HashMap默认初始化数组大小是16，HashTable是11。HashMap扩容是扩大两倍，HashTable是两倍+1</p><p>5、HashMap不能直接使用hashCode计算下标，而是使用hashCode重新计算Hash值，再计算下标。HashTable使用的是hashCode计算下标（取mod）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/Hello%20World.html"/>
      <url>/posts/Hello%20World.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
