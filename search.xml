<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DHCP简要概述</title>
      <link href="/posts/DHCP%E7%AE%80%E8%A6%81%E6%A6%82%E8%BF%B0.html"/>
      <url>/posts/DHCP%E7%AE%80%E8%A6%81%E6%A6%82%E8%BF%B0.html</url>
      
        <content type="html"><![CDATA[<h1 id="DHCP基本概念"><a href="#DHCP基本概念" class="headerlink" title="DHCP基本概念"></a>DHCP基本概念</h1><p>DHCP：动态主机配置协议，自动配置网络参数</p><ul><li>配置信息一般包括IP地址、子网掩码、默认路由器的IP地址和本地域名服务器的IP地址</li><li>DHCP服务器分配给DHCP客户的IP地址等网络参数是临时的，只能在一段有限的时间内使用，这段时间称为租用期</li><li>DHCP客户使用UDP的68号端口，DHCP服务器使用UDP的67号端口</li><li>DHCP客户端启动的时候，需要利用广播报文寻找DHCP服务器，该广播报文属于本地网络广播，不能被路由转发</li><li>因此，要求每一个网络上都有一台DHCP服务器</li></ul><h1 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h1><p>为了避免DHCP服务器过多，DHCP利用DHCP中继代理解决该问题</p><ol><li>DHCP中继代理配置了DHCP服务器的IP地址</li><li>DHCP中继代理收到DHCP客户以广播形式发送的发现报文后，就以单播形式向DHCP服务器转发此报文，并等待其应答</li><li>收到DHCP服务器的应答报文后，DHCP中继代理再把此应答报文发回给DHCP客户端</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议</title>
      <link href="/posts/HTTP%E5%8D%8F%E8%AE%AE.html"/>
      <url>/posts/HTTP%E5%8D%8F%E8%AE%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h1><ul><li>HTTP有两类报文：请求报文和响应报文</li><li>HTTP是面向文本的，在报文中的每一个字段都是一些ASCII串</li><li>HTTP请求报文和响应报文都是由三部分组成：<ol><li>开始行：在请求报文中叫请求行，在响应报文中叫状态行</li><li>首部行：用来说明浏览器、服务器或者报文主体的一些信息</li><li>实体主体：在请求报文中叫<strong>请求主体</strong>，在响应报文中叫<strong>响应主体</strong></li></ol></li></ul><h1 id="HTTP请求报文中的方法"><a href="#HTTP请求报文中的方法" class="headerlink" title="HTTP请求报文中的方法"></a>HTTP请求报文中的方法</h1><p><img src="/img/HTTP%E5%8D%8F%E8%AE%AE/img1.png" alt="img"></p><p>POST方法和PUT方法类似，区别在于POST是新增，PUT是更新，开发中用的比较多的是POST和GET</p><h1 id="HTTP响应报文中的状态码"><a href="#HTTP响应报文中的状态码" class="headerlink" title="HTTP响应报文中的状态码"></a>HTTP响应报文中的状态码</h1><p><img src="/img/HTTP%E5%8D%8F%E8%AE%AE/img2.png" alt="img"></p><h1 id="什么时候会出现502错误码"><a href="#什么时候会出现502错误码" class="headerlink" title="什么时候会出现502错误码"></a>什么时候会出现502错误码</h1><p>502错误码是服务器在充当网关或者代理时，应用服务器发生<strong>故障</strong>，nginx无法从应用服务器那收到响应，就会返回502给客户端</p><h1 id="什么时候会发现504错误码"><a href="#什么时候会发现504错误码" class="headerlink" title="什么时候会发现504错误码"></a>什么时候会发现504错误码</h1><p>504错误码是服务器在充当网关或者代理时，应用服务器接口<strong>超时</strong>，nginx无法从应用服务器那收到响应，就会返回504给客户端</p><h1 id="永久重定向和临时重定向区别"><a href="#永久重定向和临时重定向区别" class="headerlink" title="永久重定向和临时重定向区别"></a>永久重定向和临时重定向区别</h1><p>永久重定向：会记忆重定向后的URL，下次访问直接访问新的URL<br>临时重定向区：不会记忆重定向后的URL，下次访问仍要先访问旧的URL，再访问新的</p><h1 id="代理服务器和内容分发网络"><a href="#代理服务器和内容分发网络" class="headerlink" title="代理服务器和内容分发网络"></a>代理服务器和内容分发网络</h1><h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>代理服务器也叫万维网缓存。代理服务器可以将最近请求过的资源的副本缓存在自己的存储空间</p><p>工作流程：</p><ol><li>浏览器先与代理服务器建立TCP连接，向代理服务器发送HTTP请求</li><li>代理服务器收到HTTP请求后，检查本地缓存，如果有指定资源的副本就直接返回</li><li>否则向源服务器发送HTTP请求</li><li>源服务器向代理服务器返回指定的资源</li><li>代理服务器收到该资源后，自己存储一份副本，然后返回给客户端</li></ol><h2 id="什么是正向代理，什么是反向代理"><a href="#什么是正向代理，什么是反向代理" class="headerlink" title="什么是正向代理，什么是反向代理"></a>什么是正向代理，什么是反向代理</h2><ul><li>正向代理是代理客户端，可以用来屏蔽客户端IP地址和避免网络浏览限制，以及阻止访问某些内容和缓存响应结果提高访问速度</li><li>反向代理是代理服务端，可以用来保护服务器，隐藏真实IP。以及负载均衡</li></ul><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><ol><li>内容缓存和分发：<br>CDN在全球多个节点上缓存静态内容（如图像、CSS、JavaScript 文件），将内容分发到离用户最近的节点，以减少延迟并加快加载速度。</li><li>负载分担：<br>通过将请求分发到多个缓存节点，CDN 可以减少源服务器的负载，从而提高整体系统的性能和可用性。</li><li>流量管理：<br>CDN可以处理大量的并发请求，尤其在高流量情况下，帮助减轻原始服务器的压力。</li></ol><p>CDN不依赖用户在浏览器中配置代理服务器，而是依赖DNS将不同的HTTP请求定向到不同的代理服务器上</p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡（Server Load Balancer）是将访问流量根据转发策略分发到后端多台云服务器（ECS实例）的流量分发控制服务。负载均衡扩展了应用的服务能力，增强了应用的可用性</p><p>负载均衡算法：</p><ul><li>普通轮询：请求依次分配给服务器</li><li>加权轮询：根据权重比分配给服务器</li><li>IP哈希：根据客户端IP地址的哈希值来确认分配的服务器</li><li>URL哈希：根据请求的URL的哈希值来确认分配的服务器</li><li>最短响应时间：按照后端服务器的响应时间来分配，响应时间短的优先分配</li><li>最短连接：新请求会发送到并发连接最少的服务节点</li></ul><h1 id="HTTP的发展"><a href="#HTTP的发展" class="headerlink" title="HTTP的发展"></a>HTTP的发展</h1><h2 id="HTTP-1-x"><a href="#HTTP-1-x" class="headerlink" title="HTTP&#x2F;1.x"></a>HTTP&#x2F;1.x</h2><p>HTTP&#x2F;1.0和HTTP1.1的主要区别：</p><ul><li>长连接：HTTP1.1默认的行为是长连接。HTTP1.0也支持长连接，但是默认是短链接</li><li>请求管道化：HTTP1.1支持请求管道化，在一个持久连接上可以同时发送多个请求。而HTTP1.0不支持，请求和响应必须是串行的。<strong>但是HTTP1.1仍然要求服务器按顺序返回响应报文</strong></li><li>host字段：HTTP1.0没有host字段。HTTP1.1有，可以一个物理服务器承载多个域名或者站点</li></ul><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h2><p>HTTP&#x2F;1.x存在的问题：</p><ul><li>线头阻塞问题：服务器需要按序处理请求和返回响应报文，需要缓存多个请求，占用更多资源</li><li>TCP并发连接数限制：利用多个TCP连接，并发访问服务器会消耗大量服务器资源</li><li>没有报文首部压缩方案：HTTP报文首部很多，但每次请求首部的变化通常不大</li><li>明文传输不安全：HTTP依赖传输层TLS协议才能实现加密传输</li></ul><p>HTTP1.1和HTTP2.0的主要区别：</p><ul><li>基于流的多路复用：HTTP&#x2F;2引入了流的概念，每一对HTTP请求报文和响应报文被视为同一个流，在同一个TCP连接上实现了流的多路复用，不同流中的帧可以交错地发送给对方</li><li>二进制格式的帧和首部压缩：HTTP&#x2F;2将HTTP&#x2F;1的纯文本格式改成了二进制格式，提高了传输效率。并且用HPACK算法压缩了首部信息</li><li>服务器主动推送；比如客户端向服务器请求HTML文件时，会将相关的CSS文件也推送过来</li><li>增强安全性：主流浏览器公开宣布只支持加密的HTTP&#x2F;2，并且HTTP&#x2F;2对TLS的安全性做了进一步加强，比如HTTP&#x2F;2通过黑名单机制禁用了几百种不再安全的加密算法和对TLS进行了扩展，开发了应用层协商协议ALPN</li></ul><h2 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP&#x2F;3.0"></a>HTTP&#x2F;3.0</h2><p>HTTP2.0存在的问题：</p><ul><li>线头阻塞问题没有完全解决：会有TCP队头阻塞的问题，tcp是基于字节流的，必须要解决粘包问题，因此如果有一个steam丢包必须要重传，直到全部的steam收到</li><li>TCP建立连接的延迟问题：HTTP基于TCP实现，因此要先进行三次握手，有较大延迟</li><li>网络迁移需要重新连接：一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WiFi</li></ul><p>HTTP&#x2F;3：HTTP&#x2F;3就将传输层从TCP替换成了 UDP，并且UDP协议在应用层上实现了QUIC协议，来保证数据的可靠传输</p><p>QUIC协议的特点：</p><ul><li>无队头阻塞：QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响</li><li>建立连接快：因为 QUIC 内部包含 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与 TLS 密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果</li><li>连接迁移：，QUIC 协议没有用四元组的方式来“绑定”连接，而是通过「连接 ID 」来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML文档的概述</title>
      <link href="/posts/HTML%E6%96%87%E6%A1%A3%E7%9A%84%E6%A6%82%E8%BF%B0.html"/>
      <url>/posts/HTML%E6%96%87%E6%A1%A3%E7%9A%84%E6%A6%82%E8%BF%B0.html</url>
      
        <content type="html"><![CDATA[<p>超文本标记语言HTML是制作万维网页面的标准语言，目前版本HTML5.0</p><p>HTML使用标记标签来描述网页文档，HTML标签是由尖括号包围的关键词，通常是成对出现的，例如<body>和</body>，其中第一个是开始标签，第二个是结束标签</p><p>HTML标签的组成如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tag-name</span> [[<span class="attr">attribute-name</span>[= <span class="string">arrribute-value]]...]</span>&gt;</span>(文本内容)<span class="tag">&lt;/<span class="name">tag-name</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从开始标签道结束标签的所有代码称为<strong>HTML元素</strong></p><p>完整的HTML文档如下：</p><p><img src="/img/HTML%E6%96%87%E6%A1%A3%E7%9A%84%E6%A6%82%E8%BF%B0/img1.png" alt="alt text"></p><p>为了控制文档的呈现方式，通常会使用<strong>层叠样式表(CSS)</strong></p><p>CSS (Cascading Style Sheets，层叠样式表），是一种用来为结构化文档（如 HTML 文档或 XML 应用）添加样式（字体、间距和颜色等）的计算机语言，CSS 文件扩展名为 .css</p><p>HTML文档分为静态文档、动态文档、活动文档三种：</p><ul><li>静态HTML文档：不会根据浏览器发来的数据而改变</li><li>动态HTML文档：在浏览器访问服务器的时候才创建，当浏览器的请求到达的时候，服务器将URL映射到一个应用程序，由应用程序根据请求中的数据创建一个HTML文档</li><li>活动HTML文档：把创建HTML的任务交给浏览器执行。服务器返回给浏览器的文档中包含脚本程序，浏览器执行脚本后，得到活动HTML文档</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统一资源定位符URL</title>
      <link href="/posts/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6URL.html"/>
      <url>/posts/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6URL.html</url>
      
        <content type="html"><![CDATA[<p>URI 本质上是一个字符串，这个字符串的作用是唯一地标记资源的位置或者名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.chrono.com:8080/11-1?uid=1234&amp;name=mario&amp;referer=xxx</span><br></pre></td></tr></table></figure><p>scheme + :&#x2F;&#x2F; + host:port + path + [?query] + [#fragment]</p><p>path: &#x2F; + [目录名] + &#x2F; + … + 文件名 ,path中第一个&#x2F;是web服务器配置文件中的根，不是操作系统的根</p><ul><li>第一个多出的部分是协议名之后、主机名之前的身份信息“user:passwd@”，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230），因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患</li><li>第二个多出的部分是查询参数后的片段标识符“#fragment”,它是 URI 所定位的资源内部的一个“锚点”或者说是“标签”，浏览器可以在获取资源后直接跳转到它指示的位置。但片段标识符仅能由浏览器这样的客户端使用，服务器是看不到的。也就是说，浏览器永远不会把带“#fragment”的 URI 发送给服务器，服务器也永远不会用这种方式去处理资源的片段</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络传输场景问题</title>
      <link href="/posts/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98.html"/>
      <url>/posts/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何浏览器没有显示页面有哪些原因"><a href="#如何浏览器没有显示页面有哪些原因" class="headerlink" title="如何浏览器没有显示页面有哪些原因"></a>如何浏览器没有显示页面有哪些原因</h1><ol><li>先确实是服务端的问题还是客户端的问题。如果客户端可以访问其他网站，如果可以说明客户端网络没问题</li><li>如果客户端网络没问题，就抓包确认DNS是否解析出了IP地址，如果没有解析出来说明域名写错了</li><li>如果IP解析出来了，再抓包确认TCP是否完成了3次握手，需要在server端通过ps确认server进程是否启动，以及通过netstate命令确认是否监听了端口</li><li>如果TCP完成了3次握手查看返回的状态码<ul><li>404：检查输入的url是否正确</li><li>500：服务器有问题，需要去服务器排查日志</li><li>200：可以在浏览器按F12输出前端控制台，看看前端代码是不是有问题</li></ul></li><li>如果网络没问题，可以通过ping去确认网络延迟是否正常，如果耗时很长，可以排查服务器流量是不是很大，导致超过了带宽上限。如果网络正常可以排查接口是否正常，有可能是慢SQL导致的</li></ol><h1 id="服务器ping不通但是http可以请求成功，会出现吗？"><a href="#服务器ping不通但是http可以请求成功，会出现吗？" class="headerlink" title="服务器ping不通但是http可以请求成功，会出现吗？"></a>服务器ping不通但是http可以请求成功，会出现吗？</h1><p>会的。因为ping是ICMP协议，http是TCP协议，有可能服务器的防火墙禁止ICMP协议，但是TCP协议没有被禁止</p><h1 id="客户端TCP连接一个不存在的IP地址会发生什么"><a href="#客户端TCP连接一个不存在的IP地址会发生什么" class="headerlink" title="客户端TCP连接一个不存在的IP地址会发生什么"></a>客户端TCP连接一个不存在的IP地址会发生什么</h1><ul><li>如果访问的IP地址在局域网内，客户端的内核在发ARP请求的时候，广播会询问这个IP是否存在，由于不存在所以收不到ARP回应，这时候就会卡在ARP协议，SYN报文发不出去</li><li>如果访问的IP地址不在局域网内，客户端会先将SYN报文发送到路由器，然后路由器会继续转发，由于IP不存在，该SYN报文会消亡。接着客户端会发生超时重传，到达最大重传次数后客户端连接会释放</li></ul><h1 id="客户端TCP连接一个存在的IP地址但是端口不存在会发生什么"><a href="#客户端TCP连接一个存在的IP地址但是端口不存在会发生什么" class="headerlink" title="客户端TCP连接一个存在的IP地址但是端口不存在会发生什么"></a>客户端TCP连接一个存在的IP地址但是端口不存在会发生什么</h1><p>服务端在收到SYN报文后，会返回一个RST报文，客户端收到RST报文后会断开连接</p><h1 id="客户端UDP连接一个存在的IP地址但是端口不存在会发生什么"><a href="#客户端UDP连接一个存在的IP地址但是端口不存在会发生什么" class="headerlink" title="客户端UDP连接一个存在的IP地址但是端口不存在会发生什么"></a>客户端UDP连接一个存在的IP地址但是端口不存在会发生什么</h1><p>UDP没有RST报文，因此服务端会返回ICMP报文，报告端口不可达</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>键入网址场景问题</title>
      <link href="/posts/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98.html"/>
      <url>/posts/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<h1 id="输入网址后，期间发生了什么"><a href="#输入网址后，期间发生了什么" class="headerlink" title="输入网址后，期间发生了什么"></a>输入网址后，期间发生了什么</h1><ol><li>浏览器会先解析URL，解析出域名、资源路径、端口等信息，然后构造HTTP请求报文</li><li>域名解析，将域名解析成IP地址。会先查系统缓存是否有域名信息，如果有返回IP地址。如果没有再去查看本地系统hosts文件有没有域名信息，如果有就返回。如果没有再去本地DNS服务器查看。如果仍然没有就分别去根域名服务器-&gt;顶级域名服务器-&gt;权威域名服务器询问，最后返回IP</li><li>进行TCP三次握手建立连接，第一次握手会填上SYN标记位，同时填上源端口和目标端口</li><li>到网络层会加上IP头，填上目标IP地址和源IP地址</li><li>到数据链路层通过ARP协议获取到路由器的MAC地址，然后加上MAC头，填上目标MAC地址和源MAC地址</li><li>到物理层直接把数据包发送给路由器，路由器再通过下一条找到目标服务器，然后目标服务器收到SYN报文后，响应第二次握手</li><li>当双方都完成三次握手后，如果是http协议客户端就会将http请求发送给服务端；如果是https还需要ssl四次握手</li><li>目标服务器收到http请求后，就返回http响应消息，浏览器会对消息进行解析渲染，呈现给用户</li></ol><h1 id="DNS是如何解析的，是属于哪一层的协议"><a href="#DNS是如何解析的，是属于哪一层的协议" class="headerlink" title="DNS是如何解析的，是属于哪一层的协议"></a>DNS是如何解析的，是属于哪一层的协议</h1><p>DNS是属于应用层的协议</p><p><img src="/img/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%9C%BA%E6%99%AF%E9%97%AE%E9%A2%98/img1.png" alt="alt text"></p><p>会先查系统缓存是否有域名信息，如果有返回IP地址。如果没有再去查看本地系统hosts文件有没有域名信息，如果有就返回。如果没有再去本地DNS服务器查看。如果仍然没有就分别去根域名服务器-&gt;顶级域名服务器-&gt;权威域名服务器询问，最后返回IP保存到本地DNS服务器，然后本地DNS服务器将IP保存到本地缓存，并将查询结果返回给客户端</p><h1 id="DNS解析用到了什么协议"><a href="#DNS解析用到了什么协议" class="headerlink" title="DNS解析用到了什么协议"></a>DNS解析用到了什么协议</h1><p>UDP协议，因为UDP协议传输快，如果要保证可靠可以在应用层实现一个超时重传机制</p><h1 id="输入域名如何知道端口"><a href="#输入域名如何知道端口" class="headerlink" title="输入域名如何知道端口"></a>输入域名如何知道端口</h1><p>http的默认端口是80，https的默认端口是443，或者指定端口（比如:8080）</p><h1 id="客户端向服务端的IP地址发送数据，服务端如何确定把消息传给哪个应用"><a href="#客户端向服务端的IP地址发送数据，服务端如何确定把消息传给哪个应用" class="headerlink" title="客户端向服务端的IP地址发送数据，服务端如何确定把消息传给哪个应用"></a>客户端向服务端的IP地址发送数据，服务端如何确定把消息传给哪个应用</h1><p>每个传输层（如TCP和UDP）都使用不同的端口号来区分应用程序，服务端通过监听特殊的端口号来接受来自客户端的数据</p><h1 id="现在很多网站都要求使用https，我们输入一个http网站，网站是如何实现由http调到https的"><a href="#现在很多网站都要求使用https，我们输入一个http网站，网站是如何实现由http调到https的" class="headerlink" title="现在很多网站都要求使用https，我们输入一个http网站，网站是如何实现由http调到https的"></a>现在很多网站都要求使用https，我们输入一个http网站，网站是如何实现由http调到https的</h1><p>涉及服务器的配置，以下是nginx服务器端的配置方法来实现重定向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80</span><br><span class="line">    server_name example.com</span><br><span class="line">    return 301 https:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>服务器网关收到http请求后，会返回给客户端一个响应，状态码为301（永久重定向）</li><li>浏览器收到重定向响应后，自动向服务器发送一个https请求</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络分层模型</title>
      <link href="/posts/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B.html"/>
      <url>/posts/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h1><ul><li>应用层：与软件应用程序直接通信，如HTTP、HTTPS协议</li><li>表示层：提供各种应用层的编码和转换功能，如数据转换、压缩、加密等。</li><li>会话层：控制计算机之间建立会话连接</li><li>传输层：端到端通信，如TCP、UDP协议</li><li>网络层：逻辑寻址和交换功能处理数据包路由，比如IP、ICMP、ARP协议</li><li>数据链路层：节点到节点的传输，通过MAC地址标识网络上的设备</li><li>物理层：定义了数据连接的物理规格，比如光纤电缆等</li></ul><h1 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP&#x2F;IP网络模型"></a>TCP&#x2F;IP网络模型</h1><ul><li>应用层：与软件应用程序直接通信，如HTTP、HTTPS协议</li><li>传输层：端到端通信，如TCP、UDP协议</li><li>网络层：负载主机寻找、打包和路由功能，比如IP、ICMP、ARP协议。IP负责寻址和路由，ARP负责获取MAC地址，ICMP负责提供诊断功能并报告错误</li><li>网络接口层：为网络层提供链路级别传输的服务，负责在以太网、WiFi这样的底层网络上传输原始数据包，工作在网卡这个层次，通过MAC地址来标识网络上的设备</li></ul><h1 id="TCP和IP分别在哪一层"><a href="#TCP和IP分别在哪一层" class="headerlink" title="TCP和IP分别在哪一层"></a>TCP和IP分别在哪一层</h1><p>TCP协议在传输层，IP协议在网络层</p><h1 id="网络为什么要分层"><a href="#网络为什么要分层" class="headerlink" title="网络为什么要分层"></a>网络为什么要分层</h1><ul><li>为了降低耦合，上层不用关系下层的实现，只关心下层提供的接口服务，有利于排查网络问题，能更精细地定位到哪一层</li><li>不会产生关联性，不会因为某一层的改变影响到其他，比如http从1.1升级到2.0，不会对传输层和网络层有影响。以及IPv4协议升级到IPv6也不会对应用层和传输层有影响</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文字串——马拉车算法</title>
      <link href="/posts/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2%E2%80%94%E2%80%94%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95.html"/>
      <url>/posts/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2%E2%80%94%E2%80%94%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<p>Manacher算法是一个用来查找一个字符串中的最长回文子串(不是最长回文序列)的线性算法。它的优点就是把时间复杂度为O(n^2)的暴力算法优化到了O(n)</p><p><img src="/img/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2%E2%80%94%E2%80%94%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/img1.png" alt="alt text"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        str += <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">        str += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : s) &#123;</span><br><span class="line">            str += ch;</span><br><span class="line">            str += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= r) d[i] = <span class="built_in">min</span>(d[l + r - i], l - i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (str[i - d[i]] == str[i + d[i]]) d[i]++;</span><br><span class="line">            <span class="keyword">if</span> (i + d[i] - <span class="number">1</span> &gt; r) &#123;</span><br><span class="line">                l = i - d[i] + <span class="number">1</span>;</span><br><span class="line">                r = i + d[i] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        string ss = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &lt; d[i] - <span class="number">1</span>) &#123;</span><br><span class="line">                ans = d[i] - <span class="number">1</span>;</span><br><span class="line">                p = i - d[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = p; ans &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                ss += str[i];</span><br><span class="line">                ans--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ss;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie、session、token、jwt的区别</title>
      <link href="/posts/cookie%E3%80%81session%E3%80%81token%E3%80%81jwt%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
      <url>/posts/cookie%E3%80%81session%E3%80%81token%E3%80%81jwt%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      
        <content type="html"><![CDATA[<h1 id="误区纠正"><a href="#误区纠正" class="headerlink" title="误区纠正"></a>误区纠正</h1><ul><li>cookie是浏览器的存储机制，应该和localstorage、sessionStorage、indexedDB、webSQL这种对比</li><li>session是保存在服务器的一个一组数据（k-v结构），有些网站采取session来用户机制，通常会把sessionID存储在cookie中。此外，session是一个抽象概念，具体实现可以用Redis</li><li>token和jwt，他们是信息的编码的东西，是信息本身</li><li>cookie、session、token本质上是不同维度的东西，token也可以存储在cookie中，也可以存储在浏览器的localStorage中</li><li>cookie是存储在client 的，而session保存在server，sessionId需要借助cookie的传递才有意义</li></ul><p><img src="/img/cookie%E3%80%81session%E3%80%81token%E3%80%81jwt%E7%9A%84%E5%8C%BA%E5%88%AB/img1.png" alt="alt text"></p><h1 id="Cookie、Session、Token有什么区别？"><a href="#Cookie、Session、Token有什么区别？" class="headerlink" title="Cookie、Session、Token有什么区别？"></a>Cookie、Session、Token有什么区别？</h1><ul><li>存储位置不同：Cookie存储在客户端，Session存储在服务端、Token存储在客户端（通过加密方式存储在客户端的localStorage和sessionStorage）</li><li>数据安全性不同：Cookie存储在客户端，容易被窃取。Session存储在服务器，避免了敏感数据直接暴露，Token通常使用加密算法，单向不可逆，比较安全</li><li>跨域支持不同：Cookie不支持跨域，Session通常是用Cookie保存SessionID的，因此也不支持</li><li>Token支持跨域，因为Token保存在本地的localStorage或者作为请求头的一部分发送到服务端，可以支持跨域</li><li>状态管理不同：Cookie是应用程序通过客户端存储临时数据，用于实现状态管理的机制。session是服务器记录用户状态的方式，服务器会为每一个对话分配一个sessionID，关联用户状态。Token是一种用于认证和授权的一种机制，通常表示用户的身份信息和权限信息</li></ul><h1 id="为什么有了session还需要token"><a href="#为什么有了session还需要token" class="headerlink" title="为什么有了session还需要token"></a>为什么有了session还需要token</h1><p>cookie+session不支持横向扩展，如果请求被负载均衡转发到了别的机器上，没有用户登录信息，就会导致用户请求失败。虽然可以使用redis做分布式session，但是单点故障风险太高，一旦redis崩掉，用户就全部无法访问，而且为了身份验证使用Redis集群不划算<br>而jwt将用户信息加密为一个字符串传给前端，后端不保存状态，每次都从前端获取状态来实现登录校验</p><p>首先请求方输入自己的用户名，密码，然后 server 据此生成 token，客户端拿到 token 后会保存到本地，之后向 server 请求时在请求头带上此 token 即可</p><h1 id="token只存储在浏览器中，服务端却没有存储，这样的话我随便搞个token传给server也行？"><a href="#token只存储在浏览器中，服务端却没有存储，这样的话我随便搞个token传给server也行？" class="headerlink" title="token只存储在浏览器中，服务端却没有存储，这样的话我随便搞个token传给server也行？"></a>token只存储在浏览器中，服务端却没有存储，这样的话我随便搞个token传给server也行？</h1><p>server会有一套校验机制，校验这个token是否合法</p><h1 id="token怎么不像session那样根据-sessionId-找到-userid-呢，这样的话怎么知道是哪个用户？"><a href="#token怎么不像session那样根据-sessionId-找到-userid-呢，这样的话怎么知道是哪个用户？" class="headerlink" title="token怎么不像session那样根据 sessionId 找到 userid 呢，这样的话怎么知道是哪个用户？"></a>token怎么不像session那样根据 sessionId 找到 userid 呢，这样的话怎么知道是哪个用户？</h1><p>token本身携带uid信息</p><h1 id="如何校验token，或者说JWT如何工作的？"><a href="#如何校验token，或者说JWT如何工作的？" class="headerlink" title="如何校验token，或者说JWT如何工作的？"></a>如何校验token，或者说JWT如何工作的？</h1><p><img src="/img/cookie%E3%80%81session%E3%80%81token%E3%80%81jwt%E7%9A%84%E5%8C%BA%E5%88%AB/img1.png" alt="alt text"></p><p>jwt token有三部分组成：</p><ul><li>header：签名算法</li><li>payload：用户id、过期时间等非敏感信息</li><li>signature：签名，用来验证jwt是否合法</li></ul><p>验证流程：<br>当 server 收到浏览器传过来的 token 时，它会首先取出 token 中的 header+payload，根据服务端的密钥生成签名，然后再与 token 中的签名比对，如果成功则说明签名是合法的，即 token 是合法的</p><p>所以jwt就是令牌token，是一个String字符串</p><h1 id="基于Redis实现共享session登录？"><a href="#基于Redis实现共享session登录？" class="headerlink" title="基于Redis实现共享session登录？"></a>基于Redis实现共享session登录？</h1><p><img src="/img/cookie%E3%80%81session%E3%80%81token%E3%80%81jwt%E7%9A%84%E5%8C%BA%E5%88%AB/img2.png" alt="alt text"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP流量控制和拥塞控制的区别</title>
      <link href="/posts/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
      <url>/posts/TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      
        <content type="html"><![CDATA[<p>流量控制：端到端的控制，目的是放在发送方发送的数据过快，导致接收方处理不过来，通过滑动窗口实现。接收方在ACK报文中告诉自己的接受窗口的大小，这样就告诉了发送方可接受的最大数据量</p><p>拥塞控制：网络层面的控制，目的是放在过多的数据包同时在网络中传输，导致网络拥塞。主要通过慢启动、拥塞避免算法、超时重传、快速重传、快速恢复算法实现</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP和UDP的区别</title>
      <link href="/posts/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
      <url>/posts/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      
        <content type="html"><![CDATA[<p>连接：TCP是面向连接，需要3次握手。UDP不需要</p><p>可靠性：TCP会通过超时重传、流量控制、拥塞控制来保证传输的可靠。UDP没有这些保证可靠性</p><p>传输方式：TCP的传输是以字节流的形式，没有边界，会有粘包问题。UDP的传输是一个包一个包发送，有边界</p><p>TCP优劣势：保证数据的可靠，但是实时性没有UDP好</p><p>UDP优劣势：实时性和速度好，但是不可靠</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http和https有什么区别</title>
      <link href="/posts/http%E5%92%8Chttps%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB.html"/>
      <url>/posts/http%E5%92%8Chttps%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB.html</url>
      
        <content type="html"><![CDATA[<p>安全性：http是明文传输，数据在传输过程中不加密，容易被窃听和篡改。https通过SSL&#x2F;TLS来对数据加密</p><p>建立链接：http只需要进行TCP三次握手即可建立链接，而https还需要进行SSL&#x2F;TLS的四次握手</p><p>端口号：http默认端口号是80，https是443</p><p>证书：https需要通过CA机构申请数字证书来验证服务器的身份</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>epoll的ET和LT模式</title>
      <link href="/posts/epoll%E7%9A%84ET%E5%92%8CLT%E6%A8%A1%E5%BC%8F.html"/>
      <url>/posts/epoll%E7%9A%84ET%E5%92%8CLT%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<p>epoll 是 Linux 提供的一种用于处理大规模 I&#x2F;O 并发的机制，全称是 event poll。它属于 I&#x2F;O 多路复用技术的一种，旨在高效管理大量的文件描述符（file descriptors, FDs）以及响应各类 I&#x2F;O 事件</p><p>与传统的 select 和 poll 不同，epoll 使用了<strong>事件通知</strong>的方式，避免了重复遍历文件描述符集合的高开销。epoll 提供了更好的扩展性，适用于处理数以千计的并发连接，因此非常适合在网络服务器等高并发场景下使用</p><ul><li>LevelTriggered：简称LT，当FD有数据可读时，会重复通知多次，直至数据处理完成。是epoll的默认模式</li><li>EdgeTriggered：简称ET，当FD有数据可读时，只通知一次，不管数据是否处理完成</li></ul><p>Level是指信号只需要处于水平，就一直会触发；而edge则是指信号为上升沿或者下降沿时触发。和电路信号有关：水平触发是level trigger 一旦触发就能维持那个level<br>而边缘触发edge trigger 就是一次稍纵即逝的变化</p><p><strong>在ET模式下，缓冲区从不可读变成可读，会唤醒应用进程，缓冲区数据变少的情况，则不会再唤醒应用进程</strong></p><p><img src="/img/epoll%E7%9A%84ET%E5%92%8CLT%E6%A8%A1%E5%BC%8F/img1.png" alt="alt text"></p><p><img src="/img/epoll%E7%9A%84ET%E5%92%8CLT%E6%A8%A1%E5%BC%8F/img2.png" alt="alt text"></p><p>调用epoll_wait, 会将list_head链表断开，复制数据到用户空间的events中，但是还会可能残留一些数据没有读取完。这时候，如果是ET模式，链表结构将不恢复；如果是LT模式，内核将把链表结构恢复，这样下次再调用epoll_wait的时候能够继续读</p><p>似乎，ET模式好像没什么用，因为有残留数据的问题读不到，但是仍然有两种方式可以解决：</p><ol><li>既然内核不帮我们恢复链表结构，我们自己恢复，在第一次读完数据之后，如果还有残留数据，调用epoll_ctl函数，手动添加回去</li><li>在第一次从fd读取数据的时候，既然每一个fd事件就绪时只通知一次，那么可以while循环一直读取数据。但是注意不能用阻塞IO，因为阻塞IO在读取完数据后还在读，会陷入死循环。因此要用非阻塞IO，如果没数据可读要返回一个标识，跳出循环</li></ol><p>优点：</p><ul><li>ET模式避免了LT模式可能出现的惊群现象</li><li>ET模式最好结合非阻塞IO读取FD数据，相比LT会复杂一点，但是比LT模式性能好一点</li></ul><p>惊群现象：如果有n个不同的进程同时监听某个fd，并且都在调用epoll_wait获取就绪的fd，结果fd就绪后会通知这些进程。LT模式中任何一个进程通知完，fd还会存在链表当中，因此所有监听fd的进程都会被唤醒。但是真正在处理的时候，前面一两个进程可以将fd中的数据读取完，后续被唤醒的进程就没必要。然而ET模式不会出现惊群现象。因此ET模式比LT模式好一点</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程间通信</title>
      <link href="/posts/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.html"/>
      <url>/posts/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.html</url>
      
        <content type="html"><![CDATA[<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><h2 id="匿名管道「-」"><a href="#匿名管道「-」" class="headerlink" title="匿名管道「|」"></a>匿名管道「|」</h2><p><code>ps auxf | grep mysql</code></p><p>上面这种管道是没有名字，所以「|」表示的管道称为匿名管道，用完了就销毁</p><h2 id="命名管道-mkfifo"><a href="#命名管道-mkfifo" class="headerlink" title="命名管道(mkfifo)"></a>命名管道(mkfifo)</h2><p><code>mkfifo myPipe</code></p><p>myPipe 就是这个管道的名称，基于 Linux 一切皆文件的理念，所以管道也是以文件的方式存在，我们可以用 ls 看一下，这个文件的类型是 p，也就是 pipe（管道） 的意思</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l</span><br><span class="line">prw-r--r--. 1 root root 0 Jul 17 02:45 myPipe</span><br></pre></td></tr></table></figure><p>接下来，我们往 myPipe 这个管道写入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello&quot; &gt; myPipe  // 将数据写进管道</span><br><span class="line">                       // 阻塞...</span><br></pre></td></tr></table></figure><p>因为管道里的内容没有被读取，只有当管道里的数据被读完后，命令才可以正常退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat &lt; myPipe  // 读取管道里的数据</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>优缺点：</p><ul><li>优点：自然就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了</li><li>缺点：通信方式效率低，不适合进程间频繁地交换数据</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>匿名管道的创建，需要通过下面这个系统调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pipe(int fd[2])</span><br></pre></td></tr></table></figure><p>这里表示创建一个匿名管道，并返回了两个描述符，一个是管道的读取端描述符 fd[0]，另一个是管道的写入端描述符 fd[1]。注意，这个匿名管道是特殊的文件，只存在于内存，不存于文件系统中</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/img1.png" alt="alt text"></p><p>所谓的管道，就是内核里面的一串缓存。我们可以使用 fork 创建子进程，创建的子进程会复制父进程的文件描述符，这样就做到了两个进程各有两个 fd[0] 与 fd[1]，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/img2.png" alt="alt text"></p><p>管道只能一端写入，另一端读出，所以上面这种模式容易造成混乱，因为父进程和子进程都可以同时写入，也都可以读出。那么，为了避免这种情况，通常的做法是： 父进程关闭读取的 fd[0]，只保留写入的 fd[1]； 子进程关闭写入的 fd[1]，只保留读取的 fd[0]</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/img3.png" alt="alt text"></p><p>到这里，我们仅仅解析了使用管道进行父进程与子进程之间的通信，但是在我们 shell 里面并不是这样的。 在 shell 里面执行 A | B 命令的时候，A 进程和 B 进程都是 shell 创建出来的子进程，A 和 B 之间不存在父子关系，它俩的父进程都是 shell</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/img4.png" alt="alt text"></p><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><p>消息队列克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核中的消息链表（内核是共享的），消息队列的消息体可以是用户自定义的数据类型。在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），当接收方接受数据时，也要与发送方的数据类型一样</p><p>缺点：</p><ul><li>通信不及时，因为每次数据的写入和读取都需要经过用户态和内核态的拷贝过程</li><li>不适合大数据的传输，因为内核中的消息体都有一个最大长度的限制，同时所有队列包含的消息体也是有上限的</li></ul><h1 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h1><p>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，大大提高了进程间通信的速度</p><p>优缺点：</p><ul><li>优点：不需要陷入内核态或者系统调用，也不需要拷贝数据</li><li>缺点：多进程竞争同一个资源会造成数据的错乱</li></ul><p><img src="/img/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/img5.png" alt="alt text"></p><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>对于共享内存的多进程竞争资源，而造成数据错乱的问题。信号量可以解决</p><p>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</p><p>信号量表示资源的数据，有两种操作：</p><ul><li>P操作：这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行</li><li>V操作：这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程</li><li>总的来说，操作后：如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行</li></ul><p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的</p><p>共享和互斥的实现方式：</p><ul><li>如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为1</li><li>如果要实现多进程同步的方式，我们可以初始化信号量为0</li></ul><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>信号跟信号量虽然名字相似度 66.66%，但两者用途完全不一样，就好像 Java 和 JavaScript 的区别</p><p>在 Linux 操作系统中， 为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义。我们可以通过 kill -l 命令，查看所有的信号：</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/img6.png" alt="alt text"></p><p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p><ul><li>Ctrl+C 产生SIGINT信号，表示终止该进程</li><li>Ctrl+Z 产生SIGTSTP信号，表示停止该进程，但还未结束</li></ul><p>如果进程在后台运行，可以通过 kill 命令的方式给进程发送信号，但前提需要知道运行中的进程 PID 号，例如： kill -9 1050 ，表示给 PID 为 1050 的进程发送 SIGKILL 信号，用来立即结束该进程</p><p>信号是进程间通信机制中唯一的<strong>异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式</p><ul><li>执行默认操作： Linux对每种信号都做了默认操作，比如列表中的SIGTERM信号，就是终止进程的意思</li><li>捕捉信号：我们可以定义信号是一个信号处理函数，当信号发生的时候就执行对应的函数</li><li>忽略信号：当我们不希望处理信号的时候就可以忽略，但有两个是不能捕捉和忽略的，分别是SIGKILL和SEGSTOP，分别表示任何时候中断或者结束某一进程</li></ul><h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><p><code>int socket(int domain, int type, int protocal)</code></p><p>socket参数意义：</p><ul><li>domain：用来指定协议族，比如 AF_INET 用于 IPV4、AF_INET6 用于 IPV6、AF_LOCAL&#x2F;AF_UNIX 用于本机</li><li>type：参数用来指定通信特性，比如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM 表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字</li><li>protocal：参数原本是用来指定通信协议的，但现在基本废弃。因为协议已经通过前面两个参数指定完成，protocol 目前一般写成 0 即可</li></ul><p>根据创建 socket 类型的不同，通信的方式也就不同：</p><ul><li>实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM</li><li>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM</li><li>实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket</li></ul><h2 id="针对-TCP-协议通信的-socket-编程模型"><a href="#针对-TCP-协议通信的-socket-编程模型" class="headerlink" title="针对 TCP 协议通信的 socket 编程模型"></a>针对 TCP 协议通信的 socket 编程模型</h2><p><img src="/img/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/img7.png" alt="alt text"></p><ul><li>bind：服务端用于将把用于通信的地址和端口绑定到 socket 上</li><li>这里需要注意的是，服务端调用 accept 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作监听 socket，一个叫作已完成连接 socket</li></ul><h2 id="针对-UDP-协议通信的-socket-编程模型"><a href="#针对-UDP-协议通信的-socket-编程模型" class="headerlink" title="针对 UDP 协议通信的 socket 编程模型"></a>针对 UDP 协议通信的 socket 编程模型</h2><p><img src="/img/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/img8.png" alt="alt text"></p><p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind</p><h2 id="针对本地进程间通信的-socket-编程模型"><a href="#针对本地进程间通信的-socket-编程模型" class="headerlink" title="针对本地进程间通信的 socket 编程模型"></a>针对本地进程间通信的 socket 编程模型</h2><p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是绑定一个本地文件，这也就是它们之间的最大区别</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程上下文切换</title>
      <link href="/posts/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.html"/>
      <url>/posts/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.html</url>
      
        <content type="html"><![CDATA[<h1 id="进程由哪些部分组成？进程上下文又由哪些部分组成？"><a href="#进程由哪些部分组成？进程上下文又由哪些部分组成？" class="headerlink" title="进程由哪些部分组成？进程上下文又由哪些部分组成？"></a>进程由哪些部分组成？进程上下文又由哪些部分组成？</h1><h2 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h2><ol><li><p>进程控制块（Program control block）（灵魂）</p><ul><li>建立进程——建立PCB</li><li>撤销PCB——销毁进程</li></ul></li><li><p>程序（躯体）</p><ul><li>代码（code）</li><li>数据（data）</li><li>堆和栈（stack和heap）（栈：保存返回点、参数、返回值、局部变量堆：动态变量）</li></ul></li></ol><h2 id="进程的地址空间"><a href="#进程的地址空间" class="headerlink" title="进程的地址空间"></a>进程的地址空间</h2><p>内核空间1G，用户空间3G</p><p>一般来说进程的地址空间指的是用户空间</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/img1.png" alt="alt text"></p><h2 id="进程详细的组成部分"><a href="#进程详细的组成部分" class="headerlink" title="进程详细的组成部分"></a>进程详细的组成部分</h2><p><img src="/img/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/img2.png" alt="alt text"></p><p>进程的上下文：</p><ul><li>物理实体（代码和数据，在地址空间）</li><li>支持进程运行的环境（PCB、内核栈、reg）</li></ul><p>具体来说：</p><ul><li>进程的程序块、数据块、运行时的堆和用户栈等组成的用户空间信息是用户级上下文，也就是地址空间</li><li>寄存器（reg）是硬件上下文（寄存器上下文），即进程的现场信息</li><li>PCB、内核栈等内核信息是系统级上下文</li></ul><p>进程上下文切换：</p><ul><li>总的来说，下降进程的上下文保存，上升进程中曾经被保存的上下文重新放到被执行的环境中。</li><li>在进程上下文切换过程中，OS把换下进程的寄存器上下文保存到系统级上下文（理论上在PCB，实际上PCB很小因此保存在内核栈中，通过stack指针找到）</li><li>用户级上下文和系统级上下文一起构成了一个进程的整个存储器映像</li></ul><h1 id="何时发生进程上下文切换？"><a href="#何时发生进程上下文切换？" class="headerlink" title="何时发生进程上下文切换？"></a>何时发生进程上下文切换？</h1><p>下降进程自身造成切换&#x2F;外界强制下降进程和上升进程切换</p><p><strong>注意，要和CPU上下文区分开，CPU的上下文切换分为几种场景：进程上下文切换、线程上下文切换、中断上下文切换</strong></p><p>系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。 系统调用过程通常称为特权模式切换，而不是进程上下文切换，进行的是线程上下文切换</p><h1 id="下降进程的现场和断点保存在哪里？是PCB吗？"><a href="#下降进程的现场和断点保存在哪里？是PCB吗？" class="headerlink" title="下降进程的现场和断点保存在哪里？是PCB吗？"></a>下降进程的现场和断点保存在哪里？是PCB吗？</h1><p>现场就是寄存器，断点就是PC寄存器。前面已说，理论上在PCB，实际上在内核栈</p><h1 id="用户栈和内核栈（中断栈）"><a href="#用户栈和内核栈（中断栈）" class="headerlink" title="用户栈和内核栈（中断栈）"></a>用户栈和内核栈（中断栈）</h1><p>每个进程（线程）两个栈：</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/img3.png" alt="alt text"></p><p>tip：因为上下文切换是由中断驱动的，所以内核栈也叫中断栈。不过IA32将内核栈和中断栈分开，ARM体系结构两者完全一样</p><h1 id="CPU硬件的中断响应"><a href="#CPU硬件的中断响应" class="headerlink" title="CPU硬件的中断响应"></a>CPU硬件的中断响应</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><ol><li><p>关中断（“中断允许位”自动清0）：使CPU处于禁止中断状态，以防止新中断破坏SP、断点(PC)、程序状态字（PSW）等</p></li><li><p>保存断点和中断状态：将用户栈指针、断点、程序状态字（PSW）保存到内核栈</p><ul><li>SP(SS:ESP)</li><li>PC(CS:EIP)</li><li>PSW,在IA-32中是EFLAGS寄存器</li></ul><p>为什么要先保存SP?</p><p>总的来说，SP只有一个且SP首先发生变化</p><p>因为下降进程，它的硬件上下文要保存到PCB或是内核栈中，既然要保存到内核栈，SP就必须由本来用户态时指向用户栈，而改为指向内核栈，这说明SP首先发生变化，故而在将硬件上下文保存到内核栈时，首先要保存SP。之所以知道内核栈的位置，以linux的PCB，即task_struct为例，PCB中有指向本进程内核栈的指针，可以通过PCB找到内核栈</p></li><li><p>识别中断事件，得到“中断类型号”，根据此号，到中断向量表中读取对应的中断服务程序的入口地址</p></li></ol><h2 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h2><p><img src="/img/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/img4.png" alt="alt text"></p><p>具体流程:</p><p>中断发生前：</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/img5.png" alt="alt text"></p><p>中断发生时：</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/img6.png" alt="alt text"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="shell进程和hello进程的例子"><a href="#shell进程和hello进程的例子" class="headerlink" title="shell进程和hello进程的例子"></a>shell进程和hello进程的例子</h2><p>进程切换必须由操作系统接管控制权</p><p>shell里面运行一个hello程序</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/img7.png" alt="alt text"></p><h2 id="进程切换还需要改变当前进程空间"><a href="#进程切换还需要改变当前进程空间" class="headerlink" title="进程切换还需要改变当前进程空间"></a>进程切换还需要改变当前进程空间</h2><p><code>模式切换：CPU还是在同一进程中运行或在在中断上下文时，因此还需要改变进程空间</code></p><ol><li>保存当前进程的硬件上下文，对Linux系统而言，硬件上下文大部分（SP&#x2F;PC&#x2F;PSW等）保存在struct thread_struct thread中，通用寄存器（eax&#x2F;ebx）保存在内核栈</li><li>修改当前进程的PCB, 比如将其运行状态由运行态改为就绪或者等待，并将该PCB加入相关队列</li><li>调度另外一个进程</li><li>修改被调度进程的PCB, 状态改为运行（系统上下文）</li><li>将“当前进程”的存储管理数据改为被调度进程的存储管理（页表、TLB）（用户级上下文）</li><li>恢复新进程的硬件上下文，让PC指向新进程代码</li></ol>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis缓存场景</title>
      <link href="/posts/Redis%E7%BC%93%E5%AD%98%E5%9C%BA%E6%99%AF.html"/>
      <url>/posts/Redis%E7%BC%93%E5%AD%98%E5%9C%BA%E6%99%AF.html</url>
      
        <content type="html"><![CDATA[<p>介绍旁路缓存和缓存异常的场景</p><h1 id="旁路缓存-Cache-Aside"><a href="#旁路缓存-Cache-Aside" class="headerlink" title="旁路缓存(Cache-Aside)"></a>旁路缓存(Cache-Aside)</h1><p>Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准</p><ul><li>读策略： 从缓存中读取数据；如果缓存命中，则直接返回数据；如果缓存不命中，则从数据库中查询数据；查询到数据后，将数据写入到缓存中，并且返回给用户</li><li>写策略： 更新数据库Mysql中的记录,然后删除Redis中的缓存记录</li></ul><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>用户访问的数据既不在缓存中，也不在数据库中</p><p>解决：</p><ul><li>回写特殊值：缓存未命中且数据库也没有，在Redis缓存中设置一个特殊值表示数据不存在。会消耗内存</li><li>布隆过滤器：由初始值都为0的位图数组和N个哈希函数组成<br>流程：<ol><li>采用N个哈希函数运算得到N个哈希值</li><li>将这N个哈希值对位图数组长度取模，得到每个哈希值在数组中的位置</li><li>在N个对应位置设置成1</li><li>查询的时候，只要对于位置的值全是1就表示存在。因此过滤器查询到这个数据，数据库不一定存在。如果查询不到数据库一定不存在</li></ol></li><li>限流策略：采取令牌桶算法或者漏桶算法，对这些数据进行限流</li></ul><h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>缓存中的某个热点数据过期</p><p>解决：</p><ul><li>设置热点数据的热度时间窗口，在这个时间内如果数据被频繁访问，将缓存时间延长</li><li>使用互斥锁或分布式锁，只允许一个线程去查询数据，避免多个线程同时查询数据库压力过大</li><li>热点数据缓存永不过期</li><li>异步更新缓存，减少对数据库的直接访问，并且不会阻塞请求的响应</li></ul><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>大量缓存数据在同一时间过期或者Redis宕机</p><p>大量缓存数据在同一时间过期的解决：</p><ul><li>设置缓存过期的随机过期时间</li><li>使用互斥锁或分布式锁，只允许一个线程去查询数据，避免多个线程同时查询数据库压力过大</li><li>数据预热，提前将热点数据加载到缓存</li><li>后台更新缓存，业务不再复制更新缓存，也不设置有效期，而让缓存“永久有效”，将更新缓存的工作交给后台线程定时更新</li><li>数据库优化，提升数据库的性能，增加数据库的容量，以应对大量请求导致的数据库压力</li></ul><p>Redis宕机的解决：</p><ul><li>服务熔断或者限流策略：暂停业务对缓存的访问，如果Redis宕机则直接返回错误不访问数据库。但是这样做会导致业务无法正常工作。也可以启动限流策略，只接受少量部分的请求</li><li>提供缓存本身的可用性：通过主从节点的构建Redis缓存高可靠集群</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis分布式锁</title>
      <link href="/posts/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html"/>
      <url>/posts/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html</url>
      
        <content type="html"><![CDATA[<h1 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h1><p>分布式锁是实现分布式系统之间共享资源的一种方式</p><p><img src="/img/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/img1.png" alt="alt text"></p><h1 id="Redis实现分布式锁的要点"><a href="#Redis实现分布式锁的要点" class="headerlink" title="Redis实现分布式锁的要点"></a>Redis实现分布式锁的要点</h1><p>加锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set lock_key owner nx px n </span><br><span class="line">    /*</span><br><span class="line">        不能用setnx，因为setnx不能带过期参数</span><br><span class="line">        px n 表示设置过期时间是n秒</span><br><span class="line">    */ </span><br></pre></td></tr></table></figure><p>解锁：</p><p>先判断owner是否为加锁客户端，是的话才能将lock_key删除</p><p>采用lua脚本让两个操作变成一个原子操作：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 先判断owner是否为加锁客户端</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, KEYS[<span class="number">1</span>]) // 将lock_key删除</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="为什么需要owner"><a href="#为什么需要owner" class="headerlink" title="为什么需要owner"></a>为什么需要owner</h1><p>存在服务A释放掉服务B的锁的可能：</p><p>比如服务A获取了锁，由于业务流程比较长，耗时久，导致锁过期。这时候服务B获取了锁，准备去执行，这个时候服务A恢复了过来并做完了业务，就会释放锁，但是业务B还在执行。</p><h1 id="lua一定能保证原子性？"><a href="#lua一定能保证原子性？" class="headerlink" title="lua一定能保证原子性？"></a>lua一定能保证原子性？</h1><p>lua本身不具有原子性，上面提到的用lua脚本保证原子性是因为Redis是单线程的，一个流程放进lua来执行，相当于是打包在一起，Redis执行他的流程不会被其他请求打断，所以保证了原子性</p><h1 id="Redis分布式锁优缺点"><a href="#Redis分布式锁优缺点" class="headerlink" title="Redis分布式锁优缺点"></a>Redis分布式锁优缺点</h1><p>优点：</p><ul><li>性能高效：选择缓存实现</li><li>实现方便：Redis提供了setnx方法</li><li>避免单点故障：Redis是跨集群部署</li></ul><p>缺点：</p><ul><li>超时时间不好设置</li><li>Redis主从复制的数据是异步复制的，这样导致分布式锁不可靠：Redis主节点获取到锁后，没有同步到其他节点，在主节点宕机后，此时新的节点依然可以获取到锁，所以多个应用服务获取到了锁</li></ul><h1 id="Redis分布式锁的超时时间怎么设置"><a href="#Redis分布式锁的超时时间怎么设置" class="headerlink" title="Redis分布式锁的超时时间怎么设置"></a>Redis分布式锁的超时时间怎么设置</h1><p>基于续约的方式设置超时时间。先给锁设置一个超时时间，然后启动一个守护线程，让守护线程在一段时间后，重新设置这个锁的超时时间， 比如Redisson的看门狗机制。<br>当然也会设置一个最大续约次数，避免因为服务异常导致无限续约，锁得不到释放</p><h1 id="Redisson的看门狗机制"><a href="#Redisson的看门狗机制" class="headerlink" title="Redisson的看门狗机制"></a>Redisson的看门狗机制</h1><p>看门狗机制是Redission提供的一种自动延期机制，这个机制使得Redission提供的分布式锁是可以自动续期的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">lockWatchdogTimeout</span> <span class="operator">=</span> <span class="number">30</span> * <span class="number">1000</span>; <span class="comment">//看门狗机制提供的默认超时时间是30*1000毫秒，也就是30秒</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">return</span> tryLock(waitTime, -<span class="number">1</span>, unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在Redis中，锁的waiiTime表示等待获取锁的时间，而leaseTime表示锁的持有时间。 当一个线程或进程尝试获取锁时，如果锁已被其他线程或进程持有，则会等待一段时间（waitTime）后再次尝试获取锁。 </li><li>如果在这段时间内锁被释放，则当前线程或进程可以成功获取锁，否则需要等待下一次尝试。 一旦锁被某个线程或进程获取成功，该线程或进程拥有锁的持有权，持有时间为leaseTime</li></ul><p>看门狗流程：</p><ol><li>在获取锁的时候，不能指定leaseTime或者只能将leaseTime设置为-1，这样才能开启看门狗机制。</li><li>在tryLockInnerAsync方法里尝试获取锁，如果获取锁成功调用scheduleExpirationRenewal执行看门狗机制</li><li>在scheduleExpirationRenewal中比较重要的方法就是renewExpiration，当线程第一次获取到锁（也就是不是重入的情况），那么就会调用renewExpiration方法开启看门狗机制</li><li>在renewExpiration会为当前锁添加一个延迟任务task，这个延迟任务会在10s后执行，执行的任务就是将锁的有效期刷新为30s（这是看门狗机制的默认锁释放时间）</li><li>并且在任务最后还会继续递归调用renewExpiration</li></ol><p>看门狗的作用，考虑以下三种情况：</p><ul><li>如果没有设置锁的过期时间，单靠逻辑来释放锁，就会出现获取锁的节点宕机时，锁没有释放，造成死锁</li><li>如果设置了某个过期时间，在没有宕机的情况下，线程发生了阻塞，就会导致锁过期自动释放，带来一些其他的问题</li><li>如果设置了看门狗，在没有宕机时，如果发生了阻塞，那么看门狗就能一直给线程续时间；如果宕机了，看门狗不起作用，过了有效期之后就会自动释放掉锁，不会造成死锁</li></ul><p>底层源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Long <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> get(tryAcquireAsync(waitTime, leaseTime, unit, threadId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; RFuture&lt;Long&gt; <span class="title function_">tryAcquireAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (leaseTime != -<span class="number">1L</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果获取锁失败，返回的结果是这个key的剩余有效期</span></span><br><span class="line">        RFuture&lt;Long&gt; ttlRemainingFuture = <span class="built_in">this</span>.tryLockInnerAsync(waitTime, <span class="built_in">this</span>.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">        <span class="comment">//上面获取锁回调成功之后，执行这代码块的内容</span></span><br><span class="line">        ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">            <span class="comment">//不存在异常</span></span><br><span class="line">            <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//剩余有效期为null</span></span><br><span class="line">                <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//这个函数是解决最长等待有效期的问题</span></span><br><span class="line">                    <span class="built_in">this</span>.scheduleExpirationRenewal(threadId);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ttlRemainingFuture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;T&gt; RFuture&lt;T&gt; <span class="title function_">tryLockInnerAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;</span><br><span class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, command,</span><br><span class="line">                          <span class="comment">// 锁不存在，则往redis中设置锁信息</span></span><br><span class="line">                          <span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                          <span class="comment">// 锁存在</span></span><br><span class="line">                          <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,</span><br><span class="line">                          Collections.singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ExpirationEntry&gt; EXPIRATION_RENEWAL_MAP = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">scheduleExpirationRenewal</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpirationEntry</span>();</span><br><span class="line">    <span class="comment">//这里EntryName是指锁的名称</span></span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">oldEntry</span> <span class="operator">=</span> (ExpirationEntry)EXPIRATION_RENEWAL_MAP.putIfAbsent(<span class="built_in">this</span>.getEntryName(), entry);</span><br><span class="line">    <span class="keyword">if</span> (oldEntry != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//重入</span></span><br><span class="line">        <span class="comment">//将线程ID加入</span></span><br><span class="line">        oldEntry.addThreadId(threadId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将线程ID加入</span></span><br><span class="line">        entry.addThreadId(threadId);</span><br><span class="line">        <span class="comment">//续约</span></span><br><span class="line">        <span class="built_in">this</span>.renewExpiration();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//先从map里得到这个ExpirationEntry</span></span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> (ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(<span class="built_in">this</span>.getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//这个是一个延迟任务</span></span><br><span class="line">        <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> <span class="built_in">this</span>.commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="comment">//延迟任务内容</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">//拿出ExpirationEntry</span></span><br><span class="line">                <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> (ExpirationEntry)RedissonLock.EXPIRATION_RENEWAL_MAP.get(RedissonLock.<span class="built_in">this</span>.getEntryName());</span><br><span class="line">                <span class="keyword">if</span> (ent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//从ExpirationEntry拿出线程ID</span></span><br><span class="line">                    <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">                    <span class="keyword">if</span> (threadId != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//调用renewExpirationAsync方法刷新最长等待时间</span></span><br><span class="line">                        RFuture&lt;Boolean&gt; future = RedissonLock.<span class="built_in">this</span>.renewExpirationAsync(threadId);</span><br><span class="line">                        future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                                RedissonLock.log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + RedissonLock.<span class="built_in">this</span>.getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                                    <span class="comment">//renewExpirationAsync方法执行成功之后，进行递归调用，调用自己本身函数</span></span><br><span class="line">                                    <span class="comment">//那么就可以实现这样的效果</span></span><br><span class="line">                                    <span class="comment">//首先第一次进行这个函数，设置了一个延迟任务，在10s后执行</span></span><br><span class="line">                                    <span class="comment">//10s后，执行延迟任务的内容，刷新有效期成功，那么就会再新建一个延迟任务，刷新最长等待有效期</span></span><br><span class="line">                                    <span class="comment">//这样这个最长等待时间就会一直续费</span></span><br><span class="line">                                    RedissonLock.<span class="built_in">this</span>.renewExpiration();</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, </span><br><span class="line">        <span class="built_in">this</span>.internalLockLeaseTime / <span class="number">3L</span>, <span class="comment">//这是锁自动释放时间，因为没传，所以是看门狗时间=30*1000,也就是10s</span></span><br><span class="line">        TimeUnit.MILLISECONDS); <span class="comment">//时间单位</span></span><br><span class="line">        </span><br><span class="line">        ee.setTimeout(task); <span class="comment">//给当前ExpirationEntry设置延迟任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新等待时间</span></span><br><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">renewExpirationAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                          <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">                          Collections.singletonList(getName()),</span><br><span class="line">                          internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后，在释放锁的时候，就会关闭所有的延迟任务</span></span><br><span class="line"><span class="keyword">public</span> RFuture&lt;Void&gt; <span class="title function_">unlockAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    RPromise&lt;Void&gt; result = <span class="keyword">new</span> <span class="title class_">RedissonPromise</span>();</span><br><span class="line">    RFuture&lt;Boolean&gt; future = <span class="built_in">this</span>.unlockInnerAsync(threadId);</span><br><span class="line">    future.onComplete((opStatus, e) -&gt; &#123;</span><br><span class="line">        <span class="comment">//取消锁更新任务</span></span><br><span class="line">        <span class="built_in">this</span>.cancelExpirationRenewal(threadId);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            result.tryFailure(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opStatus == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">IllegalMonitorStateException</span> <span class="variable">cause</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>(<span class="string">&quot;attempt to unlock lock, not locked by current thread by node id: &quot;</span> + <span class="built_in">this</span>.id + <span class="string">&quot; thread-id: &quot;</span> + threadId);</span><br><span class="line">            result.tryFailure(cause);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.trySuccess((Object)<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">cancelExpirationRenewal</span><span class="params">(Long threadId)</span> &#123;</span><br><span class="line">    <span class="comment">//获得当前这把锁的任务</span></span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">task</span> <span class="operator">=</span> (ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(<span class="built_in">this</span>.getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//当前锁的延迟任务不为空，且线程id不为空</span></span><br><span class="line">        <span class="keyword">if</span> (threadId != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//先把线程ID去掉</span></span><br><span class="line">            task.removeThreadId(threadId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (threadId == <span class="literal">null</span> || task.hasNoThreads()) &#123;</span><br><span class="line">            <span class="comment">//然后取出延迟任务</span></span><br><span class="line">            <span class="type">Timeout</span> <span class="variable">timeout</span> <span class="operator">=</span> task.getTimeout();</span><br><span class="line">            <span class="keyword">if</span> (timeout != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//把延迟任务取消掉</span></span><br><span class="line">                timeout.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//再把ExpirationEntry移除出map</span></span><br><span class="line">            EXPIRATION_RENEWAL_MAP.remove(<span class="built_in">this</span>.getEntryName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redis如何解决集群情况下分布式锁的可靠性"><a href="#Redis如何解决集群情况下分布式锁的可靠性" class="headerlink" title="Redis如何解决集群情况下分布式锁的可靠性"></a>Redis如何解决集群情况下分布式锁的可靠性</h1><p>采用Redlock（红锁）：让客户端和多个独立的Redis节点依次请求加锁，如果客户端能和半数以上的节点成功完成加锁操作，那么我们任务客户端成功获取到了分布式锁，否则获取失败</p><p>流程：</p><ol><li>客户端获取到当前时间T1</li><li>客户端依次向N个Redis节点执行加锁操作，加锁操作使用set命令，带上nx，px和客户端的唯一标识。如果某个节点发生了故障，为了保证Redlock能继续运行，需要给 加锁操作设置一个超时时间（远小于锁的过期时间）</li><li>一旦客户端从超过半数的Redis节点上获取到了锁，就再次获取当前时间T2</li><li>如果T2 - T1 &lt; 锁的过期时间，否则获取失败</li></ol><p>可以发现，需要满足两个条件：</p><ul><li>客户端从超过半数的Redis节点上获取到了锁</li><li>如果T2 - T1 &lt; 锁的过期时间</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/hello-world.html"/>
      <url>/posts/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis过期删除策略和内存淘汰策略</title>
      <link href="/posts/Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html"/>
      <url>/posts/Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5.html</url>
      
        <content type="html"><![CDATA[<h1 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h1><h2 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h2><ol><li>只对key设置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expire key n // key在n秒后过期</span><br><span class="line">pexpire key n // key在n毫秒后过期</span><br><span class="line">expireat key n // key在时间戳n秒的时刻过期</span><br><span class="line">pexpireat key n // key在时间戳n毫秒的时刻过期</span><br></pre></td></tr></table></figure><ol start="2"><li>创建key的时候设置</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set key value ex n // 创建key，并且key在n秒后过期</span><br><span class="line">set key value px n // 创建key，并且key在n毫秒后过期</span><br><span class="line">set key n value // 创建key，并且key在时间戳n秒的时刻过期</span><br></pre></td></tr></table></figure><ol start="3"><li>查看某个key的存活时间</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttl key</span><br></pre></td></tr></table></figure><h2 id="判定key是否过期"><a href="#判定key是否过期" class="headerlink" title="判定key是否过期"></a>判定key是否过期</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span> </span><br><span class="line">    dict *dict; <span class="comment">/* 数据库键空间，存放着所有的键值对 */</span> </span><br><span class="line">    dict *expires; <span class="comment">/* 键的过期时间 */</span> .... </span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>过期字典数据结构：</p><ul><li>key 是一个指针，指向某个键对象</li><li>value 是一个 long long 类型的整数，这个整数保存了 key 的过期时间</li></ul><p><img src="/img/Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/img1.png" alt="alt text"></p><p>判断策略：</p><ul><li>字典实际上是哈希表，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找</li><li>当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：<ol><li>如果不在，则正常读取键值；</li><li>如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。</li></ol></li></ul><h2 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h2><ul><li>定时删除：给key创建过期时间的同时创建一个定时器，在过期时间来临的时候进行主动删除。好处是删除及时使得内存空间释放，坏处是定时器占用CPU时间</li><li>惰性删除：不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该key。好处是占用CPU时间少，坏处是容易造成内存泄漏</li><li>定期删除：每隔一段时间随机从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。平衡了CPU和内存占用</li><li>Redis采用的是最后两种，惰性删除和定期删除组合使用</li></ul><h2 id="Redis定期删除的流程"><a href="#Redis定期删除的流程" class="headerlink" title="Redis定期删除的流程"></a>Redis定期删除的流程</h2><ol><li>从过期字典中随机抽取 20 个 key</li><li>检查这 20 个 key 是否过期，并删除已过期的 key</li><li>如果本轮检查的已过期 key 的数量，超过 5 个（20&#x2F;4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查</li></ol><h1 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h1><h2 id="有哪些内存淘汰策略"><a href="#有哪些内存淘汰策略" class="headerlink" title="有哪些内存淘汰策略"></a>有哪些内存淘汰策略</h2><p><img src="/img/Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/img2.png" alt="alt text"></p><ul><li>noevction：不淘汰任何数据，如果运行内存超过了最大设置内存，会不允许写入</li><li>volatile：针对过期键<ul><li>lru：淘汰最久未访问到的数据</li><li>lfu：淘汰使用频率最少的数据</li><li>random：随机淘汰</li><li>ttl：淘汰最久的过期键</li></ul></li><li>allkeys：针对所有键 <ul><li>lru：淘汰最久未访问到的数据</li><li>lfu：淘汰使用频率最少的数据</li><li>random：随机淘汰</li></ul></li></ul><h2 id="Redis的LRU算法"><a href="#Redis的LRU算法" class="headerlink" title="Redis的LRU算法"></a>Redis的LRU算法</h2><p>LRU，最近最久未使用算法：记录了每个key的最近访问时间，每次淘汰最久这个时间的key，但是redis的lru不是标准的，做了优化</p><p>优化：</p><ul><li>标准lru需要维护双链表，开销很大，所以redis采用的是近似LRU算法</li><li>具体的是每次随机采样n个key，默认值是5，然后按照时间戳淘汰最久的那个。如果淘汰后内存还是不足继续随机采样淘汰。在3.0之后，redis LRU还维护了淘汰池，池中的数据按照访问时间进行排序。第一次随机选取的key都会放入池中，每次淘汰池中最久访问的key。</li><li>随后每次选取的key只有空闲时间（指的是没有访问到的时候）大于池中空间时间最小的key，才能放入其中。当池子装满了，需要新的key放入的时候，就将池子中最大的key淘汰</li></ul><h2 id="Redis的LFU算法"><a href="#Redis的LFU算法" class="headerlink" title="Redis的LFU算法"></a>Redis的LFU算法</h2><p>LRU 算法有一个问题，无法解决缓存污染问题，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染</p><p>所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些</p><p>LFU 算法相比于 LRU 算法的实现，多记录了「数据的访问频次」的信息。Redis 对象的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span> </span><br><span class="line">    ... <span class="comment">// 24 bits，</span></span><br><span class="line">    用于记录对象的访问信息 <span class="type">unsigned</span> lru:<span class="number">24</span>; </span><br><span class="line">    ... </span><br><span class="line">&#125; </span><br><span class="line">robj;</span><br></pre></td></tr></table></figure><p>Redis对象头中的lru字段，在LRU算法下和LFU算法下使用方式并不相同:</p><ul><li>在 LRU 算法中，Redis对象头的24bits的lru字段是用来记录key的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的lru字段记录的值，来比较最后一次key的访问时间长，从而淘汰最久未被使用的key</li><li>在 LFU 算法中，Redis对象头的24bits的lru字段被分成两段来存储，高16bit存储ldt(Last Decrement Time)，低8bit存储logc(Logistic Counter)</li></ul><p><img src="/img/Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/img3.png" alt="alt text"></p><p>lfu字段：</p><ul><li>ldt:用来记录key的访问时间戳；</li><li>logc:用来记录key的访问频次，它的值越小表示使用频率越低，越容易淘汰，每个新加入的key的logc初始值为5</li><li>logc 并不是单纯的访问次数，而是访问频次（访问频率），因为 logc 会随时间推移而衰减的。<br>在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大 <strong>（ldt的作用）</strong>，那么衰减的值就越大，这样实现的 LFU 算法是根据访问频率来淘汰数据的，而不只是访问次数。访问频率需要考虑 key 的访问是多长时间段内发生的。key 的先前访问距离当前时间越长，那么这个 key 的访问频率相应地也就会降低，这样被淘汰的概率也会更大。<br>对 logc 做完衰减操作后，就开始对 logc 进行增加操作，增加操作并不是单纯的 + 1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化</title>
      <link href="/posts/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html"/>
      <url>/posts/Redis%E6%8C%81%E4%B9%85%E5%8C%96.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis的持久化方式有哪些"><a href="#Redis的持久化方式有哪些" class="headerlink" title="Redis的持久化方式有哪些"></a>Redis的持久化方式有哪些</h1><p>Redis持久化有两种方式：RDB（Redis DataBase）和AOF（Append Only File）</p><p><img src="/img/Redis%E6%8C%81%E4%B9%85%E5%8C%96/img1.png" alt="alt text"></p><ul><li>RDB：RDB文件是一个经过压缩的二进制文件</li><li>AOF：AOF则是以追加的方式记录Redis执行的每一条写命令</li></ul><h1 id="Redis重启时加载持久化文件"><a href="#Redis重启时加载持久化文件" class="headerlink" title="Redis重启时加载持久化文件"></a>Redis重启时加载持久化文件</h1><p><img src="/img/Redis%E6%8C%81%E4%B9%85%E5%8C%96/img2.png" alt="alt text"></p><h1 id="RDB和AOF的区别"><a href="#RDB和AOF的区别" class="headerlink" title="RDB和AOF的区别"></a>RDB和AOF的区别</h1><ul><li>文件类型：RDB生成的是二进制文件（快照），AOF生成的是文本文件（追加日志）</li><li>安全性：缓存宕机时，RDB容易丢失较多的数据，AOF根据策略决定（默认的everysec可以保证最多有一秒的损失）</li><li>文件恢复速度：由于RDB是二进制文件，恢复比AOF快</li><li>操作的开销：每一次RDB保存都是一次全量保存，操作比较重，通常至少5分钟保存一次。而AOF的刷盘是追加操作，操作比较轻，通常设置为每一秒进行一次刷盘</li></ul><h1 id="RDB和AOF选哪种比较好"><a href="#RDB和AOF选哪种比较好" class="headerlink" title="RDB和AOF选哪种比较好"></a>RDB和AOF选哪种比较好</h1><ul><li>从业务需要来看，如果我们可以接受分钟级别的丢失，可以选择RDB。如果我们尽量让数据安全，可以考虑AOF混合持久化，</li><li>从持久化理论来看，始终开启快照是一个推荐，这也是官方默认开启RDB而不开启AOF</li></ul><h1 id="什么是AOF混合持久化"><a href="#什么是AOF混合持久化" class="headerlink" title="什么是AOF混合持久化"></a>什么是AOF混合持久化</h1><ul><li>使用RDB持久化函数，将内存数据写入到新的AOF文件中（数据格式也是RDB）</li><li>而重写期间新的命令追加到新的AOF中（数据格式是AOF）</li><li>新的AOF文件包含RDB格式和AOF格式的数据</li></ul><h1 id="RDB的触发时机"><a href="#RDB的触发时机" class="headerlink" title="RDB的触发时机"></a>RDB的触发时机</h1><ul><li>调用save和bgsave命令</li><li>根据我们的配置周期决定</li><li>redis关闭前</li><li>主从复制第二阶段：主服务器全量复制RDB文件发送给从服务器</li><li>客户点执行清空命令FLUSHALL</li></ul><h1 id="save和bgsave的区别"><a href="#save和bgsave的区别" class="headerlink" title="save和bgsave的区别"></a>save和bgsave的区别</h1><ul><li>save：会阻塞主进程，客户端无法连接redis，等SAVE完成后，主进程才开始工作，客户端可以连接</li><li>bgsave：是fork一个save的子进程，在执行save过程中，不影响主进程，客户端可以正常链接redis，等子进程fork执行save完成后，通知主进程，子进程关闭。bgsave采取的是<strong>写时复制</strong>。<br>子进程写数据到临时的RDB文件，写完之后替换旧的RDB文件</li></ul><h1 id="AOF的触发时机"><a href="#AOF的触发时机" class="headerlink" title="AOF的触发时机"></a>AOF的触发时机</h1><ul><li>Redis关闭的时候</li><li>每一次事件循环的时候</li><li>通过配置指令关闭AOF的时候</li></ul><h1 id="AOF重写流程"><a href="#AOF重写流程" class="headerlink" title="AOF重写流程"></a>AOF重写流程</h1><ol><li>子进程读取Redis DB中的数据以字符串命令的格式（也可以看作AOF格式）写入到新AOF中</li><li>如果有新数据，由主进程将数据写入到AOF重写缓冲区（aof_rewrite_buf）</li><li>当子进程完成重写操作后，主进程通过管道将AOF重写缓冲区数据传输给子进程，子进程追加到AOF文件中</li></ol><h1 id="AOF的不足"><a href="#AOF的不足" class="headerlink" title="AOF的不足"></a>AOF的不足</h1><ol><li>额外CPU的开销：<ul><li>如果有新数据，由主进程将数据写入到AOF重写缓冲区</li><li>进程通过管道将AOF重写缓冲区数据传输给子进程</li><li>子进程追加到AOF文件中</li></ul></li><li>额外内存的开销：<br>在重写的时候，Redis不仅将新的操作记录在原有的AOF缓冲区，还记录在AOF重写缓冲区</li><li>额外的磁盘开销：<br>在重写的时候，AOF缓冲需要刷入旧的AOF日志，AOF重写缓冲也需要刷入新的AOF日志，导致在重写的时候多了一份数据</li></ol><p>但是Redis在7.0做了优化？下一个问答</p><h1 id="Redis7-0对AOF做了哪些优化"><a href="#Redis7-0对AOF做了哪些优化" class="headerlink" title="Redis7.0对AOF做了哪些优化"></a>Redis7.0对AOF做了哪些优化</h1><p><img src="/img/Redis%E6%8C%81%E4%B9%85%E5%8C%96/img3.png" alt="alt text"></p><p>原来的AOF重写缓存被移除，采用<br>MP-AOF（Multi Part AOF），即多部件AOF。将原来的一个AOF变成了多个AOF，由manifest（追踪管理AOF文件）来管理。重写的时候还是fork一个子进程来对Base AOF重写</p><ul><li>Base AOF：重写之前的命令</li><li>Incr AOF：追加新的命令</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis线程模型</title>
      <link href="/posts/Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.html"/>
      <url>/posts/Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis线程是单线程还是多线程"><a href="#Redis线程是单线程还是多线程" class="headerlink" title="Redis线程是单线程还是多线程"></a>Redis线程是单线程还是多线程</h1><p>Redis核心处理一直都是单线程，但是其他处理模块也会有一些多线程、多进程的功能</p><ul><li>网络I&#x2F;O解包从6.0开始是多线程</li><li>某些异步流程从4.0开始用的是多进程，比如UNLIKE、FLUSHALL ASYNC等非阻塞的删除操作</li></ul><h1 id="Redis为什么用单线程做核心处理"><a href="#Redis为什么用单线程做核心处理" class="headerlink" title="Redis为什么用单线程做核心处理"></a>Redis为什么用单线程做核心处理</h1><ol><li>首先如果引用多线程，主要是希望利用多核的性能，但是Redis是内存k-v存储，一般不会很慢。真正影响Redis性能的是网络I&#x2F;O</li><li>其次多线程的上下文切换、同步机制开销等成本，会影响Redis的性能</li></ol><h1 id="Redis单线程性能如何"><a href="#Redis单线程性能如何" class="headerlink" title="Redis单线程性能如何"></a>Redis单线程性能如何</h1><p>性能很好，普通机器1s10多万的读性能，几万的写性能</p><p>redis-benchmark测试命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark -h 127.0.0.1 -p 6379 -t set,get -n 10000 -q</span><br></pre></td></tr></table></figure><h1 id="为什么Redis单线程性能还这么快"><a href="#为什么Redis单线程性能还这么快" class="headerlink" title="为什么Redis单线程性能还这么快"></a>为什么Redis单线程性能还这么快</h1><ul><li>基于内存操作：Redis是内存k-v存储</li><li>高效的数据结构：依赖String、List、Hash等高效的数据结构</li><li>采用单线程：没有多线程上下文切换、锁竞争等问题</li><li>I&#x2F;O多路复用：Redis的瓶颈在I&#x2F;O而不是CPU，多路复用同时监听多个socket，根据socket上的事件来选择对应的处理器进行处理</li></ul><h1 id="Redis6-0引入多线程是什么"><a href="#Redis6-0引入多线程是什么" class="headerlink" title="Redis6.0引入多线程是什么"></a>Redis6.0引入多线程是什么</h1><ul><li>Redis的瓶颈在I&#x2F;O而不是CPU，但随着互联网的发展，请求量巨大的时候单线程在同步读写I&#x2F;O的时间（读写客户端socket的I&#x2F;O），单核CPU也可能处理不过来。 因此针对核心处理流程中的解包、发包这两个CPU耗时操作，进行了多线程优化</li><li>Redis6.0多线程是默认关闭的，如果需要开启可以在redis.conf中修改。这么做的目的是首先为了兼容以前的，因为很多人认为Redis是单线程。其次是多线程不是必要的，大部分情况下够用</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Java线程池到阻塞队列</title>
      <link href="/posts/%E4%BB%8EJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html"/>
      <url>/posts/%E4%BB%8EJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h1><ul><li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li><li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行</li><li>方便管理线程：线程是稀缺资源，如果无条件地创建，不仅会消耗资源，还会降低线程的稳定性，使用线程池可以统一分配、调优和监考</li></ul><h1 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h1><p><img src="/img/%E4%BB%8EJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/img1.png" alt="alt text"></p><ul><li>corePoolSize：核心线程的数量</li><li>maximumPoolSize：线程池能创建的最大线程个数</li><li>keepAliveTime：空闲线程存活时间</li><li>unit：时间单位</li><li>workQueue：用于保存任务的阻塞队列</li><li>threadFactory：创建线程的工程类</li><li>hadler：饱和策略</li></ul><h1 id="常见线程池的区别以及特点"><a href="#常见线程池的区别以及特点" class="headerlink" title="常见线程池的区别以及特点"></a>常见线程池的区别以及特点</h1><p>newCachedThreadPool：</p><ul><li>特点：newCachedThreadPool创建一个可缓存的线程池，如果当前线程池的长度超过了处理的需要，它可以灵活的回收空闲的线程，当需要添加的时候可以灵活的添加</li><li>缺点：<strong>maximumPoolSize被设置为Inter.MAX_VALUE</strong>，可能会造成OOM</li></ul><p>newFixedThreadPool：</p><ul><li>特点：创建一个定长的线程池，可控制线程最大并发数，超出的任务会在线程中等待</li><li>缺点：线程数量是固定的，但是<strong>阻塞队列是LinkedBlockingQueue</strong>，是无界队列，也可能会造成OOM</li></ul><p>newScheduledThreadPool：</p><ul><li>特点：创建一个固定长度的线程，而且支持定时的以及周期性的任务执行，类似Timer</li><li>缺点：底层封装了<strong>PriorityQueue，同样是无界队列</strong>，可能会造成OOM</li></ul><p>newSingleThreadExecutor：</p><ul><li>特点：单线程化的线程池，它会用唯一的工作线程来执行任务。如果这个线程因为异常结束，那么会有一个新的线程来替代它。它必须保证前一项任务完成才能执行后一项。<strong>阻塞队列是LinkedBlockingQueue</strong>，因此是无界队列，会有OOM的风险</li><li>缺点：因为是单线程，高并发下有压力</li></ul><h1 id="为什么我们不用Executors默认创建线程池的方法，而直接自己手动去调用ThreadPoolExecutor去创建线程池"><a href="#为什么我们不用Executors默认创建线程池的方法，而直接自己手动去调用ThreadPoolExecutor去创建线程池" class="headerlink" title="为什么我们不用Executors默认创建线程池的方法，而直接自己手动去调用ThreadPoolExecutor去创建线程池"></a>为什么我们不用Executors默认创建线程池的方法，而直接自己手动去调用ThreadPoolExecutor去创建线程池</h1><p>Executors 返回的线程池对象的弊端如下：</p><ul><li>newFixedThreadPool 和 newSingleThreadPool: LinkedBlockingQueue无界队列，允许的请求队列长度为 Integer.MAX_VALUE(无界队列)，可能会堆积大量的请求，从而导致 OOM</li><li>newCachedThreadPool: 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM</li><li>newScheduledThreadPool：同样使用无界队列（底层是PriorityQueue），也会堆积大量请求导致OOM</li></ul><h1 id="线程池的饱和策略有哪些"><a href="#线程池的饱和策略有哪些" class="headerlink" title="线程池的饱和策略有哪些"></a>线程池的饱和策略有哪些</h1><ul><li>ThreadPoolExecutor.AbortPolicy：抛出RejectedExecutionException来拒绝任务的处理</li><li>ThreadPoolExecutor.CallerRunsPolicy：调用提交任务的线程运行任务（比如A提交线程，A运行任务）。但是会降低新任务提交速度，影响程序的整体性能</li><li>ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃掉最早的未处理的任务</li></ul><h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><ol><li>判断线程池的核心线程数是不是已满，如果不是则创建一个新的工作线程来执行任务。</li><li>如果核心线程数已满，则将提交的任务放在保存任务的阻塞队列中。</li><li>如果工作任务队列满了，则创建一个新的线程来执行任务，直到数量到达maximumPoolSize</li><li>最后如果达到线程池最大线程数，则采取对应的饱和策略</li></ol><h1 id="线程池中execute-和submit-方法有什么区别"><a href="#线程池中execute-和submit-方法有什么区别" class="headerlink" title="线程池中execute()和submit()方法有什么区别"></a>线程池中execute()和submit()方法有什么区别</h1><p>相同点：</p><ul><li>都可以提交任务到线程池中</li></ul><p>不同点：</p><ul><li>接受参数：execute只能执行Runnable类型的任务，submit可以执行Runnable和Callable类型的任务</li><li>返回值：submit方法可以返回持有计算结果的Future对象，而execute没有</li><li>异常处理：submit可以方便处理异常</li></ul><h1 id="Java中Executor、Executors和ExecuteService的区别"><a href="#Java中Executor、Executors和ExecuteService的区别" class="headerlink" title="Java中Executor、Executors和ExecuteService的区别"></a>Java中Executor、Executors和ExecuteService的区别</h1><ul><li>Executor是最基本的接口，只定义了一个execute方法</li><li>ExecuteService是一个高级的接口，实现了Executor并进行了扩展,比如实现了submit方法。这个接口的目的是方便我们使用底层不同的线程池，类似List接口，屏蔽底层差异</li><li>Executors是一个工具类，使用这个工具类可以方便的创建线程。让我们可以不用手动地指定线程池的各个参数，比如Executors.newFixedThreadPool(10)</li></ul><h1 id="线程池有哪些状态"><a href="#线程池有哪些状态" class="headerlink" title="线程池有哪些状态"></a>线程池有哪些状态</h1><p><img src="/img/%E4%BB%8EJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/img2.png" alt="alt text"></p><ul><li>Running:正常状态，可以接受其他线程</li><li>Shutdown：不接受新的任务提交，但是会继续处理等待队列中的任务</li><li>Stop：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li><li>Tidying：所有的任务都销毁，workerCount（线程数量）为0，线程池在向Tidying状态转换时，会执行钩子方法terminated()</li><li>Terminated：terminated()方法介绍后，就会变成这个</li></ul><h1 id="如何合理分配线程池大小——线程池应对IO密集型和CPU密集型的策略"><a href="#如何合理分配线程池大小——线程池应对IO密集型和CPU密集型的策略" class="headerlink" title="如何合理分配线程池大小——线程池应对IO密集型和CPU密集型的策略"></a>如何合理分配线程池大小——线程池应对IO密集型和CPU密集型的策略</h1><ul><li>CPU密集型：也叫计算密集型，其处理器占用率高，也许在某段时间内保持100%占用率。线程配置数大概和CPU核数相当，这样可以使得每个线程在执行任务</li><li>IO密集型：大部分的状况是CPU在等I&#x2F;O (硬盘&#x2F;内存) 的读&#x2F;写操作，但CPU的使用率不高。大部分线程在阻塞，故需要多配置线程数，2 * cpu核数</li></ul><h1 id="线程池如何实现动态修改"><a href="#线程池如何实现动态修改" class="headerlink" title="线程池如何实现动态修改"></a>线程池如何实现动态修改</h1><p>线程池提供了部分setter方法可以设置线程池的参数：</p><ul><li>修改线程数，最大线程数，空闲线程停留时间，拒绝策略等</li><li>可以将线程池的配置参数放入配置中心，然后直接在配置中心修改</li></ul><p>什么时候需要修改？</p><ol><li>需要监考报警策略，获取线程池状态指标，当指标判定为异常后再报警</li><li>分析指标原因，评估策略，然后通过上述线程池提供的接口进行修改</li></ol><h1 id="既然线程池中使用了阻塞队列，那么什么是阻塞队列，阻塞队列有哪些"><a href="#既然线程池中使用了阻塞队列，那么什么是阻塞队列，阻塞队列有哪些" class="headerlink" title="既然线程池中使用了阻塞队列，那么什么是阻塞队列，阻塞队列有哪些"></a>既然线程池中使用了阻塞队列，那么什么是阻塞队列，阻塞队列有哪些</h1><p>阻塞队列支持两个阻塞的插入和删除操作</p><ul><li>支持阻塞的插入put方法：当队列满的时候，队列会阻塞插入元素的线程，直到队列不满</li><li>支持阻塞的移除take方法：当队列为空的时候，队列会阻塞移除元素的线程，直到队列不为空</li></ul><p>阻塞队列：</p><ul><li>ArrayBlockingQueue：底层使用数组结构，创建时必须指定大小，是有界的</li><li>LinkedBlockingQueue：底层使用链表结构，创建时默认大小是Inter.MAX_VALUE，因此是无界的。也可以指定大小成为有界</li><li>PriorityBlockingQueue：一个支持优先级排列的队列，可重写自定义类的compareTo方法来指定排序规则</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列，使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，表示指定多久才能从队列中获得元素</li><li>SynchronousQueue：一个不存储元素的队列，每一次put必须等待一个take操作，否则不能添加元素。适用于传递性场景</li><li>LinkedTransferQueue：一个由链表结构组成的无界队列，设计了一种生产者和消费者之间传递的机制，称为”transfer“。当生产者调用transfer（e）方法时，它会阻塞直到一个消费者接收该元素</li><li>LinkedBlockingDeque：一个由链表结构组成的双端队列</li></ul><h1 id="ArrayBlockingQueue和LinkedBlockingQueue的区别"><a href="#ArrayBlockingQueue和LinkedBlockingQueue的区别" class="headerlink" title="ArrayBlockingQueue和LinkedBlockingQueue的区别"></a>ArrayBlockingQueue和LinkedBlockingQueue的区别</h1><ul><li>底层实现：ArrayBlockingQueue基于数组，LinkedBlockingQueue基于链表</li><li>是否有界：ArrayBlockingQueue有界，LinkedBlockingQueue创建时可以指定大小，默认是Integer.MAX_VALUE，无界</li><li>锁是否分离：ArrayBlockingQueue中的锁不分离，生产者和消费者使用同一把锁。LinkedBlockingQueue的锁分离，生产者使用的是putLock，消费者使用的是takeLock，这样可以防止生产者和消费者之间竞争锁</li><li>内存占用：ArrayBlockingQueue需要提前分配内存，LinkedBlockingQueue是动态分配内存，会不断占用空间</li></ul><h1 id="ArrayBlockingQueue底层源码"><a href="#ArrayBlockingQueue底层源码" class="headerlink" title="ArrayBlockingQueue底层源码"></a>ArrayBlockingQueue底层源码</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Object[] items;  <span class="comment">//队列的底层为数组，是个循环数组</span></span><br><span class="line"><span class="type">int</span> takeIndex;  <span class="comment">//从队列中取元素的索引，用于take、poll、remove</span></span><br><span class="line"><span class="type">int</span> putIndex;  <span class="comment">//向队列中存放元素的索引，用于put、offer、add</span></span><br><span class="line"><span class="type">int</span> count;  <span class="comment">//队列中的元素数</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock; <span class="comment">//队列中的锁机制，可重入锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;   <span class="comment">//notEmpty条件对象，由lock创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;  <span class="comment">//notFull条件对象，由lock创建</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">Itrs</span> <span class="variable">itrs</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">//迭代器对象</span></span><br></pre></td></tr></table></figure><h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><h3 id="add-E-e-（非阻塞方法）"><a href="#add-E-e-（非阻塞方法）" class="headerlink" title="add(E e)（非阻塞方法）"></a>add(E e)（非阻塞方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*调用了offer(e)方法，成功，返回true，失败，抛出IllegalStateException异常*/</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (offer(e)) </span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Queue full&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在当前put位置插入元素、前进和信号</span></span><br><span class="line"><span class="comment">   * Call only when holding lock. 只有在持有锁资源时才调用该方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(E x)</span> &#123;</span><br><span class="line">      <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">      <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">      <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items; <span class="comment">//将队列数组初始化</span></span><br><span class="line">      items[putIndex] = x;  <span class="comment">//将元素添加到数组里</span></span><br><span class="line">      <span class="keyword">if</span> (++putIndex == items.length)  <span class="comment">//如果将要插入的元素索引等于数组的长度，将存放元素的索引重新置为0</span></span><br><span class="line">          putIndex = <span class="number">0</span>;</span><br><span class="line">      count++;</span><br><span class="line">      notEmpty.signal();   <span class="comment">//使用条件对象notEmpty通知，唤醒当前等待的线程</span></span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Throws NullPointerException if argument is null.</span></span><br><span class="line"><span class="comment">    *如果参数为null，则抛出NullPointerException的异常</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> v the element</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkNotNull</span><span class="params">(Object v)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (v == <span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="put-E-e-（阻塞方法）"><a href="#put-E-e-（阻塞方法）" class="headerlink" title="put(E e)（阻塞方法）"></a>put(E e)（阻塞方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将指定的元素插入到此队列的末尾，然后等待</span></span><br><span class="line"><span class="comment">    * for space to become available if the queue is full.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       checkNotNull(e); <span class="comment">//判断元素是否为null</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;  <span class="comment">//初始化重入锁</span></span><br><span class="line">       lock.lockInterruptibly(); <span class="comment">//加锁，以保证在调用put方法时只有一个线程</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (count == items.length) <span class="comment">//当队列满了，阻塞当前线程，并加入到条件对象notFull的等待队列里面</span></span><br><span class="line">               notFull.await(); <span class="comment">//线程阻塞并被挂起，同时释放锁资源</span></span><br><span class="line">           enqueue(e); <span class="comment">//调用enqueue方法</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();  <span class="comment">//释放锁，让其他线程可以调用put方法</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="offer-E-e-（添加方法的具体实现）"><a href="#offer-E-e-（添加方法的具体实现）" class="headerlink" title="offer(E e)（添加方法的具体实现）"></a>offer(E e)（添加方法的具体实现）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       checkNotNull(e); <span class="comment">//检查队列中的元素是否为空。在这里不允许为空</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock; <span class="comment">//引入重入锁</span></span><br><span class="line">       lock.lock(); <span class="comment">//加锁，保证调用offer时只有一个线程</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (count == items.length)  <span class="comment">//如果当前元素的个数等于队列数组的长度，说明队列是满的，添加失败</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">           <span class="keyword">else</span> &#123;<span class="comment">//否则队列不满，调用enqueue(e)方法添加元素，返回true</span></span><br><span class="line">               enqueue(e);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;<span class="comment">//最后，释放锁，让其他线程可以调用offer方法</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h2><h3 id="poll-（非阻塞方法）"><a href="#poll-（非阻塞方法）" class="headerlink" title="poll()（非阻塞方法）"></a>poll()（非阻塞方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock; <span class="comment">//引入重用锁</span></span><br><span class="line">       lock.lock();  <span class="comment">//加锁，以保证当前只有一个线程</span></span><br><span class="line">       <span class="keyword">try</span> &#123;<span class="comment">//如果队列为空，则返回null；否则，调用dequeue方法</span></span><br><span class="line">           <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="literal">null</span> : dequeue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock(); <span class="comment">//释放锁资源，让其他线程可以调用poll方法</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="take-（阻塞方法）"><a href="#take-（阻塞方法）" class="headerlink" title="take()（阻塞方法）"></a>take()（阻塞方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();<span class="comment">//加锁，以保证在调用take()方法时只有一个线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">//当队列中元素个数为1，即队列为空时 </span></span><br><span class="line">            notEmpty.await(); <span class="comment">//阻塞当前线程，并加入到条件对象notEmpty的等待队列里</span></span><br><span class="line">        <span class="keyword">return</span> dequeue(); <span class="comment">//调用dequeue()方法</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">//释放锁，让其他线程可以调用take()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-Object-obj-（删除指定元素）"><a href="#remove-Object-obj-（删除指定元素）" class="headerlink" title="remove(Object obj)（删除指定元素）"></a>remove(Object obj)（删除指定元素）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 从队列中删除指定的元素。如果该元素存在，则将该元素从队列中删除，返回true；如果不存在，则返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果指定删除的元素为null，则返回false</span></span><br><span class="line">        <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items; <span class="comment">//阻塞队列数组</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock; <span class="comment">//重入锁</span></span><br><span class="line">        lock.lock(); <span class="comment">//加锁，以此保证在调用该remove方法时只有一个线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;<span class="comment">//如果队列不为空</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">putIndex</span> <span class="operator">=</span> <span class="built_in">this</span>.putIndex; <span class="comment">//往队列中即将要存储的元素的下标</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> takeIndex; <span class="comment">//从队列即将要取出元素的下标</span></span><br><span class="line"><span class="comment">//循环遍历阻塞队列中的元素，如果在队列中找到了要删除的元素，则将该元素删除，返回true;否则，返回false。</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (o.equals(items[i])) &#123; <span class="comment">//</span></span><br><span class="line">                        removeAt(i);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (++i == items.length)</span><br><span class="line">                        i = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">while</span> (i != putIndex);<span class="comment">//结束条件为当前元素索引==最后将要存入队列中的元素的下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();<span class="comment">//释放锁资源，让其他线程可以调用remove(e)方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="deque-（poll、take的具体实现）"><a href="#deque-（poll、take的具体实现）" class="headerlink" title="deque()（poll、take的具体实现）"></a>deque()（poll、take的具体实现）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Extracts element at current take position, advances, and signals.提取元素当前的位置、进展和信号</span></span><br><span class="line"><span class="comment">   * Call only when holding lock.在持有锁时才调用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">      <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">      <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;<span class="comment">//阻塞队列数组</span></span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex];<span class="comment">//用变量x记录当前要取出的元素</span></span><br><span class="line">      items[takeIndex] = <span class="literal">null</span>;<span class="comment">//将该元素置为null</span></span><br><span class="line">      <span class="keyword">if</span> (++takeIndex == items.length)<span class="comment">//判断是否是最后一个元素</span></span><br><span class="line">          takeIndex = <span class="number">0</span>; <span class="comment">//如果是，将取元素索引置为0，从头开始取</span></span><br><span class="line">      count--;<span class="comment">//元素个数-1</span></span><br><span class="line">      <span class="keyword">if</span> (itrs != <span class="literal">null</span>) <span class="comment">//迭代遍历队列，</span></span><br><span class="line">          itrs.elementDequeued();</span><br><span class="line">      notFull.signal();<span class="comment">// 使用条件对象notFull通知，比如使用put方法放数据的时候队列已满，被阻塞。这个时候消费了一条数据，队列没满了，就需要调用signal进行通知  </span></span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="LinkedBlockingQueue底层源码"><a href="#LinkedBlockingQueue底层源码" class="headerlink" title="LinkedBlockingQueue底层源码"></a>LinkedBlockingQueue底层源码</h1><h2 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E item;  <span class="comment">//元素</span></span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//next指针</span></span><br><span class="line">        </span><br><span class="line">        Node(E x) &#123;  <span class="comment">//有参构造函数</span></span><br><span class="line">          item = x;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;  <span class="comment">//容量，默认为 Integer.MAX_VALUE</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();  <span class="comment">//队列中元素的数量</span></span><br><span class="line">        <span class="keyword">transient</span> Node&lt;E&gt; head;  <span class="comment">//头节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;  <span class="comment">//尾节点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">//拿锁</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();  <span class="comment">//拿锁的条件，队列不为空</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();  <span class="comment">//放锁</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();  <span class="comment">//放锁的条件</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="添加方法-1"><a href="#添加方法-1" class="headerlink" title="添加方法"></a>添加方法</h2><h3 id="add-E-e-（非阻塞方法）-1"><a href="#add-E-e-（非阻塞方法）-1" class="headerlink" title="add(E e)（非阻塞方法）"></a>add(E e)（非阻塞方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put-E-e-（阻塞方法）-1"><a href="#put-E-e-（阻塞方法）-1" class="headerlink" title="put(E e)（阻塞方法）"></a>put(E e)（阻塞方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();<span class="comment">//判断添加的元素是否为null，如果为Null，抛出NullPointerException异常</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>; </span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e); <span class="comment">//构造新的结点</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock; <span class="comment">//放锁</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count; <span class="comment">//元素的个数</span></span><br><span class="line">        putLock.lockInterruptibly(); <span class="comment">//放锁加锁，保证在调用put方法的时候只有1个线程 </span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123;<span class="comment">//如果队列为满</span></span><br><span class="line">                notFull.await();<span class="comment">//阻塞并挂起当前线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            enqueue(node);<span class="comment">//将元素添加到链表的尾部</span></span><br><span class="line">            c = count.getAndIncrement(); <span class="comment">//元素个数+1</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity) <span class="comment">//如果队列的容量还没有满</span></span><br><span class="line">                notFull.signal(); <span class="comment">//在notFull对象上唤醒正在等待的1个线程，表示队列中还有元素可以消费</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock(); <span class="comment">//释放放锁，让其他线程可以调用该put方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)<span class="comment">//由于存在放锁和拿锁，这里可能拿锁一直在消费数据，count会变化。这里的if条件表示如果队列中还有1条数据 </span></span><br><span class="line">            signalNotEmpty();<span class="comment">//在拿锁的条件对象notEmpty上唤醒正在等待的1个线程，表示队列里还有1条数据，可以进行消费 </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//enqueue(Node&lt;E&gt; node)（上面方法用到）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> &#123;</span><br><span class="line">        <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">        <span class="comment">// assert last.next == null;</span></span><br><span class="line">        last = last.next = node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="offer-E-e-（添加方法的具体实现，分为offerFirst和OfferLast）"><a href="#offer-E-e-（添加方法的具体实现，分为offerFirst和OfferLast）" class="headerlink" title="offer(E e)（添加方法的具体实现，分为offerFirst和OfferLast）"></a>offer(E e)（添加方法的具体实现，分为offerFirst和OfferLast）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> linkFirst(node);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> linkLast(node);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除方法-1"><a href="#删除方法-1" class="headerlink" title="删除方法"></a>删除方法</h2><h3 id="poll-（非阻塞方法）-1"><a href="#poll-（非阻塞方法）-1" class="headerlink" title="poll()（非阻塞方法）"></a>poll()（非阻塞方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count; <span class="comment">//队列中元素的个数</span></span><br><span class="line">      <span class="keyword">if</span> (count.get() == <span class="number">0</span>) <span class="comment">//判断该队列是否为空</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//如果为空，返回null</span></span><br><span class="line">      <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//定义要返回的元素的变量名，初始化为Null</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;<span class="comment">//拿锁</span></span><br><span class="line">      takeLock.lock();<span class="comment">//拿锁加锁，以保证在调用poll()线程的时候只有1个线程</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;<span class="comment">//判断队列是否为空。如果不为空</span></span><br><span class="line">              x = dequeue();<span class="comment">//删除头节点</span></span><br><span class="line">              c = count.getAndDecrement();<span class="comment">//元素个数-1</span></span><br><span class="line">              <span class="keyword">if</span> (c &gt; <span class="number">1</span>)<span class="comment">//如果队列中还有元素</span></span><br><span class="line">                  notEmpty.signal();<span class="comment">//在拿锁的条件对象notEmpty上唤醒正在等待的线程，表示队列里还有数据，可以再次消费 </span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          takeLock.unlock();<span class="comment">//释放拿锁资源，让其他线程可以调用该poll()方法</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (c == capacity)<span class="comment">//由于存在放锁和拿锁，这里可能放锁一直在添加数据，count会变化。这里的if条件表示如果队列中还可以再插入数据 </span></span><br><span class="line">          signalNotFull();<span class="comment">//在放锁的条件对象notFull上唤醒正在等待的1个线程，表示队列里还能再次添加数据 </span></span><br><span class="line">      <span class="keyword">return</span> x;<span class="comment">//返回删除的元素</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="take-（阻塞方法）-1"><a href="#take-（阻塞方法）-1" class="headerlink" title="take()（阻塞方法）"></a>take()（阻塞方法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count; <span class="comment">//队列中元素的个数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;  <span class="comment">//拿锁</span></span><br><span class="line">    takeLock.lockInterruptibly();  <span class="comment">//拿锁加锁，以保证在调用take()方法的时候只有一个线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123; <span class="comment">//如果队列为空</span></span><br><span class="line">            notEmpty.await(); <span class="comment">//则将当前线程阻塞并挂起</span></span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue(); <span class="comment">//否则，删除头节点</span></span><br><span class="line">        c = count.getAndDecrement();  <span class="comment">//元素个数-1</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)  <span class="comment">//判断队列中是否还有元素</span></span><br><span class="line">            notEmpty.signal(); <span class="comment">//如果有，在拿锁的条件对象notEmpty上唤醒正在等待的线程，表示队列里还有数据，可以再次消费 </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock(); <span class="comment">//释放拿锁，以保证其他线程可以调用take()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity) <span class="comment">//表示如果队列中还可以再插入数据 </span></span><br><span class="line">        signalNotFull(); <span class="comment">//在放锁的条件对象notFull上唤醒正在等待的1个线程，表示队列里还能再次添加数据 </span></span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">//返回删除的那个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-Object-o-（删除指定元素）"><a href="#remove-Object-o-（删除指定元素）" class="headerlink" title="remove(Object o)（删除指定元素）"></a>remove(Object o)（删除指定元素）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//如果要删除的元素为null，返回false</span></span><br><span class="line">    fullyLock(); <span class="comment">//remove操作要移动的位置不固定，2个锁都需要加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;</span><br><span class="line">             p != <span class="literal">null</span>;</span><br><span class="line">             trail = p, p = p.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123;<span class="comment">//判断在队列中是否能找到要删除的对象</span></span><br><span class="line">                unlink(p, trail);<span class="comment">//修改节点的链接信息，同时调用notFull的signal方法 ，唤醒等待的线程</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果没有找到，返回false</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fullyUnlock();<span class="comment">//2个锁解锁 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove()方法中的加锁方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fullyLock</span><span class="params">()</span> &#123;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    takeLock.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove()方法中的解锁方法</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fullyUnlock</span><span class="params">()</span> &#123;</span><br><span class="line">    takeLock.unlock();</span><br><span class="line">    putLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deque-（poll、take的具体实现）-1"><a href="#deque-（poll、take的具体实现）-1" class="headerlink" title="deque()（poll、take的具体实现）"></a>deque()（poll、take的具体实现）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert head.item == null;</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    head = first;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;</span><br><span class="line">    first.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构和数据类型</title>
      <link href="/posts/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"/>
      <url>/posts/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>在Redis中有一个核心的对象叫做redisObject ，是用来表示所有的key和value的，用redisObject结构体来表示String、Hash、List、Set、ZSet五种数据类型</p><p><img src="/img/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/img1.png" alt="alt text"></p><p>key和value指向的是<strong>redisObject</strong>对象</p><p><img src="/img/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/img2.png" alt="alt text"></p><ul><li>type：标识该对象用的是什么类型（String、List)</li><li>encoding：编码方式</li></ul><h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><h2 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h2><p><img src="/img/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/img3.png" alt="alt text"></p><p>属性：</p><ul><li>len：记录了字符串长度，因此获取字符串长度的时候时间复杂度O(1)</li><li>alloc：分配给字符数组的空间长度。这样在修改字符串的时候，只需要alloc-len来判断剩余空间大小，可以用来判断空间是否满足修改条件，如果不满足就会将SDS扩容。因此不会出现C语言的缓冲区溢出问题</li><li>flags：用来表示不同类型的SDS，表示len和alloc的类型不同，进而保存的SDS分配给字节数组的大小不同</li><li>buf[]：字节数组，用来保存实际数据。不仅可以保存文本数据，还可以保存二进制数据</li></ul><p>Redis底层由C语言实现，那么SDS与C语言字符串对比：</p><ul><li>O(1)获得字符串长度：因为SDS有len属性</li><li>二进制安全：SDS不仅可以保存文本数据，还能保存二进制数据。SDS的使用len属性来判断是否遍历完成，不会管’\0’的字符</li><li>不会发生缓冲区溢出：通过alloc-len来判断剩余空间大小，可以用来判断空间是否满足修改条件，如果不满足就会将SDS扩容。因此不会出现C语言的缓冲区溢出问题</li></ul><p>扩容机制：</p><ul><li>如果所需的SDS长度小于1MB,则翻倍 + 1</li><li>如果所需的SDS长度超过1MB,最后的扩容大小应该是newlen + 1MB + 1</li></ul><h2 id="Ziplist（压缩列表）"><a href="#Ziplist（压缩列表）" class="headerlink" title="Ziplist（压缩列表）"></a>Ziplist（压缩列表）</h2><p><img src="/img/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/img4.png" alt="alt text"></p><p>ziplist构成：</p><ul><li>zlbytes：整个压缩列表占用内存字节数</li><li>zltail：压缩表尾部节点距离起始地址多少个字节，也就是列表尾的偏移量</li><li>zllen：entry节点的个数</li><li>entry：存储数据的部分</li><li>zlend：压缩列表的结束点，固定在0xFF</li></ul><p>entry构成：</p><ul><li>prevlen：前一个节点的长度，目的是实现从后往前遍历</li><li>encoding：记录当前节点实际的类型和长度，类型主要是字符串和整数   </li><li>data：记录当前节点的实际存储数据，类型和长度由encoding决定</li></ul><p>encdoing构成：</p><ul><li>如果当前数据是整数，需要1字节</li><li>如果当前的数据是字符串，会根据需要使用1、2、5字节的空间</li></ul><p>连续更新问题：<br>压缩列表新增某一个元素或者修改某一个元素，如果空间不够，压缩列表占用的内存空间需要重新分配。当更新的元素较大，会导致后续的prevlen也都要重新分配，从而引起连锁更新的问题</p><h2 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h2><p>在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现</p><p><img src="/img/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/img5.png" alt="alt text"></p><p>quicklist就是<strong>双向链表+ziplist</strong>的组合，quicklist链表中的每一个节点是一个压缩列表</p><p>解决连锁更新：通过控制链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越小，连锁更新带来的影响就越小，从而性能提升</p><h2 id="dictht（哈希表）"><a href="#dictht（哈希表）" class="headerlink" title="dictht（哈希表）"></a>dictht（哈希表）</h2><p>属性：</p><ul><li>dictEntry **table：数组的每一个元素是指向哈希表节点的指针</li><li>size：哈希表大小</li><li>sizemask：掩码，用于计算索引值</li><li>used：哈希表已有的entry个数</li></ul><p>哈希冲突：</p><ul><li>当两个key不同，但是索引值相同，就会发生冲突</li></ul><p>哈希冲突解决（拉链法）：</p><ul><li>被分配到同一个哈希桶上的多个节点用一个单项链表连接起来</li><li>但是也有缺点，当链表长度过长的时候，查询效率很低</li></ul><p>rehash解决链表长度过长：</p><ol><li>给哈希表2分配空间，一般比哈希表1大一倍</li><li>将哈希表1数据迁移到哈希表2</li><li>迁移完成后，哈希表1的空间释放，并把哈希表2设置为哈希表1，然后在新哈希表2创建出一个空白的哈希表，为下次rehash做准备</li></ol><p>渐进式rehash解决rehash迁徙过程耗时久：</p><ol><li>给哈希表2分配空间，一般比哈希表1大一倍</li><li>在rehash期间，每次哈希表元素新增、删除、查找的时候，Redis会执行对应的操作外，还会将哈希表1中索引位置上的所有dictEntry迁移到哈希表2。查找，更新操作会在两个哈希表上进行。redis会先尝试在 ht[0] 中寻找目标键值对，如果没有找到则会在 ht[1] 再次寻找。但是新增操作就不一样了，新增key只会在新的哈希表 ht[1] 上进行，为的是确保 ht[0] 中的已经被清空的单向链表不会新增元素。在 rehash 被触发后，即使没有收到新请求，Redis 也会定时执行一次 rehash 操作，而且，每次执行时长不会超过 1ms，以免对其他任务造成影响</li><li>迁移完成后，哈希表1的空间释放，并把哈希表2设置为哈希表1，然后在新哈希表2创建出一个空白的哈希表，为下次rehash做准备</li></ol><p>rehash触发条件：</p><ul><li>负载因子 &#x3D; 哈希表已保存的节点数量 &#x2F; 哈希表大小</li><li>当负载因子大于等于1，并且redis没有进行RDB快照和AOF重写的时候，进行rehash</li><li>当负载因子大于等于5，说明哈希冲突非常严重，不管也没用RDB快照和AOF重写，都会强制执行rehash</li></ul><h2 id="intset（整数集合）"><a href="#intset（整数集合）" class="headerlink" title="intset（整数集合）"></a>intset（整数集合）</h2><p>属性：</p><ul><li>encoding：编码方式，比如 INTSET_ENC_INT16，那么contents就是一个int16_t类型的数组</li><li>length：集合包含的元素数量</li><li>contents：虽然被声明为 int8_t 类型，但是实际上是由保存的数据大小由encoding决定</li></ul><p>整数集合升级规则：</p><ul><li>当我们将一个新元素加入集合中，如果新元素的类型(int32_t)比现有元素的类型(int16_t)都要长，需要扩宽contents数组的大小。比如现在有3个类型为int16_t的元素，每个都是16位长度，然后往整数集合里面加入一个新元素65535，这个新元素类型用int32_t保存，然后对contents扩容，会在原本的空间的大小之上多出80位（4 * 32 - 3 * 16 &#x3D; 80），这样就能保证可以存下4个int32_t的元素</li><li>扩容完 contents 数组空间大小后，需要将之前的三个元素转换为 int32_t 类型，并将转换后的元素放置到正确的位上面，并且需要维持底层数组的有序性不变：从后往前依次填充，最后再把65535这个元素放到数组末尾</li></ul><p>整数集合升级优点：</p><ul><li>如果让一个数组保存int16_t、int32_t、int64_t的元素，最好的方式就是用int64_t类型，但是会造成空间的浪费。</li><li>整数升级保证了我们只需要int64_t类型的元素再进行扩容，因此可以节约资源内存</li></ul><p>最后，整数集合不支持降级 </p><h2 id="zkplist（跳表）"><a href="#zkplist（跳表）" class="headerlink" title="zkplist（跳表）"></a>zkplist（跳表）</h2><p><img src="/img/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/img6.png" alt="alt text"></p><p>ziplist属性：</p><ul><li>跳表的头尾节点head，tail（指向ziplistNode）</li><li>跳表的长度length</li><li>跳表的最大层数level</li></ul><p>ziplistNode属性：</p><ul><li>ele：SDS结构存储数据</li><li>score：节点的分数，浮点型</li><li>backward：指向上一个节点的回退指针，支持从表尾向表头遍历，也就是ZREVRANGE命令</li><li>level：是个zskiplistLevel数组，zskiplistLevel包含了两个字段，一个是forward，指向下一层能调到哪个节点，span记录了距离下个节点的步数。数据结构就表示每个节点是个多层结构</li></ul><p>跳表节点层数设置：</p><ul><li>跳表的相邻两层的节点数量最理想的比例是 2:1，查找复杂度可以降低到 O(logN)</li><li>Redis在创建节点的时候，会生成范围为[0, 1]的随机数，如果这个随机数小于0.25（相当于概率25%），那么层数就增加一层。然后继续生成下一个随机数，直到随机数的结构大于0.25就结束</li><li>这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64</li></ul><p>为什么用跳表而不用平衡树？</p><ul><li>从内存占用上，跳表比平衡树更灵活：平衡树每个节点包含2个指针，跳表每个节点包含的指针数目为1&#x2F;（1-p），在redis中p&#x3D;0.25，平均每个节点包含1.33个指针，内存占用更少</li><li>在做范围查询的时候，跳表比平衡树操作更简单：在平衡树中我们找到特定范围的最小值后，还需要以中序遍历的顺序寻找其他不超过大值的节点，所以中序遍历不容易实现。而跳表就很简单，只需要找到最小值后，对第一层的节点进行若干步的遍历即可</li><li>在算法实现难度上，跳表更简单。平衡树的插入和删除操作可能引发子树的调整，子树逻辑复杂。而跳表的插入和删除只需要修改相邻的节点，操作简单又迅速</li></ul><h2 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h2><p><img src="/img/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/img7.png" alt="alt text"></p><p>listpack entry构成：</p><ul><li>encoding：定于元素的编码类型，会对不同长度的整数和字符串进行编码</li><li>data：实际存放的数据</li><li>len：encdong+data的总长度</li></ul><p>将prevlen改成len之后能不能从后往前遍历？</p><ul><li>答案是可以。lpDecodeBacklen函数已经实现了</li></ul><h1 id="Redis数据对象"><a href="#Redis数据对象" class="headerlink" title="Redis数据对象"></a>Redis数据对象</h1><p><img src="/img/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/img8.png" alt="alt text"></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>字符串对象的内部编码（encoding）有 3 种 ：int、raw和embstr：</p><ul><li>int：如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型表示，那么这个字符串对象会被保存在redisObject对象的<strong>prt</strong>中，同时将encoding设置成int</li><li>embstr(Embedded string 嵌入式字符串)：如果一个字符串对象保存的是字符串，并且这个字符串对象小于等于32字节。那么字符串对象将用<strong>SDS</strong>表示，同时encoding设置成embstr</li><li>raw：如果一个字符串对象保存的是字符串，并且这个字符串对象大于32字节。那么字符串对象将用<strong>SDS</strong>表示，同时encoding设置成raw</li></ul><p>embstr和raw的区别：</p><ul><li>embstr和raw都会用SDS来保存值。</li><li>embstr会通过一次内存分配函数来分配一块连续的内存空间来保存redisObject和SDS</li><li>而raw编码会调用两次内存分配函数分别分配redisObject和SDS</li></ul><p>embstr相比raw好处：</p><ul><li>embstr编码创建字符串对象只用调用一次内存分配函数，而raw编码需要两次</li><li>释放embstr编码的字符串对象同样也只需要调用一次内存释放函数</li><li>因为embstr编码的字符串对象的所有数据都保存在一块连续的内存空间，可以更好的利用cpu缓存提升性能</li></ul><p>embstr的缺点：</p><ul><li>如果字符串的长度需要重新分配空间时，整个redisObject和sds都需要重新分配空间，所以embstr编码的字符串对象实际上是只读的。redis没有为embstr编码的字符串对象编写任何修改的程序。当我们对embstr编码的字符串对象执行修改的命令，实际上是先将编码从embstr转换成raw，再做修改</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>3.2版本之前是双向链表和压缩列表：</p><ul><li>如果列表中的元素小于512个，列表每个元素的值都小于64字节，redis会用ziplist存储</li><li>否则用双向链表</li></ul><p>3.2版本之后： 统一用quicklist</p><p>7.0版本之后，统一用listpack</p><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><ul><li>如果哈希类型元素个数小于512个，并且所有值小于64字节，Redis会用ziplist（7.0版本开始采用listpack）底层数据结构</li><li>否则用哈希表</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li>如果集合中的元素都是整数且元素个数小于512使用整数集合</li><li>否则用哈希表</li></ul><h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><ul><li>如果有序集合元素小于128个，并且每个元素大小小于64字节，使用ziplist（7.0版本开始采用listpack）</li><li>否则用skiplist</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/posts/JVM.html"/>
      <url>/posts/JVM.html</url>
      
        <content type="html"><![CDATA[<p>The Java Virtual Machine (JVM) is a crucial component of the Java programming language. It is an abstract computing machine that enables a computer to run Java programs. The JVM is platform-independent, meaning it can run on any device or operating system that has a compatible JVM implementation</p><p>总的来说，分为五部分：程序计数器，虚拟机栈，本地方法栈，方法区，堆<br><img src="/img/JVM/img1.png" alt="alt text"></p><h1 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h1><h2 id="什么是程序计数器"><a href="#什么是程序计数器" class="headerlink" title="什么是程序计数器"></a>什么是程序计数器</h2><p>程序计数器：是线程私有的，记录当前虚拟机正在执行的线程指令地址。首先实现了代码的基本控制流程，比如顺序、选择、循环等，其次是因为记录了当前线程指令地址，在当前线程下次被切换回来时，可以知道它上次执行到的位置</p><h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="虚拟机栈是什么"><a href="#虚拟机栈是什么" class="headerlink" title="虚拟机栈是什么"></a>虚拟机栈是什么</h2><ul><li>虚拟机栈：由很多栈帧组成（一个方法有一个栈帧），每个栈帧包含：局部变量表、操作数栈、动态链接、返回地址等信息</li><li>局部变量表：存储当前方法参数和当前方法内部 的局部变量。局部变量表的最小容量用变量槽来表示，其中64位长度的long和double会占用两个变量槽。如果执行的是实例方法，那么当前第0个变量槽存放的是用于传递方法所属对象实例的引用，在方法中可以用“this”来访问。此外，还通过变量槽复用达到减少内存空间的使用，比如当前PC计数器超出的这个变量的作用域，那么这个变量的变量槽就可以被复用</li><li>操作数栈：为当前方法运行提供了一个临时计算过程结果的存储</li><li>动态链接：在运行期间部分符号引用转变为直接引用，为了支持java多态</li><li>返回地址：<ol><li>遇到方法返回的字节码指令</li><li>出现了异常，有异常处理则交给异常处理器，否则抛异常</li></ol></li></ul><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><h2 id="本地方法栈是什么"><a href="#本地方法栈是什么" class="headerlink" title="本地方法栈是什么"></a>本地方法栈是什么</h2><p>先介绍虚拟机栈，然后：类似虚拟机栈，本地方法栈为java虚拟机提供native方法的服务。native方法一般是由C&#x2F;C++编写</p><h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><p>方法区： 首先它是虚拟机规范的抽象概念。 他是所有线程共享的内存区域，在hotspot jkd1.8之前，方法区的实现是永久代。而在jdk 1.8，采用的是元空间</p><h2 id="对于永久代和元空间主要有以下两个区别："><a href="#对于永久代和元空间主要有以下两个区别：" class="headerlink" title="对于永久代和元空间主要有以下两个区别："></a>对于永久代和元空间主要有以下两个区别：</h2><ol><li><p>永久代位于java虚拟机内，元空间位于本地内存。因此永久代受限于JVM可用内存，但是元空间使用的是直接内存，受本地内存的限制，因此内存溢出的可能性更小。</p></li><li><p>永久代本身是面向堆来设计的，所以存储在永久代的对象不是内存连续的，所以需要额外的存储信息和额外的对象查找机制来定位对象，所以比较麻烦。（最开始使用永久代是为了进行一定程度的代码复用）</p></li></ol><h2 id="那么方法区到底存储了什么东西？"><a href="#那么方法区到底存储了什么东西？" class="headerlink" title="那么方法区到底存储了什么东西？"></a>那么方法区到底存储了什么东西？</h2><ol><li><p>在类加载的第一个阶段，会将类的类型信息加载进入方法区（包括类签名、属性、方法）</p></li><li><p>运行时常量池：常量池，存储了符号引用和部分直接引用，字面量等信息，运行时常量池主要负责动态解析符号引用，将符号引用转换为直接引用，以及字节码生成的字面量。以及还有一些字符串常量池，在jdk1.8之前字符串常量池在永久代中，1.8时在堆中。因此对于某些方法，比如intern方法，如果目标字符串在字符串常量池中存在，就返回其引用，否则创建并返回其在字符串常量池中的引用，那么在1.8时，由于字符串常量池在堆中，即使字符串常量池中没有对应的字符串对象，也只会创建一个指向堆中的该字符串对象的引用</p></li></ol><h2 id="既然提到了类加载机制，不妨谈谈类加载机制？"><a href="#既然提到了类加载机制，不妨谈谈类加载机制？" class="headerlink" title="既然提到了类加载机制，不妨谈谈类加载机制？"></a>既然提到了类加载机制，不妨谈谈类加载机制？</h2><p>类加载机制是将javac编译产生的.class对象中的二进制数据读入到方法区中的常量池，然后在堆区创建一个此类的class对象，通过这个class对象可以访问到方法区中的类信息</p><p>分为加载、链接（验证、准备、解析）、初始化这几个步骤</p><ul><li><p>加载：</p><ol><li>通过类的全限定名（ 包名 + 类型名）获取此类的二进制流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个该类的class对象，作为方法区类信息的访问入口</li></ol></li><li><p>验证：<br>确保class文件的字节流所包含的class类信息符合虚拟机规范</p></li><li><p>文件格式验证：字节流是否符合标准</p><ol><li>元数据验证：验证数据是否合理，比如所有类应该有父类</li><li>字节码验证：验证字节码是否会危害虚拟机，因此java具有安全性</li><li>符号引用验证（发生在解析阶段，因此链接不仅仅是准备阶段前）：检查常量池中引用的外部类是否存在，可以正常访问</li></ol></li><li><p>准备：为类变量分配内存并设置类变量初始值的阶段（局部变量不存在准备阶段，不能被赋值就不能被使用）。如果是final修饰，意味者在Class文件中，该字段的属性表中存在Constantvalue属性，此时初值设置为代码里写的。如果不是，就设置成零值，等到初始化阶段再赋值</p></li><li><p>解析：虚拟机将常量池的符号引用转化为直接引用</p></li><li><p>初始化：开始执行类中的java代码，调用类构造器</p></li></ul><h2 id="类加载器有哪些？"><a href="#类加载器有哪些？" class="headerlink" title="类加载器有哪些？"></a>类加载器有哪些？</h2><p>首先类加载器是属于JVM规范，是抽象概念</p><p>在规范中类加载器分为Bootstrap ClassLoader和Other，也就是启动类加载器和非启动类加载器</p><p>在hotspot实现中，bootstrap classloader是C&#x2F;C++实现（加载<java_home>&#x2F;lib），无法作为对象被程序引用。other类包括：extension classloader（加载<java_home>&#x2F;lib&#x2F;ext），applicaition classloader（加载<java_home>&#x2F;java.class.path）, user classloader（任意来源）。非bootstrap classloader（other类）都采用java来实现，都继承自java.lang.classloader，都可以作为对象被引用。除了user classloader，其他都只能从本地文件中获取字节码来加载，而user classloader可以获取任意来源的字节码。除了bootstrap classloader，其余类加载器后续加载流程都一样，因为都继承了java.lang.classloader, 在底层源码中逻辑都一样并且defineClass方法存在final修饰符，表示无法被重写。</p><h2 id="类加载模型主要是什么？"><a href="#类加载模型主要是什么？" class="headerlink" title="类加载模型主要是什么？"></a>类加载模型主要是什么？</h2><p>在默认情况下，一个限定名的类只会被一个类加载器加载，这样的话在程序中它就是唯一的，因此需要双亲委派模型</p><p>一个类加载器收到一个类的加载请求时，会先给他的父亲类去请求，这样最终一直请求到bootstrap classloader，然后再从上到下，如果父亲类加载器不能被加载，则委派给儿子类，如果没有可以被加载的，则会报ClassNotFoundException错误。越核心的类库会越被上层的类加载器加载，而某限定名的类一旦被加载过了，此后就不会被加载，这样就能有效避免类加载混乱</p><p>但是双亲委派模型由于存在设计缺陷，因此也有可能被打破：</p><p>因为java类加载器在加载第一个类的时候，这个类所引用的其他类也是由于这个类加载器去加载。这样的话，比如jdbc是没办法实现的，因此需要打破双亲委派模型</p><ul><li>打破的情况：</li></ul><ol><li>自定义类重写java.lang.loadClass方法，以实现自己的类加载逻辑</li><li>OSGi</li><li>SPI</li></ol><ul><li>哪些框架破坏了双亲委派模型？</li></ul><ol><li>Tomcat</li><li>Springboot</li><li>OSGi</li></ol><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的基本结构"><a href="#堆的基本结构" class="headerlink" title="堆的基本结构"></a>堆的基本结构</h2><p>堆存放对象实例，可以分为新生代和老年代。新生代又分为伊甸园、from区、to区</p><p>也是虚拟机中管理内存的最大一块，被线程共享，物理上不连续（因此速度相比慢，由于cache命中率低），逻辑上连续</p><p>堆也可以通过参数-Xms -Xmx设置堆的最小容量和最大容量</p><p>同时也是GC的主要地方</p><h2 id="详细解释一下GC"><a href="#详细解释一下GC" class="headerlink" title="详细解释一下GC"></a>详细解释一下GC</h2><h3 id="为什么要GC"><a href="#为什么要GC" class="headerlink" title="为什么要GC?"></a>为什么要GC?</h3><p>GC就是垃圾回收，java提供的GC可以自动监测对象是否超过作用域从而达到自动回收内存的目的，防止内存占用过多导致内存溢出</p><h3 id="可以作为GC-roots的对象有哪些？"><a href="#可以作为GC-roots的对象有哪些？" class="headerlink" title="可以作为GC roots的对象有哪些？"></a>可以作为GC roots的对象有哪些？</h3><ul><li>虚拟机栈中引用的对象，例如方法堆栈中的参数，局部变量，临时变量等</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中Native方法引用的对象</li><li>Java虚拟机内部的引用对象，比如基本数据类型对应的Class对象、线程等</li></ul><h3 id="什么情况下会被回收？"><a href="#什么情况下会被回收？" class="headerlink" title="什么情况下会被回收？"></a>什么情况下会被回收？</h3><p>当对象不存活的时候会被回收，判断对象存活与否有两种：</p><ul><li>第一点是引用计数法，给对象添加一个引用计数器。当一个对象被引用，计数器就加1，当一个对象被取消引用，就-1。计数器为0的对象是会被回收的。但是有弊端：循环引用造成对象不可能会被回收</li><li>第二点是可达性分析，以GC roots为起点，从这些节点向下搜索，通过引用链看能不能找到</li></ul><h3 id="如何可达性分析？"><a href="#如何可达性分析？" class="headerlink" title="如何可达性分析？"></a>如何可达性分析？</h3><p>不同的引用类型，主要体现的是对象不同的可达性（reachable）状态和对垃圾收集的影响</p><p>分为强引用、软引用、弱引用、虚引用</p><ul><li>强引用：只要还有强引用指向该对象，就说明还存活</li><li>软引用：只有当JVM内存不足时，才会回收软引用的对象</li><li>弱引用：不管内存够不够，都会回收只有弱引用的对象</li><li>虚引用：等于没有被引用，在任何时候都可能被回收，目的是为了在对象被垃圾回收时起到一个通知作用</li></ul><h3 id="GC根据作用域划分："><a href="#GC根据作用域划分：" class="headerlink" title="GC根据作用域划分："></a>GC根据作用域划分：</h3><ul><li>Minor GC：只是回收新生代</li><li>Major GC: 只是回收老年代</li><li>Full GC: 整堆回收</li><li>Mixed GC: 收集整个新生代和部分老年代的垃圾（目前只有G1 GC会有这种行为）</li></ul><h3 id="堆分配策略："><a href="#堆分配策略：" class="headerlink" title="堆分配策略："></a>堆分配策略：</h3><p>首先大部分情况分配在伊甸园区，如果伊甸园内存不足，触发Minor GC，当然大对象直接进入老年代。接着长期存活的对象进入老年代（在新生代存活时间超过一定阈值的对象，每经过一次Minor GC 都会增长一次年龄）</p><p>此外，还有一些机制保证GC:</p><p>动态年龄判定以及空间分配担保</p><ul><li>动态年龄判定：当Survivor区中相同年龄对象的总和大于Survivor空间的一半时，则年龄大于或等于该年龄的对象可以直接进入老年区，不用直接达到阈值</li><li>空间分配担保：在发生Minor GC之前，虚拟机要看老年代最大可用的连续空间是否大于新生代所有的对象空间，如果是，则Minor GC是安全的，否则虚拟机会看老年代最大的连续空间是否大于历次晋升到老年代的平均大小，如果大则担保成功，触发Minor GC。否则，触发Full GC</li></ul><h3 id="四大回收算法"><a href="#四大回收算法" class="headerlink" title="四大回收算法"></a>四大回收算法</h3><ul><li>标记清除算法：将需要回收的对象标记，然后清除。缺点是会产生内存碎片</li><li>复制算法：为了解决内存碎片问题。将内存分为相同大小的两块，每次只使用其中的一块，当其中一块用完了则复制到另一块，并且这一块全部回收。缺点是内存占用大</li><li>标记整理算法：和标记清除算法一样，但是不同的是后续不是直接清理，而是让所以存活的对象移动到同一端</li><li>分代收集算法：严格来说不是一套理论，而是综合以上三种算法根据不同情况选择不同的回收算法。一般来说，新生代使用复制算法，老年代使用标记清除算法或者标记整理算法</li></ul><h3 id="为什么需要Survivor-区？"><a href="#为什么需要Survivor-区？" class="headerlink" title="为什么需要Survivor 区？"></a>为什么需要Survivor 区？</h3><p>如何没有Survivor区，那么会直接进入Old区，这样会导致Old区很快被填满，但是由于虽然一次Minor GC没有回收，但也不会存活几次。因此放在Survivor区可以减少Major GC的发生。当存活年龄达到16次时再进入Old区</p><h3 id="Survivor-区为什么需要两个？"><a href="#Survivor-区为什么需要两个？" class="headerlink" title="Survivor 区为什么需要两个？"></a>Survivor 区为什么需要两个？</h3><p>因为一个的话由于标记清除会导致内存碎片问题，但是两个区域的话，将Eden区和From区复制到To区，第二次GC时再交换From和To的职责，将Edge和To区复制到From区。这样永远有一个Survivor区是空的，另一个非空的是无碎片的。为什么不继续分多一点？因为再细分下去，每一块的Survivor的空间会更小，两块综合考虑更好</p><h3 id="那么有哪些垃圾回收器？"><a href="#那么有哪些垃圾回收器？" class="headerlink" title="那么有哪些垃圾回收器？"></a>那么有哪些垃圾回收器？</h3><p>主要可以分为四类垃圾收集器：</p><ol><li><p>串行垃圾收集器：</p><ul><li>serial gc:单线程垃圾收集器，使用时必须先stop the world（进入一个安全点，其他用户线程均阻塞），然后直到他收集结束。采取标记复制算法。通常在单核cpu或较小的应用中去使用</li><li>serial old gc:serial gc的老年代版本，单线程垃圾回收，采取标记整理算法</li></ul></li><li><p>吞吐量优先的垃圾回收器：</p><ul><li>Parallel gc：并行垃圾回收器.工作在新生代，采用标记复制算法，多线程垃圾回收算法，线程数量与CPU核数相关。以吞吐量优先意味着总的时间花费少</li><li>Parallel old gc：并行垃圾回收器.区别在于工作在老年代</li></ul></li><li><p>响应时间优先</p></li></ol><p>CMS GC：并发垃圾收集器，工作在老年代，如果并发失败，会退化成serial old。采用的是并发标记清除算法</p><p>当触发垃圾回收机制时，有以下4个阶段：</p><pre><code>1. 初始标记：短暂地stop the world，标记直接与gc roots能直接关联的对象2. 并发标记：从gc roots开始进行可达性分析，标记存活对象，用户线程不需要暂停，不需要stop the world。由三色标记算法保证3. 重新标记：由于并发标记阶段可能引用发生了变化，发生错标、漏标，因此需要stop the world来重新标记4. 并发清理：清理未标记对象，用户线程不需要暂停</code></pre><p>整个过程消耗时间最长的是并发标记和并发清除阶段，这两个阶段垃圾收集线程可以和用户线程一起工作。</p><p>优点是并发收集，停顿时间短</p><p>缺点是标记清除算法，会导致大量内存碎片以及会产生浮动垃圾，因为并发清理阶段还有用户线程在运行，就会产生新的垃圾</p><p>ParNew GC:与之配合，工作在新生代，基于复制算法的垃圾回收器</p><ol start="4"><li>同时注重吞吐量和低延迟的G1垃圾收集器，JDK9默认</li></ol><p>G1将堆分为相同大小的分区，每个分区大小是2的幂次方。有4种不同类型的分区，eden，survivor，old，humongous</p><p>整体上是标记整理算法，两个区域之间采取的是标记复制算法</p><p>整体分为以下几个步骤：</p><pre><code>1. 初始标记。暂停其他线程，记录直接与gc roots相连的对象2. 并发标记。从gc roots开始进行可达性分析，找出要回收的对象，耗时较长，不过可以与用户程序同时执行。3. 最终标记。需要对其他线程做短暂的暂停，用于处理并发标记阶段对象出现引用变化的区域4. 筛选回收。对整个分区的回收价值和成本进行排序，然后根据用户所期望的停顿时间来制作回收计划。把回收的分区的存活对象复制到空的分区中，再清理掉整个旧的分区的全部空间。因此也需要stop the world</code></pre><h3 id="三色标记算法？"><a href="#三色标记算法？" class="headerlink" title="三色标记算法？"></a>三色标记算法？</h3><p>整个标记过程：</p><ol><li><p>将标记对象分为三种颜色：</p><ul><li>白色——该对象没有被标记过（垃圾）</li><li>灰色——对象已经被标记过，但他的属性没有被标记完</li><li>黑色——对象已经被标记过，他的属性也标记完了</li></ul></li></ol><p>初始时，所有对象都在白色集合里面，然后从gc roots开始进行可达性分析，将gc roots直接引用的对象移动到灰色集合，然后再从灰色集合中根据属性不断再取出新的标记对象，放到灰色集合里面，然后将本对象放到黑色集合里面。如此反复直到没有灰色对象</p><ol start="2"><li><p>优点：用于垃圾回收，将stw升级为并发标记。然后避免重复标记，提高了效率</p></li><li><p>存在的问题：</p></li></ol><p>由于并发标记阶段对象引用发生变化，所以会出现错标和漏标的情况</p><p>浮动垃圾：在并发标记阶段，已经被标记成黑色或灰色的对象，突然变成了垃圾，由于不会再对黑色的对象重新扫描，那么这个对象不是白色的但是会被清除。于是只能留到下一次gc去回收，所以一般情况下老年代占到百分之80到90就回收</p><p>对象漏标问题：<br>在并发标记对象，一个对象是黑色，但是这个对象引用发生了变化，引用到了需要被回收的对象</p><p>因此漏标问题一定要解决，对于不同的垃圾回收器处理策略也不一样</p><ul><li><p>cms：写屏障+增量更新</p></li><li><p>g1：写屏障+原始快照 stab</p></li><li><p>zgc：读屏障</p></li><li><p>增量更新：如果白色对象被重新指定引用，那么被指定的对象是黑色，那么就将这个引用记录下来，之后等并发标记结束后，再重新扫描一遍，以黑色对象为根，相当于黑色对象变成了灰色</p></li><li><p>原始快照 stab：当灰色对象要删除指向白色对象的引用时，将这个要删除的引用记录下来，并发标记结束后再重新扫描一遍</p></li></ul><h3 id="什么是跨代引用？"><a href="#什么是跨代引用？" class="headerlink" title="什么是跨代引用？"></a>什么是跨代引用？</h3><p>java中不同代存在引用，比如新生代引用老年代</p><p>问题：比如在minor gc时，存在老年代指向新生代的引用，但是由于是minor gc，将会产生漏标问题</p><p>解决：minor gc时，将整个老年代的对象也加入扫描范围，但是这样做效率太低，因此引入记忆集的数据结构<br>记忆集是在新生代开辟一个空间来存储一个集合，用来存放老年代对新生代的引用，因此在minor gc时不需要扫描整个老年代，只需要扫描新生代+记忆集。在hotspot中采用一种卡表的方式实现。卡表是使用一个字节数组实现，每个元素对应着其标识的卡页</p><h3 id="full-gc触发条件？"><a href="#full-gc触发条件？" class="headerlink" title="full gc触发条件？"></a>full gc触发条件？</h3><ul><li>System.gc() 主动</li><li>老年代空间不足</li><li>空间分配担保失败</li><li>jdk1.7及之前的永久代空间不足</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用设计模式</title>
      <link href="/posts/Java%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
      <url>/posts/Java%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式就是: 在程序运行期间, 某些类有且最多只有一个实例对象</p><h2 id="饿汉模式-静态常量"><a href="#饿汉模式-静态常量" class="headerlink" title="饿汉模式(静态常量)"></a>饿汉模式(静态常量)</h2><p>饥饿模式又称为饿汉模式, 指的是JVM在加载类的时候就完成类对象的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式(静态常量)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line">    <span class="comment">//构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//本类创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton1</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line">    <span class="comment">//提供一个公有的静态方法，返回对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>优点：JVM层面的线程安全。JVM在加载这个类的时候就会对它进行初始化, 因此JVM层面包证了线程安全</li><li>缺点：造成空间的浪费</li></ul><h2 id="饿汉模式（静态代码块）"><a href="#饿汉模式（静态代码块）" class="headerlink" title="饿汉模式（静态代码块）"></a>饿汉模式（静态代码块）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式(静态代码块)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="comment">//构造器私有化，外部不能new</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//本类创建对象实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供一个公有的静态方法，返回对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。</p><h2 id="饿汉模式（枚举）"><a href="#饿汉模式（枚举）" class="headerlink" title="饿汉模式（枚举）"></a>饿汉模式（枚举）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton8</span> &#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的(枚举类也是在JVM层面保证的线程安全)，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p><h2 id="懒汉模式（线程不安全，不可用）"><a href="#懒汉模式（线程不安全，不可用）" class="headerlink" title="懒汉模式（线程不安全，不可用）"></a>懒汉模式（线程不安全，不可用）</h2><p>真正需要的时候再完成类对象的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式(线程不安全)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建instance 即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：节省空间</li><li>缺点：线程不安全</li></ul><h2 id="懒汉模式（线程安全，同步方法，不推荐用）"><a href="#懒汉模式（线程安全，同步方法，不推荐用）" class="headerlink" title="懒汉模式（线程安全，同步方法，不推荐用）"></a>懒汉模式（线程安全，同步方法，不推荐用）</h2><p>通过<code>synchronized</code>关键字对获取实例的方法进行同步限制, 实现了线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式(线程安全)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton4</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton4</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建instance 即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton4 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton4</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>优点：线程安全</li><li>缺点：对所有线程的访问都会进行同步操作, 有很严重的性能问题</li></ul><h2 id="懒汉模式（线程不安全，同步代码块，不可用）"><a href="#懒汉模式（线程不安全，同步代码块，不可用）" class="headerlink" title="懒汉模式（线程不安全，同步代码块，不可用）"></a>懒汉模式（线程不安全，同步代码块，不可用）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式(线程安全, 同步代码块)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton5 instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton5</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建instance 即懒汉式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton5.class)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Singleton5</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了if (instance &#x3D;&#x3D; null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例</p><h2 id="懒汉模式（线程安全，双重检查-推荐用）"><a href="#懒汉模式（线程安全，双重检查-推荐用）" class="headerlink" title="懒汉模式（线程安全，双重检查, 推荐用）"></a>懒汉模式（线程安全，双重检查, 推荐用）</h2><p>双重检查锁(Double Checked Locking, 简称DCL)模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双重检查</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton6</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton6</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton6 instance;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton5.class)&#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton6</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多处理器的共享内存、或者编译器的优化下, DCL模式并不一定线程 —— 可能 (注意: 只是可能出现) 会发生指令的重排序, 出现半个对象的问题</p><p>Java中创建一个对象的过程并不是原子性操作，可能会发生指令的重排序（先把这个实例的引用指向地址，再对成员初始化）, 出现半个对象的问题</p><p>因此要用<code>volatile</code>关键字修饰<code>instance</code>变量</p><p>半对象问题：当一个线程进来的时候，判断对象是否为空？肯定为空，因为还没创建呢，往下执行，拿到锁，继续往下执行，再次判断是否为空？为空，往下执行，在new对象的时候，对象有个半初始化的一个状态，在执行完new的时候，分配了一块空间，成员变量是引用类型那么它的值为null，就在此时，<code>invokespecial</code>和<code>astore 1</code>发生了指令重排序，直接将<code>instance</code>指向了初始化一半还没有调用构造方法的内存空间，这时候第二个线程进来了，判断对象为空吗？不为空，为啥？因为它指向了一个半初始化的一个对象嘛！既然不为空，我就直接返回了这个初始化一半的对象</p><h2 id="懒汉式（线程安全，静态内部类，推荐用）"><a href="#懒汉式（线程安全，静态内部类，推荐用）" class="headerlink" title="懒汉式（线程安全，静态内部类，推荐用）"></a>懒汉式（线程安全，静态内部类，推荐用）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton7</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton7</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建instance 即懒汉式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton7</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton7</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton7 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>JVM在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类(SingletonHolder)的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性(instance)</li><li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li></ul><h2 id="破坏单例模式"><a href="#破坏单例模式" class="headerlink" title="破坏单例模式"></a>破坏单例模式</h2><p>除枚举方式外, 其他方法都会通过反射的方式破坏单例</p><ol><li><p>反射是通过调用构造方法生成新的对象, 可以在构造方法中进行判断 —— 若已有实例, 则阻止生成新的实例,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;Singleton already initialized, 此类是单例类, 不允许生成新对象, 请通过getInstance()获取本类对象&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果单例类实现了序列化接口Serializable, 就可以通过反序列化破坏单例。可以不实现序列化接口, 或者重写反序列化方法readResolve(), 反序列化时直接返回相关单例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化时直接返回当前实例</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Object#clone()方法也会破坏单例, 即使你没有实现Cloneable接口 —— 因为clone()方法是Object类中的。可以重写clone()方法, 并在其中抛出异常信息“Can not create clone of Singleton class”</p></li></ol><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p><img src="/img/Java%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-5.png" alt="alt text"></p><ul><li><p>Factory: 工厂角色 负责根据不同的参数创建不同的实例。</p></li><li><p>IProduct: 抽象产品角色 所有产品实例的接口，负责描述所有产品实例的行为。</p></li><li><p>Product(A B ..): 具象产品角色，所有产品的实例，实现了抽象产品定义的代码</p></li></ul><p>示例:</p><p>平台做一个机票代购业务，对接了两个供应商A、B，用户选择完机票后，平台拿着机票去供应商下单。下单时根据机票由那个供应商提供去相应的供应商去下单。</p><ol><li><p>定义一个下单接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IVender</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 供应商下单方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">order</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分别实现A、B供应商的下单方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VendorA</span> <span class="keyword">implements</span> <span class="title class_">IVender</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">order</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;A供应商下单成功,下单时间&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VendorB</span> <span class="keyword">implements</span> <span class="title class_">IVender</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">order</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 业务逻辑处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;B供应商下单成功，下单时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接着定义一个工厂类，根据传入的不同参数请求，分别创建不同的供应商实例并返回，若碰到无效的参数，则抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VendorFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IVender <span class="title function_">createVendor</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VendorA</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VendorB</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;供应商不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后，由我们客户端进行调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line">        <span class="type">IVender</span> <span class="variable">iVender</span> <span class="operator">=</span> VendorFactory.createVendor(type);</span><br><span class="line">        iVender.order();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>缺点：缺点在于不符合<code>开闭原则</code>，每次添加新产品就需要修改工厂类。在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展维护，并且工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><ul><li>工厂方法模式将工厂抽象化，并定义一个创建对象的接口。每增加新产品，只需增加该产品以及对应的具体实现工厂类，由具体工厂类决定要实例化的产品是哪个，将对象的创建与实例化延迟到子类，这样工厂的设计就符合“开闭原则”了，扩展时不必去修改原来的代码。</li><li>缺点：但缺点在于，每增加一个产品都需要增加一个具体产品类和实现工厂类，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</li></ul><ol><li><p>抽象产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂方法的抽象产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interviewer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">askQuestion</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体产品</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Developer</span> <span class="keyword">implements</span> <span class="title class_">Interviewer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">askQuestion</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;询问设计模式相关的问题&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommunityExecutive</span> <span class="keyword">implements</span> <span class="title class_">Interviewer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">askQuestion</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;询问社区建设相关的问题&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HiringManager</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象工厂方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Interviewer <span class="title function_">makeInterviewer</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">takeInterviewer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Interviewer</span> <span class="variable">interviewer</span> <span class="operator">=</span> makeInterviewer(); <span class="comment">//创建具体的</span></span><br><span class="line">        interviewer.askQuestion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体工厂（决定要实例化的产品是哪个）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DevelopmentManager</span> <span class="keyword">extends</span> <span class="title class_">HiringManager</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Interviewer <span class="title function_">makeInterviewer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Developer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MarketingManager</span> <span class="keyword">extends</span> <span class="title class_">HiringManager</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Interviewer <span class="title function_">makeInterviewer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommunityExecutive</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式定义了一系列的算法，并将每一个算法封装起来，使每个算法可以相互替代，使算法本身和使用算法的客户端分割开来，相互独立</p><ol><li><p>策略接口角色IStrategy：用来约束一系列具体的策略算法，策略上下文角色ConcreteStrategy使用此策略接口来调用具体的策略所实现的算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//策略接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IStrategy</span> &#123;</span><br><span class="line">    <span class="comment">//定义的抽象算法方法 来约束具体的算法实现方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithmMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体策略实现角色ConcreteStrategy：具体的策略实现，即具体的算法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 具体的策略实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteStrategy</span> <span class="keyword">implements</span> <span class="title class_">IStrategy</span> &#123;</span><br><span class="line">     <span class="comment">//具体的算法实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">algorithmMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is ConcreteStrategy method...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>策略上下文角色StrategyContext：策略上下文，负责具体的策略实现交互，通常策略上下文对象会持有一个真正的策略实现对象，策略上下文还可以让具体的策略实现从其中获取相关数据，回调策略上下文对象的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyContext</span> &#123;</span><br><span class="line">    <span class="comment">//持有一个策略实现的引用</span></span><br><span class="line">    <span class="keyword">private</span> IStrategy strategy;</span><br><span class="line">    <span class="comment">//使用构造器注入具体的策略类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StrategyContext</span><span class="params">(IStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//调用策略实现的方法</span></span><br><span class="line">        strategy.algorithmMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>外部客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建具体测策略实现</span></span><br><span class="line">        <span class="type">IStrategy</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteStrategy</span>();</span><br><span class="line">        <span class="comment">//2.在创建策略上下文的同时，将具体的策略实现对象注入到策略上下文当中</span></span><br><span class="line">        <span class="type">StrategyContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyContext</span>(strategy);</span><br><span class="line">        <span class="comment">//3.调用上下文对象的方法来完成对具体策略实现的回调</span></span><br><span class="line">        ctx.contextMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>缺点：</li></ul><ol><li>客户端必须了解所有的策略，清楚它们的不同：<br>如果由客户端来决定使用何种算法，那客户端必须知道所有的策略，清楚各个策略的功能和不同，这样才能做出正确的选择，但是这暴露了策略的具体实现</li><li>增加了对象的数量：<br>由于策略模式将每个具体的算法都单独封装为一个策略类，如果可选的策略有很多的话，那对象的数量也会很多</li><li>只适合偏平的算法结构：<br>由于策略模式的各个策略实现是平等的关系（可相互替换），实际上就构成了一个扁平的算法结构。即一个策略接口下面有多个平等的策略实现（多个策略实现是兄弟关系），并且运行时只能有一个算法被使用。这就限制了算法的使用层级，且不能被嵌套</li></ol><ul><li>本质：<br>分离算法，选择实现。如果没有上下文，策略模式就回到了最基本的接口和实现了，只要是面向接口编程，就能够享受到面向接口编程带来的好处，通过一个统一的策略接口来封装和分离各个具体的策略实现，无需关系具体的策略实现。貌似没有上下文什么事，但是如果没有上下文的话，客户端就必须直接和具体的策略实现进行交互了，尤其是需要提供一些公共功能或者是存储一些状态的时候，会大大增加客户端使用的难度；引入上下文之后，这部分工作可以由上下文来完成，客户端只需要和上下文进行交互就可以了。这样可以让策略模式更具有整体性，客户端也更加的简单</li></ul><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><ul><li>前言：代理(Proxy)模式是一种结构型设计模式，提供了对目标对象另外的访问方式；即通过代理对象访问目标对象。<br><img src="/img/Java%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image.png" alt="alt text"></li></ul><p>代理模式大致有三种角色：</p><ul><li>Real Subject：真实类，也就是被代理类、委托类。用来真正完成业务服务功能；</li><li>Proxy：代理类，将自身的请求用 Real Subject 对应的功能来实现，代理类对象并不真正的去实现其业务功能；</li><li>Subject：定义 RealSubject 和 Proxy 角色都应该实现的接口。</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理需要先定义接口，被代理对象与代理对象一起实现相同的接口，然后通过调用相同的方法来调用目标对象的方法。<br><img src="/img/Java%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-1.png" alt="alt text"></p><ul><li>优点：静态代理模式在不改变目标对象的前提下，实现了对目标对象的功能扩展。</li><li>缺点：静态代理实现了目标对象的所有方法，一旦目标接口增加方法，代理对象和目标对象都要进行相应的修改，增加维护成本。</li></ul><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="JDK代理"><a href="#JDK代理" class="headerlink" title="JDK代理"></a>JDK代理</h3><p><img src="/img/Java%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-2.png" alt="alt text"></p><ul><li><p>原理：JDK动态代理对象不需要实现接口，但是目标对象必须实现接口。代理对象会实现与目标类一样的方法，并将方法调用转发给目标对象</p></li><li><p>样例：有一天公司增加了业务，出售的商品越来越多，售后也需要更上。但是公司发现原来的代理商，还要再培训才能完成全部的业务，于是就找了另外的动态代理商B 。 代理商B 承诺无缝对接公司所有的业务，不管新增什么业务，均不需要额外的培训即可完成</p></li></ul><ol><li><p>公司增加了维修业务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口添加方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TVCompany</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产电视机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 电视机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">produceTV</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 维修电视机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tv 电视机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 电视机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">repair</span><span class="params">(TV tv)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>工厂也得把维修业务搞起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TVFactory</span> <span class="keyword">implements</span> <span class="title class_">TVCompany</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">produceTV</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TV factory produce TV...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TV</span>(<span class="string">&quot;小米电视机&quot;</span>,<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">repair</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tv is repair finished...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TV</span>(<span class="string">&quot;小米电视机&quot;</span>,<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>B代理商 全面代理公司所有的业务。使用Proxy.newProxyInstance方法生成代理对象，实现InvocationHandler中的 invoke方法，在invoke方法中通过反射调用代理类的方法，并提供增强方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新增代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TVProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TVProxyFactory</span><span class="params">(Object o)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target = o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        ClassLoader loader：指定当前目标对象使用类加载器，获取加载器的方法是固定的。</span></span><br><span class="line"><span class="comment">        Class&lt;?&gt;[] interfaces：目标对象实现的接口的类型，使用泛型方式确认类型。</span></span><br><span class="line"><span class="comment">        InvocationHandler h：事件处理，执行目标对象的方法时，会触发事件处理器的方法，会把当前执行目标对象的方法作为参数传入。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(), target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;TV proxy find factory for tv.... &quot;</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">                <span class="keyword">return</span> invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TVConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TVCompany</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TVFactory</span>();</span><br><span class="line">        <span class="type">TVCompany</span> <span class="variable">tvCompany</span> <span class="operator">=</span> (TVCompany) <span class="keyword">new</span> <span class="title class_">TVProxyFactory</span>(target).getProxy();</span><br><span class="line">        <span class="type">TV</span> <span class="variable">tv</span> <span class="operator">=</span> tvCompany.produceTV();</span><br><span class="line">        tvCompany.repair(tv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>缺点：JDK 动态代理有一个最致命的问题是它只能代理实现了某个接口的实现类（因为java是单继承，生成的新的代理类继承Proxy），并且代理类也只能代理接口中实现的方法，要是实现类中有自己私有的方法，而接口中没有的话，该方法不能进行代理调用</p><p>事务失效场景：内部调用，当类内部的方法调用另一个带有 @Transactional 注解的方法时，这个调用不会通过 Spring 的代理对象进行，而是直接通过 this 引用，因此 Spring 无法拦截并应用事务。Spring AOP 代理机制只能拦截通过代理对象进行的方法调用，而不能拦截类内部的直接方法调用</p><p>解决：</p><p>其中一种解决方法是在类内部通过 Spring 容器获取当前对象的代理实例，然后通过代理对象调用目标方法，从而让事务生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publicMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 从 Spring 容器中获取代理对象</span></span><br><span class="line">        <span class="type">TransactionService</span> <span class="variable">proxy</span> <span class="operator">=</span> context.getBean(TransactionService.class);</span><br><span class="line">        proxy.internalMethod(); <span class="comment">// 通过代理对象调用方法，事务生效</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">internalMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 事务在这里生效</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Cglib代理"><a href="#Cglib代理" class="headerlink" title="Cglib代理"></a>Cglib代理</h3><p>Cglib代理可以称为子类代理，是在内存中构建一个子类对象，从而实现对目标对象功能的扩展。它不要求目标类实现接口中的方法，而是基于字节码生成技术，生成目标类的子类作为代理类，并重写父类的方法和增强逻辑</p><p><img src="/img/Java%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-3.png" alt="alt text"></p><p>Cglib通过Enhancer 来生成代理类，通过实现MethodInterceptor接口，并实现其中的intercept方法，在此方法中可以添加增强方法，并可以利用反射Method或者MethodProxy继承类 来调用原方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TVProxyCglib</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给目标对象创建一个代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Class c)</span>&#123;</span><br><span class="line">        <span class="comment">//1.工具类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//2.设置父类</span></span><br><span class="line">        enhancer.setSuperclass(c);</span><br><span class="line">        <span class="comment">//3.设置回调函数，调用方法的时候先调用intercept（拦截器）方法，执行我们定义的方法的增强链（也就是设置）</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//4.创建子类（代理对象）</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TVProxyFactory enhancement.....&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新代理的B工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TVFactoryB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">produceTVB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tv factory B producing tv.... &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TV</span>(<span class="string">&quot;华为电视机&quot;</span>, <span class="string">&quot;南京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TV <span class="title function_">repairB</span><span class="params">(TV tv)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tv B is repair finished.... &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C代理可以直接和公司合作，也可以和工厂打交道。并且可以代理任何工厂的产品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TVConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TVCompany</span> <span class="variable">tvCompany</span> <span class="operator">=</span> (TVCompany) <span class="keyword">new</span> <span class="title class_">TVProxyCglib</span>().getProxyInstance(TVFactory.class);</span><br><span class="line">        <span class="type">TV</span> <span class="variable">tv</span> <span class="operator">=</span> tvCompany.produceTV();</span><br><span class="line">        tvCompany.repair(tv);</span><br><span class="line">        System.out.println(<span class="string">&quot;==============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">TVFactoryB</span> <span class="variable">tvFactoryB</span> <span class="operator">=</span> (TVFactoryB) <span class="keyword">new</span> <span class="title class_">TVProxyCglib</span>().getProxyInstance(TVFactoryB.class);</span><br><span class="line">        <span class="type">TV</span> <span class="variable">tv</span> <span class="operator">=</span> tvFactoryB.produceTVB();</span><br><span class="line">        tvFactoryB.repairB(tv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TVProxyFactory enhancement.....</span><br><span class="line">TV factory produce TV...</span><br><span class="line">TVProxyFactory enhancement.....</span><br><span class="line">tv is repair finished...</span><br><span class="line">==============================</span><br><span class="line">TVProxyFactory enhancement.....</span><br><span class="line">tv factory B producing tv.... </span><br><span class="line">TVProxyFactory enhancement.....</span><br><span class="line">tv B is repair finished.... </span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="Spring-AOP使用代理"><a href="#Spring-AOP使用代理" class="headerlink" title="Spring AOP使用代理"></a>Spring AOP使用代理</h2><p>Spring中AOP的实现有JDK和Cglib两种，如下图：</p><p><img src="/img/Java%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-4.png" alt="alt text"></p><ul><li>如果目标对象需要实现接口，则使用JDK代理</li><li>如果目标对象不需要实现接口，则使用Cglib代理</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>静态代理：需要代理类和目标类都实现接口的方法，从而达到代理增强其功能</li><li>JDK动态代理：需要代理类实现某个接口，使用Proxy.newProxyInstance方法生成代理类，并实现InvocationHandler中的invoke方法，实现增强功能</li><li>Cglib动态代理：无需代理类实现接口，使用Cblib中的Enhancer来生成代理对象子类，并实现MethodInterceptor中的intercept方法，在此方法中可以实现增强功能</li></ul><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p>核心思想是：父类定义骨架，子类实现某些细节</p><p>为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用final。对于需要子类实现的抽象方法，一般声明为protected，使得这些方法对外部客户端不可见</p><ol><li><p>父类定义骨架</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSetting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getSetting</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">//从缓存读取</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> lookupCache(key);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在缓存中未找到,从数据库读取</span></span><br><span class="line">            value = readFromDatabase(key);</span><br><span class="line">            <span class="comment">// 放入缓存</span></span><br><span class="line">            putIntoCache(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title function_">lookupCache</span><span class="params">(String key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">putIntoCache</span><span class="params">(String key, String value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>子类实现某些细节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisSetting</span> <span class="keyword">extends</span> <span class="title class_">AbstractSetting</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">RedisClient</span> <span class="variable">client</span> <span class="operator">=</span> RedisClient.create(<span class="string">&quot;redis://localhost:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">lookupCache</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;</span><br><span class="line">            RedisCommands&lt;String, String&gt; commands = connection.sync();</span><br><span class="line">            <span class="keyword">return</span> commands.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">putIntoCache</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (StatefulRedisConnection&lt;String, String&gt; connection = client.connect()) &#123;</span><br><span class="line">            RedisCommands&lt;String, String&gt; commands = connection.sync();</span><br><span class="line">            commands.set(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AbstractSetting</span> <span class="variable">setting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisSetting</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;autosave = &quot;</span> + setting.getSetting(<span class="string">&quot;autosave&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;autosave = &quot;</span> + setting.getSetting(<span class="string">&quot;autosave&quot;</span>));</span><br></pre></td></tr></table></figure></li></ol><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h2><p>观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式</p><ul><li>优点：</li></ul><ol><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则</li><li>目标与观察者之间建立了一套触发机制</li></ol><ul><li>缺点：</li></ul><ol><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用</li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率</li></ol><ul><li>观察者模式的结构：</li></ul><ol><li>抽象主题（subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的方法</li><li>具体主题（Concrete subject）角色：也叫具体目标类，实现了抽象目标类的方法，当具体主题的内部状态发生变化的时候，通知所有注册过的观察者对象</li><li>抽象观察者（Observer）角色：它是一个抽象类或者接口，它包含了一个更新自己的抽象方法，当接受到具体主题的更改通知时被调用</li><li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态</li></ol><p>示例：</p><p>Observer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">//更新的方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String messages)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WexinUser</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体观察者类 实现更新的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WexinUser</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WexinUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WexinUser</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String messages)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;--&gt;&quot;</span> + messages);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Subject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象主题类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//增加订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通知订阅者更新消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String messages)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SubscriptionSubject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体主题(具体被观察者)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//存储订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; weixinUserList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserList.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserList.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SubscriptionSubject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubscriptionSubject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建微信用户</span></span><br><span class="line">        <span class="type">WexinUser</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WexinUser</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="type">WexinUser</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WexinUser</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        <span class="type">WexinUser</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WexinUser</span>(<span class="string">&quot;王五&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//订阅公众号</span></span><br><span class="line">        subject.attach(user1);</span><br><span class="line">        subject.attach(user2);</span><br><span class="line">        subject.attach(user3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过订阅用户</span></span><br><span class="line">        subject.notify(<span class="string">&quot;您关注的公众号更新啦~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDK源码解析"><a href="#JDK源码解析" class="headerlink" title="JDK源码解析"></a>JDK源码解析</h2><p>在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例</p><ol><li>Observable类（抽象被观察者）<br>Observable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的3个方法</li></ol><ul><li>void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中</li><li>void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知</li><li>void setChange() 方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者</li></ul><ol start="2"><li>Observer 接口（抽象观察者）<br>Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作</li></ol><p>示例：</p><p>警擦（观察者）抓小偷（被观察者），当小偷偷东西的时警擦会被通知</p><p>Thief(被观察者)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小偷类 继承Observable接口</span></span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thief</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thief</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thief</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">steal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;emmm我正在悄悄偷东西&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.setChanged();<span class="comment">//默认为true</span></span><br><span class="line">        <span class="built_in">super</span>.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Policemen(观察者)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Policeman</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Policeman</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Policeman</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;警察：&quot;</span> + ((Thief) o).getName() + <span class="string">&quot;我抓住你了！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//小偷（被观察者）</span></span><br><span class="line">        <span class="type">Thief</span> <span class="variable">thief</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thief</span>(<span class="string">&quot;法外狂徒格雷福斯&quot;</span>);</span><br><span class="line">        <span class="comment">//警察（观察者）</span></span><br><span class="line">        <span class="type">Policeman</span> <span class="variable">policeman</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Policeman</span>(<span class="string">&quot;凯瑟琳女警&quot;</span>);</span><br><span class="line">        <span class="comment">//警察观察小偷</span></span><br><span class="line">        thief.addObserver(policeman);</span><br><span class="line">        <span class="comment">//小偷行窃</span></span><br><span class="line">        thief.steal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  打印结果：</span></span><br><span class="line"><span class="comment">    emmm我正在悄悄偷东西</span></span><br><span class="line"><span class="comment">    警察：法外狂徒格雷福斯我抓住你了！！！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashTable和HashMap的区别</title>
      <link href="/posts/HashTable%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
      <url>/posts/HashTable%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      
        <content type="html"><![CDATA[<p>1、HashMap是线程不安全的，HashTable是线程安全的</p><ul><li><p>HashMap：Fail-fast 机制。表示快速失败，在集合遍历过程中，一旦发现容器中的数据被修改了，会立刻抛出ConcurrentModificationException异常，从而导致遍历失败，像这种情况：定义一个Map集合，使用Iterator迭代器进行数据遍历，在遍历过程中，对集合数据做变更时，就会发生Fail-fast。java.util包下的集合类都是快速失败机制的, 常见的的使用Fail-fast方式遍历的容器有HashMap和ArrayList等。</p></li><li><p>HashTable：公开的方法比如get都使用了synchronized描述符。而遍历视图比如keySet都使用了Collections.synchronizedXXX进行了同步包装。并且是锁住全局的</p></li><li><p>Fail-fast底层实现：迭代器在遍历集合的过程，会维护一个modCount变量。如果在遍历过程modCount发生变化，在迭代器使用hasNext&#x2F;next遍历下一个元素的时候，都会检测modCount是否为expectedModCount的值，如果不是抛出异常。</p></li></ul><p>2、 由于线程安全，HashTable效率比不上HashMap</p><p>3、HashMap允许键为NULL，值为NULL。HashTable都不允许</p><ul><li>HashMap是支持null键和null值的，而HashTable在遇到null时，会抛出NullPointerException异常。这并不是因为HashTable有什么特殊的实现层面的原因导致不能支持null键和null值，这仅仅是因为HashMap在实现时对null做了特殊处理，将null的hashCode值定为了0，从而将其存放在哈希表的第0个bucket中。</li></ul><p>4、HashMap默认初始化数组大小是16，HashTable是11。HashMap扩容是扩大两倍，HashTable是两倍+1</p><p>5、HashMap不能直接使用hashCode计算下标，而是使用hashCode重新计算Hash值，再计算下标。HashTable使用的是hashCode计算下标（取mod）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
